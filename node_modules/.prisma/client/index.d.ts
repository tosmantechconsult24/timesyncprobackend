
/**
 * Client
**/

import * as runtime from '@prisma/client/runtime/library.js';
import $Types = runtime.Types // general types
import $Public = runtime.Types.Public
import $Utils = runtime.Types.Utils
import $Extensions = runtime.Types.Extensions
import $Result = runtime.Types.Result

export type PrismaPromise<T> = $Public.PrismaPromise<T>


/**
 * Model User
 * 
 */
export type User = $Result.DefaultSelection<Prisma.$UserPayload>
/**
 * Model Department
 * 
 */
export type Department = $Result.DefaultSelection<Prisma.$DepartmentPayload>
/**
 * Model Shift
 * 
 */
export type Shift = $Result.DefaultSelection<Prisma.$ShiftPayload>
/**
 * Model Employee
 * 
 */
export type Employee = $Result.DefaultSelection<Prisma.$EmployeePayload>
/**
 * Model InactiveEmployee
 * 
 */
export type InactiveEmployee = $Result.DefaultSelection<Prisma.$InactiveEmployeePayload>
/**
 * Model AuditLog
 * 
 */
export type AuditLog = $Result.DefaultSelection<Prisma.$AuditLogPayload>
/**
 * Model AttendanceLog
 * 
 */
export type AttendanceLog = $Result.DefaultSelection<Prisma.$AttendanceLogPayload>
/**
 * Model BiometricData
 * 
 */
export type BiometricData = $Result.DefaultSelection<Prisma.$BiometricDataPayload>
/**
 * Model LeaveBalance
 * 
 */
export type LeaveBalance = $Result.DefaultSelection<Prisma.$LeaveBalancePayload>
/**
 * Model LeaveRequest
 * 
 */
export type LeaveRequest = $Result.DefaultSelection<Prisma.$LeaveRequestPayload>
/**
 * Model Notification
 * 
 */
export type Notification = $Result.DefaultSelection<Prisma.$NotificationPayload>
/**
 * Model Setting
 * 
 */
export type Setting = $Result.DefaultSelection<Prisma.$SettingPayload>
/**
 * Model ShiftAssignment
 * 
 */
export type ShiftAssignment = $Result.DefaultSelection<Prisma.$ShiftAssignmentPayload>
/**
 * Model Terminal
 * 
 */
export type Terminal = $Result.DefaultSelection<Prisma.$TerminalPayload>
/**
 * Model TimeEntry
 * 
 */
export type TimeEntry = $Result.DefaultSelection<Prisma.$TimeEntryPayload>
/**
 * Model EmployeeRate
 * 
 */
export type EmployeeRate = $Result.DefaultSelection<Prisma.$EmployeeRatePayload>
/**
 * Model PayrollDeduction
 * 
 */
export type PayrollDeduction = $Result.DefaultSelection<Prisma.$PayrollDeductionPayload>
/**
 * Model Infraction
 * 
 */
export type Infraction = $Result.DefaultSelection<Prisma.$InfractionPayload>

/**
 * ##  Prisma Client ʲˢ
 * 
 * Type-safe database client for TypeScript & Node.js
 * @example
 * ```
 * const prisma = new PrismaClient()
 * // Fetch zero or more Users
 * const users = await prisma.user.findMany()
 * ```
 *
 * 
 * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
 */
export class PrismaClient<
  ClientOptions extends Prisma.PrismaClientOptions = Prisma.PrismaClientOptions,
  U = 'log' extends keyof ClientOptions ? ClientOptions['log'] extends Array<Prisma.LogLevel | Prisma.LogDefinition> ? Prisma.GetEvents<ClientOptions['log']> : never : never,
  ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs
> {
  [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['other'] }

    /**
   * ##  Prisma Client ʲˢ
   * 
   * Type-safe database client for TypeScript & Node.js
   * @example
   * ```
   * const prisma = new PrismaClient()
   * // Fetch zero or more Users
   * const users = await prisma.user.findMany()
   * ```
   *
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client).
   */

  constructor(optionsArg ?: Prisma.Subset<ClientOptions, Prisma.PrismaClientOptions>);
  $on<V extends U>(eventType: V, callback: (event: V extends 'query' ? Prisma.QueryEvent : Prisma.LogEvent) => void): void;

  /**
   * Connect with the database
   */
  $connect(): $Utils.JsPromise<void>;

  /**
   * Disconnect from the database
   */
  $disconnect(): $Utils.JsPromise<void>;

  /**
   * Add a middleware
   * @deprecated since 4.16.0. For new code, prefer client extensions instead.
   * @see https://pris.ly/d/extensions
   */
  $use(cb: Prisma.Middleware): void

/**
   * Executes a prepared raw query and returns the number of affected rows.
   * @example
   * ```
   * const result = await prisma.$executeRaw`UPDATE User SET cool = ${true} WHERE email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Executes a raw query and returns the number of affected rows.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$executeRawUnsafe('UPDATE User SET cool = $1 WHERE email = $2 ;', true, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $executeRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<number>;

  /**
   * Performs a prepared raw query and returns the `SELECT` data.
   * @example
   * ```
   * const result = await prisma.$queryRaw`SELECT * FROM User WHERE id = ${1} OR email = ${'user@email.com'};`
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRaw<T = unknown>(query: TemplateStringsArray | Prisma.Sql, ...values: any[]): Prisma.PrismaPromise<T>;

  /**
   * Performs a raw query and returns the `SELECT` data.
   * Susceptible to SQL injections, see documentation.
   * @example
   * ```
   * const result = await prisma.$queryRawUnsafe('SELECT * FROM User WHERE id = $1 OR email = $2;', 1, 'user@email.com')
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/raw-database-access).
   */
  $queryRawUnsafe<T = unknown>(query: string, ...values: any[]): Prisma.PrismaPromise<T>;


  /**
   * Allows the running of a sequence of read/write operations that are guaranteed to either succeed or fail as a whole.
   * @example
   * ```
   * const [george, bob, alice] = await prisma.$transaction([
   *   prisma.user.create({ data: { name: 'George' } }),
   *   prisma.user.create({ data: { name: 'Bob' } }),
   *   prisma.user.create({ data: { name: 'Alice' } }),
   * ])
   * ```
   * 
   * Read more in our [docs](https://www.prisma.io/docs/concepts/components/prisma-client/transactions).
   */
  $transaction<P extends Prisma.PrismaPromise<any>[]>(arg: [...P], options?: { isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<runtime.Types.Utils.UnwrapTuple<P>>

  $transaction<R>(fn: (prisma: Omit<PrismaClient, runtime.ITXClientDenyList>) => $Utils.JsPromise<R>, options?: { maxWait?: number, timeout?: number, isolationLevel?: Prisma.TransactionIsolationLevel }): $Utils.JsPromise<R>


  $extends: $Extensions.ExtendsHook<"extends", Prisma.TypeMapCb, ExtArgs>

      /**
   * `prisma.user`: Exposes CRUD operations for the **User** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Users
    * const users = await prisma.user.findMany()
    * ```
    */
  get user(): Prisma.UserDelegate<ExtArgs>;

  /**
   * `prisma.department`: Exposes CRUD operations for the **Department** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Departments
    * const departments = await prisma.department.findMany()
    * ```
    */
  get department(): Prisma.DepartmentDelegate<ExtArgs>;

  /**
   * `prisma.shift`: Exposes CRUD operations for the **Shift** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Shifts
    * const shifts = await prisma.shift.findMany()
    * ```
    */
  get shift(): Prisma.ShiftDelegate<ExtArgs>;

  /**
   * `prisma.employee`: Exposes CRUD operations for the **Employee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Employees
    * const employees = await prisma.employee.findMany()
    * ```
    */
  get employee(): Prisma.EmployeeDelegate<ExtArgs>;

  /**
   * `prisma.inactiveEmployee`: Exposes CRUD operations for the **InactiveEmployee** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more InactiveEmployees
    * const inactiveEmployees = await prisma.inactiveEmployee.findMany()
    * ```
    */
  get inactiveEmployee(): Prisma.InactiveEmployeeDelegate<ExtArgs>;

  /**
   * `prisma.auditLog`: Exposes CRUD operations for the **AuditLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AuditLogs
    * const auditLogs = await prisma.auditLog.findMany()
    * ```
    */
  get auditLog(): Prisma.AuditLogDelegate<ExtArgs>;

  /**
   * `prisma.attendanceLog`: Exposes CRUD operations for the **AttendanceLog** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more AttendanceLogs
    * const attendanceLogs = await prisma.attendanceLog.findMany()
    * ```
    */
  get attendanceLog(): Prisma.AttendanceLogDelegate<ExtArgs>;

  /**
   * `prisma.biometricData`: Exposes CRUD operations for the **BiometricData** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more BiometricData
    * const biometricData = await prisma.biometricData.findMany()
    * ```
    */
  get biometricData(): Prisma.BiometricDataDelegate<ExtArgs>;

  /**
   * `prisma.leaveBalance`: Exposes CRUD operations for the **LeaveBalance** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveBalances
    * const leaveBalances = await prisma.leaveBalance.findMany()
    * ```
    */
  get leaveBalance(): Prisma.LeaveBalanceDelegate<ExtArgs>;

  /**
   * `prisma.leaveRequest`: Exposes CRUD operations for the **LeaveRequest** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more LeaveRequests
    * const leaveRequests = await prisma.leaveRequest.findMany()
    * ```
    */
  get leaveRequest(): Prisma.LeaveRequestDelegate<ExtArgs>;

  /**
   * `prisma.notification`: Exposes CRUD operations for the **Notification** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Notifications
    * const notifications = await prisma.notification.findMany()
    * ```
    */
  get notification(): Prisma.NotificationDelegate<ExtArgs>;

  /**
   * `prisma.setting`: Exposes CRUD operations for the **Setting** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Settings
    * const settings = await prisma.setting.findMany()
    * ```
    */
  get setting(): Prisma.SettingDelegate<ExtArgs>;

  /**
   * `prisma.shiftAssignment`: Exposes CRUD operations for the **ShiftAssignment** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more ShiftAssignments
    * const shiftAssignments = await prisma.shiftAssignment.findMany()
    * ```
    */
  get shiftAssignment(): Prisma.ShiftAssignmentDelegate<ExtArgs>;

  /**
   * `prisma.terminal`: Exposes CRUD operations for the **Terminal** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Terminals
    * const terminals = await prisma.terminal.findMany()
    * ```
    */
  get terminal(): Prisma.TerminalDelegate<ExtArgs>;

  /**
   * `prisma.timeEntry`: Exposes CRUD operations for the **TimeEntry** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more TimeEntries
    * const timeEntries = await prisma.timeEntry.findMany()
    * ```
    */
  get timeEntry(): Prisma.TimeEntryDelegate<ExtArgs>;

  /**
   * `prisma.employeeRate`: Exposes CRUD operations for the **EmployeeRate** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more EmployeeRates
    * const employeeRates = await prisma.employeeRate.findMany()
    * ```
    */
  get employeeRate(): Prisma.EmployeeRateDelegate<ExtArgs>;

  /**
   * `prisma.payrollDeduction`: Exposes CRUD operations for the **PayrollDeduction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more PayrollDeductions
    * const payrollDeductions = await prisma.payrollDeduction.findMany()
    * ```
    */
  get payrollDeduction(): Prisma.PayrollDeductionDelegate<ExtArgs>;

  /**
   * `prisma.infraction`: Exposes CRUD operations for the **Infraction** model.
    * Example usage:
    * ```ts
    * // Fetch zero or more Infractions
    * const infractions = await prisma.infraction.findMany()
    * ```
    */
  get infraction(): Prisma.InfractionDelegate<ExtArgs>;
}

export namespace Prisma {
  export import DMMF = runtime.DMMF

  export type PrismaPromise<T> = $Public.PrismaPromise<T>

  /**
   * Validator
   */
  export import validator = runtime.Public.validator

  /**
   * Prisma Errors
   */
  export import PrismaClientKnownRequestError = runtime.PrismaClientKnownRequestError
  export import PrismaClientUnknownRequestError = runtime.PrismaClientUnknownRequestError
  export import PrismaClientRustPanicError = runtime.PrismaClientRustPanicError
  export import PrismaClientInitializationError = runtime.PrismaClientInitializationError
  export import PrismaClientValidationError = runtime.PrismaClientValidationError
  export import NotFoundError = runtime.NotFoundError

  /**
   * Re-export of sql-template-tag
   */
  export import sql = runtime.sqltag
  export import empty = runtime.empty
  export import join = runtime.join
  export import raw = runtime.raw
  export import Sql = runtime.Sql



  /**
   * Decimal.js
   */
  export import Decimal = runtime.Decimal

  export type DecimalJsLike = runtime.DecimalJsLike

  /**
   * Metrics 
   */
  export type Metrics = runtime.Metrics
  export type Metric<T> = runtime.Metric<T>
  export type MetricHistogram = runtime.MetricHistogram
  export type MetricHistogramBucket = runtime.MetricHistogramBucket

  /**
  * Extensions
  */
  export import Extension = $Extensions.UserArgs
  export import getExtensionContext = runtime.Extensions.getExtensionContext
  export import Args = $Public.Args
  export import Payload = $Public.Payload
  export import Result = $Public.Result
  export import Exact = $Public.Exact

  /**
   * Prisma Client JS version: 5.22.0
   * Query Engine version: 605197351a3c8bdd595af2d2a9bc3025bca48ea2
   */
  export type PrismaVersion = {
    client: string
  }

  export const prismaVersion: PrismaVersion 

  /**
   * Utility Types
   */


  export import JsonObject = runtime.JsonObject
  export import JsonArray = runtime.JsonArray
  export import JsonValue = runtime.JsonValue
  export import InputJsonObject = runtime.InputJsonObject
  export import InputJsonArray = runtime.InputJsonArray
  export import InputJsonValue = runtime.InputJsonValue

  /**
   * Types of the values used to represent different kinds of `null` values when working with JSON fields.
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  namespace NullTypes {
    /**
    * Type of `Prisma.DbNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.DbNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class DbNull {
      private DbNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.JsonNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.JsonNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class JsonNull {
      private JsonNull: never
      private constructor()
    }

    /**
    * Type of `Prisma.AnyNull`.
    * 
    * You cannot use other instances of this class. Please use the `Prisma.AnyNull` value.
    * 
    * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
    */
    class AnyNull {
      private AnyNull: never
      private constructor()
    }
  }

  /**
   * Helper for filtering JSON entries that have `null` on the database (empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const DbNull: NullTypes.DbNull

  /**
   * Helper for filtering JSON entries that have JSON `null` values (not empty on the db)
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const JsonNull: NullTypes.JsonNull

  /**
   * Helper for filtering JSON entries that are `Prisma.DbNull` or `Prisma.JsonNull`
   * 
   * @see https://www.prisma.io/docs/concepts/components/prisma-client/working-with-fields/working-with-json-fields#filtering-on-a-json-field
   */
  export const AnyNull: NullTypes.AnyNull

  type SelectAndInclude = {
    select: any
    include: any
  }

  type SelectAndOmit = {
    select: any
    omit: any
  }

  /**
   * Get the type of the value, that the Promise holds.
   */
  export type PromiseType<T extends PromiseLike<any>> = T extends PromiseLike<infer U> ? U : T;

  /**
   * Get the return type of a function which returns a Promise.
   */
  export type PromiseReturnType<T extends (...args: any) => $Utils.JsPromise<any>> = PromiseType<ReturnType<T>>

  /**
   * From T, pick a set of properties whose keys are in the union K
   */
  type Prisma__Pick<T, K extends keyof T> = {
      [P in K]: T[P];
  };


  export type Enumerable<T> = T | Array<T>;

  export type RequiredKeys<T> = {
    [K in keyof T]-?: {} extends Prisma__Pick<T, K> ? never : K
  }[keyof T]

  export type TruthyKeys<T> = keyof {
    [K in keyof T as T[K] extends false | undefined | null ? never : K]: K
  }

  export type TrueKeys<T> = TruthyKeys<Prisma__Pick<T, RequiredKeys<T>>>

  /**
   * Subset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection
   */
  export type Subset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never;
  };

  /**
   * SelectSubset
   * @desc From `T` pick properties that exist in `U`. Simple version of Intersection.
   * Additionally, it validates, if both select and include are present. If the case, it errors.
   */
  export type SelectSubset<T, U> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    (T extends SelectAndInclude
      ? 'Please either choose `select` or `include`.'
      : T extends SelectAndOmit
        ? 'Please either choose `select` or `omit`.'
        : {})

  /**
   * Subset + Intersection
   * @desc From `T` pick properties that exist in `U` and intersect `K`
   */
  export type SubsetIntersection<T, U, K> = {
    [key in keyof T]: key extends keyof U ? T[key] : never
  } &
    K

  type Without<T, U> = { [P in Exclude<keyof T, keyof U>]?: never };

  /**
   * XOR is needed to have a real mutually exclusive union type
   * https://stackoverflow.com/questions/42123407/does-typescript-support-mutually-exclusive-types
   */
  type XOR<T, U> =
    T extends object ?
    U extends object ?
      (Without<T, U> & U) | (Without<U, T> & T)
    : U : T


  /**
   * Is T a Record?
   */
  type IsObject<T extends any> = T extends Array<any>
  ? False
  : T extends Date
  ? False
  : T extends Uint8Array
  ? False
  : T extends BigInt
  ? False
  : T extends object
  ? True
  : False


  /**
   * If it's T[], return T
   */
  export type UnEnumerate<T extends unknown> = T extends Array<infer U> ? U : T

  /**
   * From ts-toolbelt
   */

  type __Either<O extends object, K extends Key> = Omit<O, K> &
    {
      // Merge all but K
      [P in K]: Prisma__Pick<O, P & keyof O> // With K possibilities
    }[K]

  type EitherStrict<O extends object, K extends Key> = Strict<__Either<O, K>>

  type EitherLoose<O extends object, K extends Key> = ComputeRaw<__Either<O, K>>

  type _Either<
    O extends object,
    K extends Key,
    strict extends Boolean
  > = {
    1: EitherStrict<O, K>
    0: EitherLoose<O, K>
  }[strict]

  type Either<
    O extends object,
    K extends Key,
    strict extends Boolean = 1
  > = O extends unknown ? _Either<O, K, strict> : never

  export type Union = any

  type PatchUndefined<O extends object, O1 extends object> = {
    [K in keyof O]: O[K] extends undefined ? At<O1, K> : O[K]
  } & {}

  /** Helper Types for "Merge" **/
  export type IntersectOf<U extends Union> = (
    U extends unknown ? (k: U) => void : never
  ) extends (k: infer I) => void
    ? I
    : never

  export type Overwrite<O extends object, O1 extends object> = {
      [K in keyof O]: K extends keyof O1 ? O1[K] : O[K];
  } & {};

  type _Merge<U extends object> = IntersectOf<Overwrite<U, {
      [K in keyof U]-?: At<U, K>;
  }>>;

  type Key = string | number | symbol;
  type AtBasic<O extends object, K extends Key> = K extends keyof O ? O[K] : never;
  type AtStrict<O extends object, K extends Key> = O[K & keyof O];
  type AtLoose<O extends object, K extends Key> = O extends unknown ? AtStrict<O, K> : never;
  export type At<O extends object, K extends Key, strict extends Boolean = 1> = {
      1: AtStrict<O, K>;
      0: AtLoose<O, K>;
  }[strict];

  export type ComputeRaw<A extends any> = A extends Function ? A : {
    [K in keyof A]: A[K];
  } & {};

  export type OptionalFlat<O> = {
    [K in keyof O]?: O[K];
  } & {};

  type _Record<K extends keyof any, T> = {
    [P in K]: T;
  };

  // cause typescript not to expand types and preserve names
  type NoExpand<T> = T extends unknown ? T : never;

  // this type assumes the passed object is entirely optional
  type AtLeast<O extends object, K extends string> = NoExpand<
    O extends unknown
    ? | (K extends keyof O ? { [P in K]: O[P] } & O : O)
      | {[P in keyof O as P extends K ? K : never]-?: O[P]} & O
    : never>;

  type _Strict<U, _U = U> = U extends unknown ? U & OptionalFlat<_Record<Exclude<Keys<_U>, keyof U>, never>> : never;

  export type Strict<U extends object> = ComputeRaw<_Strict<U>>;
  /** End Helper Types for "Merge" **/

  export type Merge<U extends object> = ComputeRaw<_Merge<Strict<U>>>;

  /**
  A [[Boolean]]
  */
  export type Boolean = True | False

  // /**
  // 1
  // */
  export type True = 1

  /**
  0
  */
  export type False = 0

  export type Not<B extends Boolean> = {
    0: 1
    1: 0
  }[B]

  export type Extends<A1 extends any, A2 extends any> = [A1] extends [never]
    ? 0 // anything `never` is false
    : A1 extends A2
    ? 1
    : 0

  export type Has<U extends Union, U1 extends Union> = Not<
    Extends<Exclude<U1, U>, U1>
  >

  export type Or<B1 extends Boolean, B2 extends Boolean> = {
    0: {
      0: 0
      1: 1
    }
    1: {
      0: 1
      1: 1
    }
  }[B1][B2]

  export type Keys<U extends Union> = U extends unknown ? keyof U : never

  type Cast<A, B> = A extends B ? A : B;

  export const type: unique symbol;



  /**
   * Used by group by
   */

  export type GetScalarType<T, O> = O extends object ? {
    [P in keyof T]: P extends keyof O
      ? O[P]
      : never
  } : never

  type FieldPaths<
    T,
    U = Omit<T, '_avg' | '_sum' | '_count' | '_min' | '_max'>
  > = IsObject<T> extends True ? U : T

  type GetHavingFields<T> = {
    [K in keyof T]: Or<
      Or<Extends<'OR', K>, Extends<'AND', K>>,
      Extends<'NOT', K>
    > extends True
      ? // infer is only needed to not hit TS limit
        // based on the brilliant idea of Pierre-Antoine Mills
        // https://github.com/microsoft/TypeScript/issues/30188#issuecomment-478938437
        T[K] extends infer TK
        ? GetHavingFields<UnEnumerate<TK> extends object ? Merge<UnEnumerate<TK>> : never>
        : never
      : {} extends FieldPaths<T[K]>
      ? never
      : K
  }[keyof T]

  /**
   * Convert tuple to union
   */
  type _TupleToUnion<T> = T extends (infer E)[] ? E : never
  type TupleToUnion<K extends readonly any[]> = _TupleToUnion<K>
  type MaybeTupleToUnion<T> = T extends any[] ? TupleToUnion<T> : T

  /**
   * Like `Pick`, but additionally can also accept an array of keys
   */
  type PickEnumerable<T, K extends Enumerable<keyof T> | keyof T> = Prisma__Pick<T, MaybeTupleToUnion<K>>

  /**
   * Exclude all keys with underscores
   */
  type ExcludeUnderscoreKeys<T extends string> = T extends `_${string}` ? never : T


  export type FieldRef<Model, FieldType> = runtime.FieldRef<Model, FieldType>

  type FieldRefInputType<Model, FieldType> = Model extends never ? never : FieldRef<Model, FieldType>


  export const ModelName: {
    User: 'User',
    Department: 'Department',
    Shift: 'Shift',
    Employee: 'Employee',
    InactiveEmployee: 'InactiveEmployee',
    AuditLog: 'AuditLog',
    AttendanceLog: 'AttendanceLog',
    BiometricData: 'BiometricData',
    LeaveBalance: 'LeaveBalance',
    LeaveRequest: 'LeaveRequest',
    Notification: 'Notification',
    Setting: 'Setting',
    ShiftAssignment: 'ShiftAssignment',
    Terminal: 'Terminal',
    TimeEntry: 'TimeEntry',
    EmployeeRate: 'EmployeeRate',
    PayrollDeduction: 'PayrollDeduction',
    Infraction: 'Infraction'
  };

  export type ModelName = (typeof ModelName)[keyof typeof ModelName]


  export type Datasources = {
    db?: Datasource
  }

  interface TypeMapCb extends $Utils.Fn<{extArgs: $Extensions.InternalArgs, clientOptions: PrismaClientOptions }, $Utils.Record<string, any>> {
    returns: Prisma.TypeMap<this['params']['extArgs'], this['params']['clientOptions']>
  }

  export type TypeMap<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs, ClientOptions = {}> = {
    meta: {
      modelProps: "user" | "department" | "shift" | "employee" | "inactiveEmployee" | "auditLog" | "attendanceLog" | "biometricData" | "leaveBalance" | "leaveRequest" | "notification" | "setting" | "shiftAssignment" | "terminal" | "timeEntry" | "employeeRate" | "payrollDeduction" | "infraction"
      txIsolationLevel: Prisma.TransactionIsolationLevel
    }
    model: {
      User: {
        payload: Prisma.$UserPayload<ExtArgs>
        fields: Prisma.UserFieldRefs
        operations: {
          findUnique: {
            args: Prisma.UserFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.UserFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findFirst: {
            args: Prisma.UserFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.UserFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          findMany: {
            args: Prisma.UserFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          create: {
            args: Prisma.UserCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          createMany: {
            args: Prisma.UserCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.UserCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>[]
          }
          delete: {
            args: Prisma.UserDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          update: {
            args: Prisma.UserUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          deleteMany: {
            args: Prisma.UserDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.UserUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.UserUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$UserPayload>
          }
          aggregate: {
            args: Prisma.UserAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateUser>
          }
          groupBy: {
            args: Prisma.UserGroupByArgs<ExtArgs>
            result: $Utils.Optional<UserGroupByOutputType>[]
          }
          count: {
            args: Prisma.UserCountArgs<ExtArgs>
            result: $Utils.Optional<UserCountAggregateOutputType> | number
          }
        }
      }
      Department: {
        payload: Prisma.$DepartmentPayload<ExtArgs>
        fields: Prisma.DepartmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.DepartmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.DepartmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findFirst: {
            args: Prisma.DepartmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.DepartmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          findMany: {
            args: Prisma.DepartmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          create: {
            args: Prisma.DepartmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          createMany: {
            args: Prisma.DepartmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.DepartmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>[]
          }
          delete: {
            args: Prisma.DepartmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          update: {
            args: Prisma.DepartmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          deleteMany: {
            args: Prisma.DepartmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.DepartmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.DepartmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$DepartmentPayload>
          }
          aggregate: {
            args: Prisma.DepartmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateDepartment>
          }
          groupBy: {
            args: Prisma.DepartmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<DepartmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.DepartmentCountArgs<ExtArgs>
            result: $Utils.Optional<DepartmentCountAggregateOutputType> | number
          }
        }
      }
      Shift: {
        payload: Prisma.$ShiftPayload<ExtArgs>
        fields: Prisma.ShiftFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findFirst: {
            args: Prisma.ShiftFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          findMany: {
            args: Prisma.ShiftFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          create: {
            args: Prisma.ShiftCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          createMany: {
            args: Prisma.ShiftCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>[]
          }
          delete: {
            args: Prisma.ShiftDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          update: {
            args: Prisma.ShiftUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          deleteMany: {
            args: Prisma.ShiftDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftPayload>
          }
          aggregate: {
            args: Prisma.ShiftAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShift>
          }
          groupBy: {
            args: Prisma.ShiftGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftCountAggregateOutputType> | number
          }
        }
      }
      Employee: {
        payload: Prisma.$EmployeePayload<ExtArgs>
        fields: Prisma.EmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findFirst: {
            args: Prisma.EmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          findMany: {
            args: Prisma.EmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          create: {
            args: Prisma.EmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          createMany: {
            args: Prisma.EmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>[]
          }
          delete: {
            args: Prisma.EmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          update: {
            args: Prisma.EmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeePayload>
          }
          aggregate: {
            args: Prisma.EmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployee>
          }
          groupBy: {
            args: Prisma.EmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeCountAggregateOutputType> | number
          }
        }
      }
      InactiveEmployee: {
        payload: Prisma.$InactiveEmployeePayload<ExtArgs>
        fields: Prisma.InactiveEmployeeFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InactiveEmployeeFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InactiveEmployeeFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          findFirst: {
            args: Prisma.InactiveEmployeeFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InactiveEmployeeFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          findMany: {
            args: Prisma.InactiveEmployeeFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>[]
          }
          create: {
            args: Prisma.InactiveEmployeeCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          createMany: {
            args: Prisma.InactiveEmployeeCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InactiveEmployeeCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>[]
          }
          delete: {
            args: Prisma.InactiveEmployeeDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          update: {
            args: Prisma.InactiveEmployeeUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          deleteMany: {
            args: Prisma.InactiveEmployeeDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InactiveEmployeeUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InactiveEmployeeUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InactiveEmployeePayload>
          }
          aggregate: {
            args: Prisma.InactiveEmployeeAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInactiveEmployee>
          }
          groupBy: {
            args: Prisma.InactiveEmployeeGroupByArgs<ExtArgs>
            result: $Utils.Optional<InactiveEmployeeGroupByOutputType>[]
          }
          count: {
            args: Prisma.InactiveEmployeeCountArgs<ExtArgs>
            result: $Utils.Optional<InactiveEmployeeCountAggregateOutputType> | number
          }
        }
      }
      AuditLog: {
        payload: Prisma.$AuditLogPayload<ExtArgs>
        fields: Prisma.AuditLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AuditLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AuditLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findFirst: {
            args: Prisma.AuditLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AuditLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          findMany: {
            args: Prisma.AuditLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          create: {
            args: Prisma.AuditLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          createMany: {
            args: Prisma.AuditLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AuditLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>[]
          }
          delete: {
            args: Prisma.AuditLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          update: {
            args: Prisma.AuditLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          deleteMany: {
            args: Prisma.AuditLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AuditLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AuditLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AuditLogPayload>
          }
          aggregate: {
            args: Prisma.AuditLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAuditLog>
          }
          groupBy: {
            args: Prisma.AuditLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AuditLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AuditLogCountArgs<ExtArgs>
            result: $Utils.Optional<AuditLogCountAggregateOutputType> | number
          }
        }
      }
      AttendanceLog: {
        payload: Prisma.$AttendanceLogPayload<ExtArgs>
        fields: Prisma.AttendanceLogFieldRefs
        operations: {
          findUnique: {
            args: Prisma.AttendanceLogFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.AttendanceLogFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findFirst: {
            args: Prisma.AttendanceLogFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.AttendanceLogFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          findMany: {
            args: Prisma.AttendanceLogFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          create: {
            args: Prisma.AttendanceLogCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          createMany: {
            args: Prisma.AttendanceLogCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.AttendanceLogCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>[]
          }
          delete: {
            args: Prisma.AttendanceLogDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          update: {
            args: Prisma.AttendanceLogUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          deleteMany: {
            args: Prisma.AttendanceLogDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.AttendanceLogUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.AttendanceLogUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$AttendanceLogPayload>
          }
          aggregate: {
            args: Prisma.AttendanceLogAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateAttendanceLog>
          }
          groupBy: {
            args: Prisma.AttendanceLogGroupByArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogGroupByOutputType>[]
          }
          count: {
            args: Prisma.AttendanceLogCountArgs<ExtArgs>
            result: $Utils.Optional<AttendanceLogCountAggregateOutputType> | number
          }
        }
      }
      BiometricData: {
        payload: Prisma.$BiometricDataPayload<ExtArgs>
        fields: Prisma.BiometricDataFieldRefs
        operations: {
          findUnique: {
            args: Prisma.BiometricDataFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.BiometricDataFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findFirst: {
            args: Prisma.BiometricDataFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.BiometricDataFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          findMany: {
            args: Prisma.BiometricDataFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          create: {
            args: Prisma.BiometricDataCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          createMany: {
            args: Prisma.BiometricDataCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.BiometricDataCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>[]
          }
          delete: {
            args: Prisma.BiometricDataDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          update: {
            args: Prisma.BiometricDataUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          deleteMany: {
            args: Prisma.BiometricDataDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.BiometricDataUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.BiometricDataUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$BiometricDataPayload>
          }
          aggregate: {
            args: Prisma.BiometricDataAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateBiometricData>
          }
          groupBy: {
            args: Prisma.BiometricDataGroupByArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataGroupByOutputType>[]
          }
          count: {
            args: Prisma.BiometricDataCountArgs<ExtArgs>
            result: $Utils.Optional<BiometricDataCountAggregateOutputType> | number
          }
        }
      }
      LeaveBalance: {
        payload: Prisma.$LeaveBalancePayload<ExtArgs>
        fields: Prisma.LeaveBalanceFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveBalanceFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findFirst: {
            args: Prisma.LeaveBalanceFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveBalanceFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          findMany: {
            args: Prisma.LeaveBalanceFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          create: {
            args: Prisma.LeaveBalanceCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          createMany: {
            args: Prisma.LeaveBalanceCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveBalanceCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>[]
          }
          delete: {
            args: Prisma.LeaveBalanceDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          update: {
            args: Prisma.LeaveBalanceUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          deleteMany: {
            args: Prisma.LeaveBalanceDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveBalanceUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveBalanceUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveBalancePayload>
          }
          aggregate: {
            args: Prisma.LeaveBalanceAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveBalance>
          }
          groupBy: {
            args: Prisma.LeaveBalanceGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveBalanceCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveBalanceCountAggregateOutputType> | number
          }
        }
      }
      LeaveRequest: {
        payload: Prisma.$LeaveRequestPayload<ExtArgs>
        fields: Prisma.LeaveRequestFieldRefs
        operations: {
          findUnique: {
            args: Prisma.LeaveRequestFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.LeaveRequestFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findFirst: {
            args: Prisma.LeaveRequestFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.LeaveRequestFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          findMany: {
            args: Prisma.LeaveRequestFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          create: {
            args: Prisma.LeaveRequestCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          createMany: {
            args: Prisma.LeaveRequestCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.LeaveRequestCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>[]
          }
          delete: {
            args: Prisma.LeaveRequestDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          update: {
            args: Prisma.LeaveRequestUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          deleteMany: {
            args: Prisma.LeaveRequestDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.LeaveRequestUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.LeaveRequestUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$LeaveRequestPayload>
          }
          aggregate: {
            args: Prisma.LeaveRequestAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateLeaveRequest>
          }
          groupBy: {
            args: Prisma.LeaveRequestGroupByArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestGroupByOutputType>[]
          }
          count: {
            args: Prisma.LeaveRequestCountArgs<ExtArgs>
            result: $Utils.Optional<LeaveRequestCountAggregateOutputType> | number
          }
        }
      }
      Notification: {
        payload: Prisma.$NotificationPayload<ExtArgs>
        fields: Prisma.NotificationFieldRefs
        operations: {
          findUnique: {
            args: Prisma.NotificationFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.NotificationFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findFirst: {
            args: Prisma.NotificationFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.NotificationFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          findMany: {
            args: Prisma.NotificationFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          create: {
            args: Prisma.NotificationCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          createMany: {
            args: Prisma.NotificationCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.NotificationCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>[]
          }
          delete: {
            args: Prisma.NotificationDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          update: {
            args: Prisma.NotificationUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          deleteMany: {
            args: Prisma.NotificationDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.NotificationUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.NotificationUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$NotificationPayload>
          }
          aggregate: {
            args: Prisma.NotificationAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateNotification>
          }
          groupBy: {
            args: Prisma.NotificationGroupByArgs<ExtArgs>
            result: $Utils.Optional<NotificationGroupByOutputType>[]
          }
          count: {
            args: Prisma.NotificationCountArgs<ExtArgs>
            result: $Utils.Optional<NotificationCountAggregateOutputType> | number
          }
        }
      }
      Setting: {
        payload: Prisma.$SettingPayload<ExtArgs>
        fields: Prisma.SettingFieldRefs
        operations: {
          findUnique: {
            args: Prisma.SettingFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.SettingFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findFirst: {
            args: Prisma.SettingFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.SettingFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          findMany: {
            args: Prisma.SettingFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          create: {
            args: Prisma.SettingCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          createMany: {
            args: Prisma.SettingCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.SettingCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>[]
          }
          delete: {
            args: Prisma.SettingDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          update: {
            args: Prisma.SettingUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          deleteMany: {
            args: Prisma.SettingDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.SettingUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.SettingUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$SettingPayload>
          }
          aggregate: {
            args: Prisma.SettingAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateSetting>
          }
          groupBy: {
            args: Prisma.SettingGroupByArgs<ExtArgs>
            result: $Utils.Optional<SettingGroupByOutputType>[]
          }
          count: {
            args: Prisma.SettingCountArgs<ExtArgs>
            result: $Utils.Optional<SettingCountAggregateOutputType> | number
          }
        }
      }
      ShiftAssignment: {
        payload: Prisma.$ShiftAssignmentPayload<ExtArgs>
        fields: Prisma.ShiftAssignmentFieldRefs
        operations: {
          findUnique: {
            args: Prisma.ShiftAssignmentFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          findFirst: {
            args: Prisma.ShiftAssignmentFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.ShiftAssignmentFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          findMany: {
            args: Prisma.ShiftAssignmentFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>[]
          }
          create: {
            args: Prisma.ShiftAssignmentCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          createMany: {
            args: Prisma.ShiftAssignmentCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.ShiftAssignmentCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>[]
          }
          delete: {
            args: Prisma.ShiftAssignmentDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          update: {
            args: Prisma.ShiftAssignmentUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          deleteMany: {
            args: Prisma.ShiftAssignmentDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.ShiftAssignmentUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.ShiftAssignmentUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$ShiftAssignmentPayload>
          }
          aggregate: {
            args: Prisma.ShiftAssignmentAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateShiftAssignment>
          }
          groupBy: {
            args: Prisma.ShiftAssignmentGroupByArgs<ExtArgs>
            result: $Utils.Optional<ShiftAssignmentGroupByOutputType>[]
          }
          count: {
            args: Prisma.ShiftAssignmentCountArgs<ExtArgs>
            result: $Utils.Optional<ShiftAssignmentCountAggregateOutputType> | number
          }
        }
      }
      Terminal: {
        payload: Prisma.$TerminalPayload<ExtArgs>
        fields: Prisma.TerminalFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TerminalFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TerminalFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          findFirst: {
            args: Prisma.TerminalFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TerminalFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          findMany: {
            args: Prisma.TerminalFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>[]
          }
          create: {
            args: Prisma.TerminalCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          createMany: {
            args: Prisma.TerminalCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TerminalCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>[]
          }
          delete: {
            args: Prisma.TerminalDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          update: {
            args: Prisma.TerminalUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          deleteMany: {
            args: Prisma.TerminalDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TerminalUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TerminalUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TerminalPayload>
          }
          aggregate: {
            args: Prisma.TerminalAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTerminal>
          }
          groupBy: {
            args: Prisma.TerminalGroupByArgs<ExtArgs>
            result: $Utils.Optional<TerminalGroupByOutputType>[]
          }
          count: {
            args: Prisma.TerminalCountArgs<ExtArgs>
            result: $Utils.Optional<TerminalCountAggregateOutputType> | number
          }
        }
      }
      TimeEntry: {
        payload: Prisma.$TimeEntryPayload<ExtArgs>
        fields: Prisma.TimeEntryFieldRefs
        operations: {
          findUnique: {
            args: Prisma.TimeEntryFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.TimeEntryFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findFirst: {
            args: Prisma.TimeEntryFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.TimeEntryFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          findMany: {
            args: Prisma.TimeEntryFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          create: {
            args: Prisma.TimeEntryCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          createMany: {
            args: Prisma.TimeEntryCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.TimeEntryCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>[]
          }
          delete: {
            args: Prisma.TimeEntryDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          update: {
            args: Prisma.TimeEntryUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          deleteMany: {
            args: Prisma.TimeEntryDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.TimeEntryUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.TimeEntryUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$TimeEntryPayload>
          }
          aggregate: {
            args: Prisma.TimeEntryAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateTimeEntry>
          }
          groupBy: {
            args: Prisma.TimeEntryGroupByArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryGroupByOutputType>[]
          }
          count: {
            args: Prisma.TimeEntryCountArgs<ExtArgs>
            result: $Utils.Optional<TimeEntryCountAggregateOutputType> | number
          }
        }
      }
      EmployeeRate: {
        payload: Prisma.$EmployeeRatePayload<ExtArgs>
        fields: Prisma.EmployeeRateFieldRefs
        operations: {
          findUnique: {
            args: Prisma.EmployeeRateFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.EmployeeRateFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          findFirst: {
            args: Prisma.EmployeeRateFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.EmployeeRateFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          findMany: {
            args: Prisma.EmployeeRateFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>[]
          }
          create: {
            args: Prisma.EmployeeRateCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          createMany: {
            args: Prisma.EmployeeRateCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.EmployeeRateCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>[]
          }
          delete: {
            args: Prisma.EmployeeRateDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          update: {
            args: Prisma.EmployeeRateUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          deleteMany: {
            args: Prisma.EmployeeRateDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.EmployeeRateUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.EmployeeRateUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$EmployeeRatePayload>
          }
          aggregate: {
            args: Prisma.EmployeeRateAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateEmployeeRate>
          }
          groupBy: {
            args: Prisma.EmployeeRateGroupByArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRateGroupByOutputType>[]
          }
          count: {
            args: Prisma.EmployeeRateCountArgs<ExtArgs>
            result: $Utils.Optional<EmployeeRateCountAggregateOutputType> | number
          }
        }
      }
      PayrollDeduction: {
        payload: Prisma.$PayrollDeductionPayload<ExtArgs>
        fields: Prisma.PayrollDeductionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.PayrollDeductionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.PayrollDeductionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          findFirst: {
            args: Prisma.PayrollDeductionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.PayrollDeductionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          findMany: {
            args: Prisma.PayrollDeductionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>[]
          }
          create: {
            args: Prisma.PayrollDeductionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          createMany: {
            args: Prisma.PayrollDeductionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.PayrollDeductionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>[]
          }
          delete: {
            args: Prisma.PayrollDeductionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          update: {
            args: Prisma.PayrollDeductionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          deleteMany: {
            args: Prisma.PayrollDeductionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.PayrollDeductionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.PayrollDeductionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$PayrollDeductionPayload>
          }
          aggregate: {
            args: Prisma.PayrollDeductionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregatePayrollDeduction>
          }
          groupBy: {
            args: Prisma.PayrollDeductionGroupByArgs<ExtArgs>
            result: $Utils.Optional<PayrollDeductionGroupByOutputType>[]
          }
          count: {
            args: Prisma.PayrollDeductionCountArgs<ExtArgs>
            result: $Utils.Optional<PayrollDeductionCountAggregateOutputType> | number
          }
        }
      }
      Infraction: {
        payload: Prisma.$InfractionPayload<ExtArgs>
        fields: Prisma.InfractionFieldRefs
        operations: {
          findUnique: {
            args: Prisma.InfractionFindUniqueArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload> | null
          }
          findUniqueOrThrow: {
            args: Prisma.InfractionFindUniqueOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          findFirst: {
            args: Prisma.InfractionFindFirstArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload> | null
          }
          findFirstOrThrow: {
            args: Prisma.InfractionFindFirstOrThrowArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          findMany: {
            args: Prisma.InfractionFindManyArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>[]
          }
          create: {
            args: Prisma.InfractionCreateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          createMany: {
            args: Prisma.InfractionCreateManyArgs<ExtArgs>
            result: BatchPayload
          }
          createManyAndReturn: {
            args: Prisma.InfractionCreateManyAndReturnArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>[]
          }
          delete: {
            args: Prisma.InfractionDeleteArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          update: {
            args: Prisma.InfractionUpdateArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          deleteMany: {
            args: Prisma.InfractionDeleteManyArgs<ExtArgs>
            result: BatchPayload
          }
          updateMany: {
            args: Prisma.InfractionUpdateManyArgs<ExtArgs>
            result: BatchPayload
          }
          upsert: {
            args: Prisma.InfractionUpsertArgs<ExtArgs>
            result: $Utils.PayloadToResult<Prisma.$InfractionPayload>
          }
          aggregate: {
            args: Prisma.InfractionAggregateArgs<ExtArgs>
            result: $Utils.Optional<AggregateInfraction>
          }
          groupBy: {
            args: Prisma.InfractionGroupByArgs<ExtArgs>
            result: $Utils.Optional<InfractionGroupByOutputType>[]
          }
          count: {
            args: Prisma.InfractionCountArgs<ExtArgs>
            result: $Utils.Optional<InfractionCountAggregateOutputType> | number
          }
        }
      }
    }
  } & {
    other: {
      payload: any
      operations: {
        $executeRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $executeRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
        $queryRaw: {
          args: [query: TemplateStringsArray | Prisma.Sql, ...values: any[]],
          result: any
        }
        $queryRawUnsafe: {
          args: [query: string, ...values: any[]],
          result: any
        }
      }
    }
  }
  export const defineExtension: $Extensions.ExtendsHook<"define", Prisma.TypeMapCb, $Extensions.DefaultArgs>
  export type DefaultPrismaClient = PrismaClient
  export type ErrorFormat = 'pretty' | 'colorless' | 'minimal'
  export interface PrismaClientOptions {
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasources?: Datasources
    /**
     * Overwrites the datasource url from your schema.prisma file
     */
    datasourceUrl?: string
    /**
     * @default "colorless"
     */
    errorFormat?: ErrorFormat
    /**
     * @example
     * ```
     * // Defaults to stdout
     * log: ['query', 'info', 'warn', 'error']
     * 
     * // Emit as events
     * log: [
     *   { emit: 'stdout', level: 'query' },
     *   { emit: 'stdout', level: 'info' },
     *   { emit: 'stdout', level: 'warn' }
     *   { emit: 'stdout', level: 'error' }
     * ]
     * ```
     * Read more in our [docs](https://www.prisma.io/docs/reference/tools-and-interfaces/prisma-client/logging#the-log-option).
     */
    log?: (LogLevel | LogDefinition)[]
    /**
     * The default values for transactionOptions
     * maxWait ?= 2000
     * timeout ?= 5000
     */
    transactionOptions?: {
      maxWait?: number
      timeout?: number
      isolationLevel?: Prisma.TransactionIsolationLevel
    }
  }


  /* Types for Logging */
  export type LogLevel = 'info' | 'query' | 'warn' | 'error'
  export type LogDefinition = {
    level: LogLevel
    emit: 'stdout' | 'event'
  }

  export type GetLogType<T extends LogLevel | LogDefinition> = T extends LogDefinition ? T['emit'] extends 'event' ? T['level'] : never : never
  export type GetEvents<T extends any> = T extends Array<LogLevel | LogDefinition> ?
    GetLogType<T[0]> | GetLogType<T[1]> | GetLogType<T[2]> | GetLogType<T[3]>
    : never

  export type QueryEvent = {
    timestamp: Date
    query: string
    params: string
    duration: number
    target: string
  }

  export type LogEvent = {
    timestamp: Date
    message: string
    target: string
  }
  /* End Types for Logging */


  export type PrismaAction =
    | 'findUnique'
    | 'findUniqueOrThrow'
    | 'findMany'
    | 'findFirst'
    | 'findFirstOrThrow'
    | 'create'
    | 'createMany'
    | 'createManyAndReturn'
    | 'update'
    | 'updateMany'
    | 'upsert'
    | 'delete'
    | 'deleteMany'
    | 'executeRaw'
    | 'queryRaw'
    | 'aggregate'
    | 'count'
    | 'runCommandRaw'
    | 'findRaw'
    | 'groupBy'

  /**
   * These options are being passed into the middleware as "params"
   */
  export type MiddlewareParams = {
    model?: ModelName
    action: PrismaAction
    args: any
    dataPath: string[]
    runInTransaction: boolean
  }

  /**
   * The `T` type makes sure, that the `return proceed` is not forgotten in the middleware implementation
   */
  export type Middleware<T = any> = (
    params: MiddlewareParams,
    next: (params: MiddlewareParams) => $Utils.JsPromise<T>,
  ) => $Utils.JsPromise<T>

  // tested in getLogLevel.test.ts
  export function getLogLevel(log: Array<LogLevel | LogDefinition>): LogLevel | undefined;

  /**
   * `PrismaClient` proxy available in interactive transactions.
   */
  export type TransactionClient = Omit<Prisma.DefaultPrismaClient, runtime.ITXClientDenyList>

  export type Datasource = {
    url?: string
  }

  /**
   * Count Types
   */


  /**
   * Count Type UserCountOutputType
   */

  export type UserCountOutputType = {
    AuditLog: number
    LeaveRequest: number
    TimeEntry: number
    DepartmentsCreated: number
    ShiftsCreated: number
    ShiftAssignmentsCreated: number
    DeductionApprovals: number
    InfractionReports: number
    InfractionApprovals: number
  }

  export type UserCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | UserCountOutputTypeCountAuditLogArgs
    LeaveRequest?: boolean | UserCountOutputTypeCountLeaveRequestArgs
    TimeEntry?: boolean | UserCountOutputTypeCountTimeEntryArgs
    DepartmentsCreated?: boolean | UserCountOutputTypeCountDepartmentsCreatedArgs
    ShiftsCreated?: boolean | UserCountOutputTypeCountShiftsCreatedArgs
    ShiftAssignmentsCreated?: boolean | UserCountOutputTypeCountShiftAssignmentsCreatedArgs
    DeductionApprovals?: boolean | UserCountOutputTypeCountDeductionApprovalsArgs
    InfractionReports?: boolean | UserCountOutputTypeCountInfractionReportsArgs
    InfractionApprovals?: boolean | UserCountOutputTypeCountInfractionApprovalsArgs
  }

  // Custom InputTypes
  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the UserCountOutputType
     */
    select?: UserCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountAuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountLeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountTimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDepartmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountShiftAssignmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountDeductionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollDeductionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInfractionReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
  }

  /**
   * UserCountOutputType without action
   */
  export type UserCountOutputTypeCountInfractionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
  }


  /**
   * Count Type DepartmentCountOutputType
   */

  export type DepartmentCountOutputType = {
    employees: number
  }

  export type DepartmentCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | DepartmentCountOutputTypeCountEmployeesArgs
  }

  // Custom InputTypes
  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the DepartmentCountOutputType
     */
    select?: DepartmentCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * DepartmentCountOutputType without action
   */
  export type DepartmentCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }


  /**
   * Count Type ShiftCountOutputType
   */

  export type ShiftCountOutputType = {
    employees: number
    ShiftAssignment: number
  }

  export type ShiftCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    employees?: boolean | ShiftCountOutputTypeCountEmployeesArgs
    ShiftAssignment?: boolean | ShiftCountOutputTypeCountShiftAssignmentArgs
  }

  // Custom InputTypes
  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftCountOutputType
     */
    select?: ShiftCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountEmployeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * ShiftCountOutputType without action
   */
  export type ShiftCountOutputTypeCountShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }


  /**
   * Count Type EmployeeCountOutputType
   */

  export type EmployeeCountOutputType = {
    AttendanceLog: number
    BiometricData: number
    other_Employee: number
    LeaveBalance: number
    LeaveRequest: number
    Notification: number
    ShiftAssignment: number
    TimeEntry: number
    EmployeeDeductions: number
    EmployeeInfractions: number
  }

  export type EmployeeCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttendanceLog?: boolean | EmployeeCountOutputTypeCountAttendanceLogArgs
    BiometricData?: boolean | EmployeeCountOutputTypeCountBiometricDataArgs
    other_Employee?: boolean | EmployeeCountOutputTypeCountOther_EmployeeArgs
    LeaveBalance?: boolean | EmployeeCountOutputTypeCountLeaveBalanceArgs
    LeaveRequest?: boolean | EmployeeCountOutputTypeCountLeaveRequestArgs
    Notification?: boolean | EmployeeCountOutputTypeCountNotificationArgs
    ShiftAssignment?: boolean | EmployeeCountOutputTypeCountShiftAssignmentArgs
    TimeEntry?: boolean | EmployeeCountOutputTypeCountTimeEntryArgs
    EmployeeDeductions?: boolean | EmployeeCountOutputTypeCountEmployeeDeductionsArgs
    EmployeeInfractions?: boolean | EmployeeCountOutputTypeCountEmployeeInfractionsArgs
  }

  // Custom InputTypes
  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeCountOutputType
     */
    select?: EmployeeCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountAttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountBiometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiometricDataWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountOther_EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountLeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountNotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountTimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeDeductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollDeductionWhereInput
  }

  /**
   * EmployeeCountOutputType without action
   */
  export type EmployeeCountOutputTypeCountEmployeeInfractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
  }


  /**
   * Count Type TerminalCountOutputType
   */

  export type TerminalCountOutputType = {
    AttendanceLog: number
    TimeEntry: number
  }

  export type TerminalCountOutputTypeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttendanceLog?: boolean | TerminalCountOutputTypeCountAttendanceLogArgs
    TimeEntry?: boolean | TerminalCountOutputTypeCountTimeEntryArgs
  }

  // Custom InputTypes
  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TerminalCountOutputType
     */
    select?: TerminalCountOutputTypeSelect<ExtArgs> | null
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountAttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
  }

  /**
   * TerminalCountOutputType without action
   */
  export type TerminalCountOutputTypeCountTimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
  }


  /**
   * Models
   */

  /**
   * Model User
   */

  export type AggregateUser = {
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  export type UserMinAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    permissions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserMaxAggregateOutputType = {
    id: string | null
    email: string | null
    password: string | null
    firstName: string | null
    lastName: string | null
    role: string | null
    permissions: string | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type UserCountAggregateOutputType = {
    id: number
    email: number
    password: number
    firstName: number
    lastName: number
    role: number
    permissions: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type UserMinAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserMaxAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type UserCountAggregateInputType = {
    id?: true
    email?: true
    password?: true
    firstName?: true
    lastName?: true
    role?: true
    permissions?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type UserAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which User to aggregate.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Users
    **/
    _count?: true | UserCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: UserMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: UserMaxAggregateInputType
  }

  export type GetUserAggregateType<T extends UserAggregateArgs> = {
        [P in keyof T & keyof AggregateUser]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateUser[P]>
      : GetScalarType<T[P], AggregateUser[P]>
  }




  export type UserGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: UserWhereInput
    orderBy?: UserOrderByWithAggregationInput | UserOrderByWithAggregationInput[]
    by: UserScalarFieldEnum[] | UserScalarFieldEnum
    having?: UserScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: UserCountAggregateInputType | true
    _min?: UserMinAggregateInputType
    _max?: UserMaxAggregateInputType
  }

  export type UserGroupByOutputType = {
    id: string
    email: string
    password: string
    firstName: string
    lastName: string
    role: string
    permissions: string
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: UserCountAggregateOutputType | null
    _min: UserMinAggregateOutputType | null
    _max: UserMaxAggregateOutputType | null
  }

  type GetUserGroupByPayload<T extends UserGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<UserGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof UserGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], UserGroupByOutputType[P]>
            : GetScalarType<T[P], UserGroupByOutputType[P]>
        }
      >
    >


  export type UserSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Employee?: boolean | User$EmployeeArgs<ExtArgs>
    LeaveRequest?: boolean | User$LeaveRequestArgs<ExtArgs>
    TimeEntry?: boolean | User$TimeEntryArgs<ExtArgs>
    DepartmentsCreated?: boolean | User$DepartmentsCreatedArgs<ExtArgs>
    ShiftsCreated?: boolean | User$ShiftsCreatedArgs<ExtArgs>
    ShiftAssignmentsCreated?: boolean | User$ShiftAssignmentsCreatedArgs<ExtArgs>
    DeductionApprovals?: boolean | User$DeductionApprovalsArgs<ExtArgs>
    InfractionReports?: boolean | User$InfractionReportsArgs<ExtArgs>
    InfractionApprovals?: boolean | User$InfractionApprovalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["user"]>

  export type UserSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["user"]>

  export type UserSelectScalar = {
    id?: boolean
    email?: boolean
    password?: boolean
    firstName?: boolean
    lastName?: boolean
    role?: boolean
    permissions?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type UserInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AuditLog?: boolean | User$AuditLogArgs<ExtArgs>
    Employee?: boolean | User$EmployeeArgs<ExtArgs>
    LeaveRequest?: boolean | User$LeaveRequestArgs<ExtArgs>
    TimeEntry?: boolean | User$TimeEntryArgs<ExtArgs>
    DepartmentsCreated?: boolean | User$DepartmentsCreatedArgs<ExtArgs>
    ShiftsCreated?: boolean | User$ShiftsCreatedArgs<ExtArgs>
    ShiftAssignmentsCreated?: boolean | User$ShiftAssignmentsCreatedArgs<ExtArgs>
    DeductionApprovals?: boolean | User$DeductionApprovalsArgs<ExtArgs>
    InfractionReports?: boolean | User$InfractionReportsArgs<ExtArgs>
    InfractionApprovals?: boolean | User$InfractionApprovalsArgs<ExtArgs>
    _count?: boolean | UserCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type UserIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $UserPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "User"
    objects: {
      AuditLog: Prisma.$AuditLogPayload<ExtArgs>[]
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
      LeaveRequest: Prisma.$LeaveRequestPayload<ExtArgs>[]
      TimeEntry: Prisma.$TimeEntryPayload<ExtArgs>[]
      DepartmentsCreated: Prisma.$DepartmentPayload<ExtArgs>[]
      ShiftsCreated: Prisma.$ShiftPayload<ExtArgs>[]
      ShiftAssignmentsCreated: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
      DeductionApprovals: Prisma.$PayrollDeductionPayload<ExtArgs>[]
      InfractionReports: Prisma.$InfractionPayload<ExtArgs>[]
      InfractionApprovals: Prisma.$InfractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      email: string
      password: string
      firstName: string
      lastName: string
      role: string
      permissions: string
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["user"]>
    composites: {}
  }

  type UserGetPayload<S extends boolean | null | undefined | UserDefaultArgs> = $Result.GetResult<Prisma.$UserPayload, S>

  type UserCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<UserFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: UserCountAggregateInputType | true
    }

  export interface UserDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['User'], meta: { name: 'User' } }
    /**
     * Find zero or one User that matches the filter.
     * @param {UserFindUniqueArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends UserFindUniqueArgs>(args: SelectSubset<T, UserFindUniqueArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one User that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {UserFindUniqueOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends UserFindUniqueOrThrowArgs>(args: SelectSubset<T, UserFindUniqueOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first User that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends UserFindFirstArgs>(args?: SelectSubset<T, UserFindFirstArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first User that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindFirstOrThrowArgs} args - Arguments to find a User
     * @example
     * // Get one User
     * const user = await prisma.user.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends UserFindFirstOrThrowArgs>(args?: SelectSubset<T, UserFindFirstOrThrowArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Users that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Users
     * const users = await prisma.user.findMany()
     * 
     * // Get first 10 Users
     * const users = await prisma.user.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const userWithIdOnly = await prisma.user.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends UserFindManyArgs>(args?: SelectSubset<T, UserFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a User.
     * @param {UserCreateArgs} args - Arguments to create a User.
     * @example
     * // Create one User
     * const User = await prisma.user.create({
     *   data: {
     *     // ... data to create a User
     *   }
     * })
     * 
     */
    create<T extends UserCreateArgs>(args: SelectSubset<T, UserCreateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Users.
     * @param {UserCreateManyArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends UserCreateManyArgs>(args?: SelectSubset<T, UserCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Users and returns the data saved in the database.
     * @param {UserCreateManyAndReturnArgs} args - Arguments to create many Users.
     * @example
     * // Create many Users
     * const user = await prisma.user.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Users and only return the `id`
     * const userWithIdOnly = await prisma.user.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends UserCreateManyAndReturnArgs>(args?: SelectSubset<T, UserCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a User.
     * @param {UserDeleteArgs} args - Arguments to delete one User.
     * @example
     * // Delete one User
     * const User = await prisma.user.delete({
     *   where: {
     *     // ... filter to delete one User
     *   }
     * })
     * 
     */
    delete<T extends UserDeleteArgs>(args: SelectSubset<T, UserDeleteArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one User.
     * @param {UserUpdateArgs} args - Arguments to update one User.
     * @example
     * // Update one User
     * const user = await prisma.user.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends UserUpdateArgs>(args: SelectSubset<T, UserUpdateArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Users.
     * @param {UserDeleteManyArgs} args - Arguments to filter Users to delete.
     * @example
     * // Delete a few Users
     * const { count } = await prisma.user.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends UserDeleteManyArgs>(args?: SelectSubset<T, UserDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Users
     * const user = await prisma.user.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends UserUpdateManyArgs>(args: SelectSubset<T, UserUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one User.
     * @param {UserUpsertArgs} args - Arguments to update or create a User.
     * @example
     * // Update or create a User
     * const user = await prisma.user.upsert({
     *   create: {
     *     // ... data to create a User
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the User we want to update
     *   }
     * })
     */
    upsert<T extends UserUpsertArgs>(args: SelectSubset<T, UserUpsertArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Users.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserCountArgs} args - Arguments to filter Users to count.
     * @example
     * // Count the number of Users
     * const count = await prisma.user.count({
     *   where: {
     *     // ... the filter for the Users we want to count
     *   }
     * })
    **/
    count<T extends UserCountArgs>(
      args?: Subset<T, UserCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], UserCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends UserAggregateArgs>(args: Subset<T, UserAggregateArgs>): Prisma.PrismaPromise<GetUserAggregateType<T>>

    /**
     * Group by User.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {UserGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends UserGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: UserGroupByArgs['orderBy'] }
        : { orderBy?: UserGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, UserGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetUserGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the User model
   */
  readonly fields: UserFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for User.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__UserClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AuditLog<T extends User$AuditLogArgs<ExtArgs> = {}>(args?: Subset<T, User$AuditLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany"> | Null>
    Employee<T extends User$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, User$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    LeaveRequest<T extends User$LeaveRequestArgs<ExtArgs> = {}>(args?: Subset<T, User$LeaveRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    TimeEntry<T extends User$TimeEntryArgs<ExtArgs> = {}>(args?: Subset<T, User$TimeEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany"> | Null>
    DepartmentsCreated<T extends User$DepartmentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$DepartmentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany"> | Null>
    ShiftsCreated<T extends User$ShiftsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ShiftsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany"> | Null>
    ShiftAssignmentsCreated<T extends User$ShiftAssignmentsCreatedArgs<ExtArgs> = {}>(args?: Subset<T, User$ShiftAssignmentsCreatedArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    DeductionApprovals<T extends User$DeductionApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$DeductionApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findMany"> | Null>
    InfractionReports<T extends User$InfractionReportsArgs<ExtArgs> = {}>(args?: Subset<T, User$InfractionReportsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany"> | Null>
    InfractionApprovals<T extends User$InfractionApprovalsArgs<ExtArgs> = {}>(args?: Subset<T, User$InfractionApprovalsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the User model
   */ 
  interface UserFieldRefs {
    readonly id: FieldRef<"User", 'String'>
    readonly email: FieldRef<"User", 'String'>
    readonly password: FieldRef<"User", 'String'>
    readonly firstName: FieldRef<"User", 'String'>
    readonly lastName: FieldRef<"User", 'String'>
    readonly role: FieldRef<"User", 'String'>
    readonly permissions: FieldRef<"User", 'String'>
    readonly isActive: FieldRef<"User", 'Boolean'>
    readonly createdAt: FieldRef<"User", 'DateTime'>
    readonly updatedAt: FieldRef<"User", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * User findUnique
   */
  export type UserFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findUniqueOrThrow
   */
  export type UserFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User findFirst
   */
  export type UserFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findFirstOrThrow
   */
  export type UserFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which User to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Users.
     */
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User findMany
   */
  export type UserFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter, which Users to fetch.
     */
    where?: UserWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Users to fetch.
     */
    orderBy?: UserOrderByWithRelationInput | UserOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Users.
     */
    cursor?: UserWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Users from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Users.
     */
    skip?: number
    distinct?: UserScalarFieldEnum | UserScalarFieldEnum[]
  }

  /**
   * User create
   */
  export type UserCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to create a User.
     */
    data: XOR<UserCreateInput, UserUncheckedCreateInput>
  }

  /**
   * User createMany
   */
  export type UserCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User createManyAndReturn
   */
  export type UserCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Users.
     */
    data: UserCreateManyInput | UserCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * User update
   */
  export type UserUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The data needed to update a User.
     */
    data: XOR<UserUpdateInput, UserUncheckedUpdateInput>
    /**
     * Choose, which User to update.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User updateMany
   */
  export type UserUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Users.
     */
    data: XOR<UserUpdateManyMutationInput, UserUncheckedUpdateManyInput>
    /**
     * Filter which Users to update
     */
    where?: UserWhereInput
  }

  /**
   * User upsert
   */
  export type UserUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * The filter to search for the User to update in case it exists.
     */
    where: UserWhereUniqueInput
    /**
     * In case the User found by the `where` argument doesn't exist, create a new User with this data.
     */
    create: XOR<UserCreateInput, UserUncheckedCreateInput>
    /**
     * In case the User was found with the provided `where` argument, update it with this data.
     */
    update: XOR<UserUpdateInput, UserUncheckedUpdateInput>
  }

  /**
   * User delete
   */
  export type UserDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    /**
     * Filter which User to delete.
     */
    where: UserWhereUniqueInput
  }

  /**
   * User deleteMany
   */
  export type UserDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Users to delete
     */
    where?: UserWhereInput
  }

  /**
   * User.AuditLog
   */
  export type User$AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    cursor?: AuditLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * User.Employee
   */
  export type User$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * User.LeaveRequest
   */
  export type User$LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * User.TimeEntry
   */
  export type User$TimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * User.DepartmentsCreated
   */
  export type User$DepartmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    cursor?: DepartmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * User.ShiftsCreated
   */
  export type User$ShiftsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    cursor?: ShiftWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * User.ShiftAssignmentsCreated
   */
  export type User$ShiftAssignmentsCreatedArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * User.DeductionApprovals
   */
  export type User$DeductionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    where?: PayrollDeductionWhereInput
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    cursor?: PayrollDeductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollDeductionScalarFieldEnum | PayrollDeductionScalarFieldEnum[]
  }

  /**
   * User.InfractionReports
   */
  export type User$InfractionReportsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    cursor?: InfractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * User.InfractionApprovals
   */
  export type User$InfractionApprovalsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    cursor?: InfractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * User without action
   */
  export type UserDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
  }


  /**
   * Model Department
   */

  export type AggregateDepartment = {
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  export type DepartmentAvgAggregateOutputType = {
    budget: number | null
  }

  export type DepartmentSumAggregateOutputType = {
    budget: number | null
  }

  export type DepartmentMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    managerId: string | null
    color: string | null
    budget: number | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    managerId: string | null
    color: string | null
    budget: number | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type DepartmentCountAggregateOutputType = {
    id: number
    name: number
    description: number
    managerId: number
    color: number
    budget: number
    isActive: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type DepartmentAvgAggregateInputType = {
    budget?: true
  }

  export type DepartmentSumAggregateInputType = {
    budget?: true
  }

  export type DepartmentMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    color?: true
    budget?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    color?: true
    budget?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type DepartmentCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    managerId?: true
    color?: true
    budget?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type DepartmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Department to aggregate.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Departments
    **/
    _count?: true | DepartmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: DepartmentAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: DepartmentSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: DepartmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: DepartmentMaxAggregateInputType
  }

  export type GetDepartmentAggregateType<T extends DepartmentAggregateArgs> = {
        [P in keyof T & keyof AggregateDepartment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateDepartment[P]>
      : GetScalarType<T[P], AggregateDepartment[P]>
  }




  export type DepartmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: DepartmentWhereInput
    orderBy?: DepartmentOrderByWithAggregationInput | DepartmentOrderByWithAggregationInput[]
    by: DepartmentScalarFieldEnum[] | DepartmentScalarFieldEnum
    having?: DepartmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: DepartmentCountAggregateInputType | true
    _avg?: DepartmentAvgAggregateInputType
    _sum?: DepartmentSumAggregateInputType
    _min?: DepartmentMinAggregateInputType
    _max?: DepartmentMaxAggregateInputType
  }

  export type DepartmentGroupByOutputType = {
    id: string
    name: string
    description: string | null
    managerId: string | null
    color: string | null
    budget: number | null
    isActive: boolean
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: DepartmentCountAggregateOutputType | null
    _avg: DepartmentAvgAggregateOutputType | null
    _sum: DepartmentSumAggregateOutputType | null
    _min: DepartmentMinAggregateOutputType | null
    _max: DepartmentMaxAggregateOutputType | null
  }

  type GetDepartmentGroupByPayload<T extends DepartmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<DepartmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof DepartmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
            : GetScalarType<T[P], DepartmentGroupByOutputType[P]>
        }
      >
    >


  export type DepartmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    color?: boolean
    budget?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CreatedBy?: boolean | Department$CreatedByArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    color?: boolean
    budget?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CreatedBy?: boolean | Department$CreatedByArgs<ExtArgs>
  }, ExtArgs["result"]["department"]>

  export type DepartmentSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    managerId?: boolean
    color?: boolean
    budget?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type DepartmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedBy?: boolean | Department$CreatedByArgs<ExtArgs>
    employees?: boolean | Department$employeesArgs<ExtArgs>
    _count?: boolean | DepartmentCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type DepartmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedBy?: boolean | Department$CreatedByArgs<ExtArgs>
  }

  export type $DepartmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Department"
    objects: {
      CreatedBy: Prisma.$UserPayload<ExtArgs> | null
      employees: Prisma.$EmployeePayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      managerId: string | null
      color: string | null
      budget: number | null
      isActive: boolean
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["department"]>
    composites: {}
  }

  type DepartmentGetPayload<S extends boolean | null | undefined | DepartmentDefaultArgs> = $Result.GetResult<Prisma.$DepartmentPayload, S>

  type DepartmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<DepartmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: DepartmentCountAggregateInputType | true
    }

  export interface DepartmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Department'], meta: { name: 'Department' } }
    /**
     * Find zero or one Department that matches the filter.
     * @param {DepartmentFindUniqueArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends DepartmentFindUniqueArgs>(args: SelectSubset<T, DepartmentFindUniqueArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Department that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {DepartmentFindUniqueOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends DepartmentFindUniqueOrThrowArgs>(args: SelectSubset<T, DepartmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Department that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends DepartmentFindFirstArgs>(args?: SelectSubset<T, DepartmentFindFirstArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Department that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindFirstOrThrowArgs} args - Arguments to find a Department
     * @example
     * // Get one Department
     * const department = await prisma.department.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends DepartmentFindFirstOrThrowArgs>(args?: SelectSubset<T, DepartmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Departments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Departments
     * const departments = await prisma.department.findMany()
     * 
     * // Get first 10 Departments
     * const departments = await prisma.department.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const departmentWithIdOnly = await prisma.department.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends DepartmentFindManyArgs>(args?: SelectSubset<T, DepartmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Department.
     * @param {DepartmentCreateArgs} args - Arguments to create a Department.
     * @example
     * // Create one Department
     * const Department = await prisma.department.create({
     *   data: {
     *     // ... data to create a Department
     *   }
     * })
     * 
     */
    create<T extends DepartmentCreateArgs>(args: SelectSubset<T, DepartmentCreateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Departments.
     * @param {DepartmentCreateManyArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends DepartmentCreateManyArgs>(args?: SelectSubset<T, DepartmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Departments and returns the data saved in the database.
     * @param {DepartmentCreateManyAndReturnArgs} args - Arguments to create many Departments.
     * @example
     * // Create many Departments
     * const department = await prisma.department.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Departments and only return the `id`
     * const departmentWithIdOnly = await prisma.department.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends DepartmentCreateManyAndReturnArgs>(args?: SelectSubset<T, DepartmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Department.
     * @param {DepartmentDeleteArgs} args - Arguments to delete one Department.
     * @example
     * // Delete one Department
     * const Department = await prisma.department.delete({
     *   where: {
     *     // ... filter to delete one Department
     *   }
     * })
     * 
     */
    delete<T extends DepartmentDeleteArgs>(args: SelectSubset<T, DepartmentDeleteArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Department.
     * @param {DepartmentUpdateArgs} args - Arguments to update one Department.
     * @example
     * // Update one Department
     * const department = await prisma.department.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends DepartmentUpdateArgs>(args: SelectSubset<T, DepartmentUpdateArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Departments.
     * @param {DepartmentDeleteManyArgs} args - Arguments to filter Departments to delete.
     * @example
     * // Delete a few Departments
     * const { count } = await prisma.department.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends DepartmentDeleteManyArgs>(args?: SelectSubset<T, DepartmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Departments
     * const department = await prisma.department.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends DepartmentUpdateManyArgs>(args: SelectSubset<T, DepartmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Department.
     * @param {DepartmentUpsertArgs} args - Arguments to update or create a Department.
     * @example
     * // Update or create a Department
     * const department = await prisma.department.upsert({
     *   create: {
     *     // ... data to create a Department
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Department we want to update
     *   }
     * })
     */
    upsert<T extends DepartmentUpsertArgs>(args: SelectSubset<T, DepartmentUpsertArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Departments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentCountArgs} args - Arguments to filter Departments to count.
     * @example
     * // Count the number of Departments
     * const count = await prisma.department.count({
     *   where: {
     *     // ... the filter for the Departments we want to count
     *   }
     * })
    **/
    count<T extends DepartmentCountArgs>(
      args?: Subset<T, DepartmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], DepartmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends DepartmentAggregateArgs>(args: Subset<T, DepartmentAggregateArgs>): Prisma.PrismaPromise<GetDepartmentAggregateType<T>>

    /**
     * Group by Department.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {DepartmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends DepartmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: DepartmentGroupByArgs['orderBy'] }
        : { orderBy?: DepartmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, DepartmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetDepartmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Department model
   */
  readonly fields: DepartmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Department.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__DepartmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CreatedBy<T extends Department$CreatedByArgs<ExtArgs> = {}>(args?: Subset<T, Department$CreatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employees<T extends Department$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Department$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Department model
   */ 
  interface DepartmentFieldRefs {
    readonly id: FieldRef<"Department", 'String'>
    readonly name: FieldRef<"Department", 'String'>
    readonly description: FieldRef<"Department", 'String'>
    readonly managerId: FieldRef<"Department", 'String'>
    readonly color: FieldRef<"Department", 'String'>
    readonly budget: FieldRef<"Department", 'Float'>
    readonly isActive: FieldRef<"Department", 'Boolean'>
    readonly createdById: FieldRef<"Department", 'String'>
    readonly createdAt: FieldRef<"Department", 'DateTime'>
    readonly updatedAt: FieldRef<"Department", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Department findUnique
   */
  export type DepartmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findUniqueOrThrow
   */
  export type DepartmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department findFirst
   */
  export type DepartmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findFirstOrThrow
   */
  export type DepartmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Department to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Departments.
     */
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department findMany
   */
  export type DepartmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter, which Departments to fetch.
     */
    where?: DepartmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Departments to fetch.
     */
    orderBy?: DepartmentOrderByWithRelationInput | DepartmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Departments.
     */
    cursor?: DepartmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Departments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Departments.
     */
    skip?: number
    distinct?: DepartmentScalarFieldEnum | DepartmentScalarFieldEnum[]
  }

  /**
   * Department create
   */
  export type DepartmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to create a Department.
     */
    data: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
  }

  /**
   * Department createMany
   */
  export type DepartmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Department createManyAndReturn
   */
  export type DepartmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Departments.
     */
    data: DepartmentCreateManyInput | DepartmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Department update
   */
  export type DepartmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The data needed to update a Department.
     */
    data: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
    /**
     * Choose, which Department to update.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department updateMany
   */
  export type DepartmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Departments.
     */
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyInput>
    /**
     * Filter which Departments to update
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department upsert
   */
  export type DepartmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * The filter to search for the Department to update in case it exists.
     */
    where: DepartmentWhereUniqueInput
    /**
     * In case the Department found by the `where` argument doesn't exist, create a new Department with this data.
     */
    create: XOR<DepartmentCreateInput, DepartmentUncheckedCreateInput>
    /**
     * In case the Department was found with the provided `where` argument, update it with this data.
     */
    update: XOR<DepartmentUpdateInput, DepartmentUncheckedUpdateInput>
  }

  /**
   * Department delete
   */
  export type DepartmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    /**
     * Filter which Department to delete.
     */
    where: DepartmentWhereUniqueInput
  }

  /**
   * Department deleteMany
   */
  export type DepartmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Departments to delete
     */
    where?: DepartmentWhereInput
  }

  /**
   * Department.CreatedBy
   */
  export type Department$CreatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Department.employees
   */
  export type Department$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Department without action
   */
  export type DepartmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
  }


  /**
   * Model Shift
   */

  export type AggregateShift = {
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  export type ShiftAvgAggregateOutputType = {
    breakDuration: number | null
    graceMinutes: number | null
    overtimeAfter: number | null
  }

  export type ShiftSumAggregateOutputType = {
    breakDuration: number | null
    graceMinutes: number | null
    overtimeAfter: number | null
  }

  export type ShiftMinAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    breakDuration: number | null
    graceMinutes: number | null
    overtimeAfter: number | null
    workingDays: string | null
    color: string | null
    isNightShift: boolean | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftMaxAggregateOutputType = {
    id: string | null
    name: string | null
    description: string | null
    startTime: string | null
    endTime: string | null
    breakDuration: number | null
    graceMinutes: number | null
    overtimeAfter: number | null
    workingDays: string | null
    color: string | null
    isNightShift: boolean | null
    isActive: boolean | null
    createdById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type ShiftCountAggregateOutputType = {
    id: number
    name: number
    description: number
    startTime: number
    endTime: number
    breakDuration: number
    graceMinutes: number
    overtimeAfter: number
    workingDays: number
    color: number
    isNightShift: number
    isActive: number
    createdById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type ShiftAvgAggregateInputType = {
    breakDuration?: true
    graceMinutes?: true
    overtimeAfter?: true
  }

  export type ShiftSumAggregateInputType = {
    breakDuration?: true
    graceMinutes?: true
    overtimeAfter?: true
  }

  export type ShiftMinAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    breakDuration?: true
    graceMinutes?: true
    overtimeAfter?: true
    workingDays?: true
    color?: true
    isNightShift?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftMaxAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    breakDuration?: true
    graceMinutes?: true
    overtimeAfter?: true
    workingDays?: true
    color?: true
    isNightShift?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type ShiftCountAggregateInputType = {
    id?: true
    name?: true
    description?: true
    startTime?: true
    endTime?: true
    breakDuration?: true
    graceMinutes?: true
    overtimeAfter?: true
    workingDays?: true
    color?: true
    isNightShift?: true
    isActive?: true
    createdById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type ShiftAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shift to aggregate.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Shifts
    **/
    _count?: true | ShiftCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: ShiftAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: ShiftSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftMaxAggregateInputType
  }

  export type GetShiftAggregateType<T extends ShiftAggregateArgs> = {
        [P in keyof T & keyof AggregateShift]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShift[P]>
      : GetScalarType<T[P], AggregateShift[P]>
  }




  export type ShiftGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftWhereInput
    orderBy?: ShiftOrderByWithAggregationInput | ShiftOrderByWithAggregationInput[]
    by: ShiftScalarFieldEnum[] | ShiftScalarFieldEnum
    having?: ShiftScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftCountAggregateInputType | true
    _avg?: ShiftAvgAggregateInputType
    _sum?: ShiftSumAggregateInputType
    _min?: ShiftMinAggregateInputType
    _max?: ShiftMaxAggregateInputType
  }

  export type ShiftGroupByOutputType = {
    id: string
    name: string
    description: string | null
    startTime: string
    endTime: string
    breakDuration: number
    graceMinutes: number
    overtimeAfter: number
    workingDays: string
    color: string | null
    isNightShift: boolean
    isActive: boolean
    createdById: string | null
    createdAt: Date
    updatedAt: Date
    _count: ShiftCountAggregateOutputType | null
    _avg: ShiftAvgAggregateOutputType | null
    _sum: ShiftSumAggregateOutputType | null
    _min: ShiftMinAggregateOutputType | null
    _max: ShiftMaxAggregateOutputType | null
  }

  type GetShiftGroupByPayload<T extends ShiftGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftGroupByOutputType[P]>
        }
      >
    >


  export type ShiftSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    breakDuration?: boolean
    graceMinutes?: boolean
    overtimeAfter?: boolean
    workingDays?: boolean
    color?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CreatedBy?: boolean | Shift$CreatedByArgs<ExtArgs>
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    ShiftAssignment?: boolean | Shift$ShiftAssignmentArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    breakDuration?: boolean
    graceMinutes?: boolean
    overtimeAfter?: boolean
    workingDays?: boolean
    color?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    CreatedBy?: boolean | Shift$CreatedByArgs<ExtArgs>
  }, ExtArgs["result"]["shift"]>

  export type ShiftSelectScalar = {
    id?: boolean
    name?: boolean
    description?: boolean
    startTime?: boolean
    endTime?: boolean
    breakDuration?: boolean
    graceMinutes?: boolean
    overtimeAfter?: boolean
    workingDays?: boolean
    color?: boolean
    isNightShift?: boolean
    isActive?: boolean
    createdById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type ShiftInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedBy?: boolean | Shift$CreatedByArgs<ExtArgs>
    employees?: boolean | Shift$employeesArgs<ExtArgs>
    ShiftAssignment?: boolean | Shift$ShiftAssignmentArgs<ExtArgs>
    _count?: boolean | ShiftCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type ShiftIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    CreatedBy?: boolean | Shift$CreatedByArgs<ExtArgs>
  }

  export type $ShiftPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Shift"
    objects: {
      CreatedBy: Prisma.$UserPayload<ExtArgs> | null
      employees: Prisma.$EmployeePayload<ExtArgs>[]
      ShiftAssignment: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      description: string | null
      startTime: string
      endTime: string
      breakDuration: number
      graceMinutes: number
      overtimeAfter: number
      workingDays: string
      color: string | null
      isNightShift: boolean
      isActive: boolean
      createdById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["shift"]>
    composites: {}
  }

  type ShiftGetPayload<S extends boolean | null | undefined | ShiftDefaultArgs> = $Result.GetResult<Prisma.$ShiftPayload, S>

  type ShiftCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftCountAggregateInputType | true
    }

  export interface ShiftDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Shift'], meta: { name: 'Shift' } }
    /**
     * Find zero or one Shift that matches the filter.
     * @param {ShiftFindUniqueArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftFindUniqueArgs>(args: SelectSubset<T, ShiftFindUniqueArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Shift that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftFindUniqueOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Shift that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftFindFirstArgs>(args?: SelectSubset<T, ShiftFindFirstArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Shift that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindFirstOrThrowArgs} args - Arguments to find a Shift
     * @example
     * // Get one Shift
     * const shift = await prisma.shift.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Shifts that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Shifts
     * const shifts = await prisma.shift.findMany()
     * 
     * // Get first 10 Shifts
     * const shifts = await prisma.shift.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftWithIdOnly = await prisma.shift.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftFindManyArgs>(args?: SelectSubset<T, ShiftFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Shift.
     * @param {ShiftCreateArgs} args - Arguments to create a Shift.
     * @example
     * // Create one Shift
     * const Shift = await prisma.shift.create({
     *   data: {
     *     // ... data to create a Shift
     *   }
     * })
     * 
     */
    create<T extends ShiftCreateArgs>(args: SelectSubset<T, ShiftCreateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Shifts.
     * @param {ShiftCreateManyArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftCreateManyArgs>(args?: SelectSubset<T, ShiftCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Shifts and returns the data saved in the database.
     * @param {ShiftCreateManyAndReturnArgs} args - Arguments to create many Shifts.
     * @example
     * // Create many Shifts
     * const shift = await prisma.shift.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Shifts and only return the `id`
     * const shiftWithIdOnly = await prisma.shift.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Shift.
     * @param {ShiftDeleteArgs} args - Arguments to delete one Shift.
     * @example
     * // Delete one Shift
     * const Shift = await prisma.shift.delete({
     *   where: {
     *     // ... filter to delete one Shift
     *   }
     * })
     * 
     */
    delete<T extends ShiftDeleteArgs>(args: SelectSubset<T, ShiftDeleteArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Shift.
     * @param {ShiftUpdateArgs} args - Arguments to update one Shift.
     * @example
     * // Update one Shift
     * const shift = await prisma.shift.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftUpdateArgs>(args: SelectSubset<T, ShiftUpdateArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Shifts.
     * @param {ShiftDeleteManyArgs} args - Arguments to filter Shifts to delete.
     * @example
     * // Delete a few Shifts
     * const { count } = await prisma.shift.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftDeleteManyArgs>(args?: SelectSubset<T, ShiftDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Shifts
     * const shift = await prisma.shift.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftUpdateManyArgs>(args: SelectSubset<T, ShiftUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Shift.
     * @param {ShiftUpsertArgs} args - Arguments to update or create a Shift.
     * @example
     * // Update or create a Shift
     * const shift = await prisma.shift.upsert({
     *   create: {
     *     // ... data to create a Shift
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Shift we want to update
     *   }
     * })
     */
    upsert<T extends ShiftUpsertArgs>(args: SelectSubset<T, ShiftUpsertArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Shifts.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftCountArgs} args - Arguments to filter Shifts to count.
     * @example
     * // Count the number of Shifts
     * const count = await prisma.shift.count({
     *   where: {
     *     // ... the filter for the Shifts we want to count
     *   }
     * })
    **/
    count<T extends ShiftCountArgs>(
      args?: Subset<T, ShiftCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAggregateArgs>(args: Subset<T, ShiftAggregateArgs>): Prisma.PrismaPromise<GetShiftAggregateType<T>>

    /**
     * Group by Shift.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftGroupByArgs['orderBy'] }
        : { orderBy?: ShiftGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Shift model
   */
  readonly fields: ShiftFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Shift.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    CreatedBy<T extends Shift$CreatedByArgs<ExtArgs> = {}>(args?: Subset<T, Shift$CreatedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    employees<T extends Shift$employeesArgs<ExtArgs> = {}>(args?: Subset<T, Shift$employeesArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    ShiftAssignment<T extends Shift$ShiftAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Shift$ShiftAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Shift model
   */ 
  interface ShiftFieldRefs {
    readonly id: FieldRef<"Shift", 'String'>
    readonly name: FieldRef<"Shift", 'String'>
    readonly description: FieldRef<"Shift", 'String'>
    readonly startTime: FieldRef<"Shift", 'String'>
    readonly endTime: FieldRef<"Shift", 'String'>
    readonly breakDuration: FieldRef<"Shift", 'Int'>
    readonly graceMinutes: FieldRef<"Shift", 'Int'>
    readonly overtimeAfter: FieldRef<"Shift", 'Float'>
    readonly workingDays: FieldRef<"Shift", 'String'>
    readonly color: FieldRef<"Shift", 'String'>
    readonly isNightShift: FieldRef<"Shift", 'Boolean'>
    readonly isActive: FieldRef<"Shift", 'Boolean'>
    readonly createdById: FieldRef<"Shift", 'String'>
    readonly createdAt: FieldRef<"Shift", 'DateTime'>
    readonly updatedAt: FieldRef<"Shift", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Shift findUnique
   */
  export type ShiftFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findUniqueOrThrow
   */
  export type ShiftFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift findFirst
   */
  export type ShiftFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findFirstOrThrow
   */
  export type ShiftFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shift to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Shifts.
     */
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift findMany
   */
  export type ShiftFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter, which Shifts to fetch.
     */
    where?: ShiftWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Shifts to fetch.
     */
    orderBy?: ShiftOrderByWithRelationInput | ShiftOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Shifts.
     */
    cursor?: ShiftWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Shifts from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Shifts.
     */
    skip?: number
    distinct?: ShiftScalarFieldEnum | ShiftScalarFieldEnum[]
  }

  /**
   * Shift create
   */
  export type ShiftCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to create a Shift.
     */
    data: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
  }

  /**
   * Shift createMany
   */
  export type ShiftCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Shift createManyAndReturn
   */
  export type ShiftCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Shifts.
     */
    data: ShiftCreateManyInput | ShiftCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Shift update
   */
  export type ShiftUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The data needed to update a Shift.
     */
    data: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
    /**
     * Choose, which Shift to update.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift updateMany
   */
  export type ShiftUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Shifts.
     */
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyInput>
    /**
     * Filter which Shifts to update
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift upsert
   */
  export type ShiftUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * The filter to search for the Shift to update in case it exists.
     */
    where: ShiftWhereUniqueInput
    /**
     * In case the Shift found by the `where` argument doesn't exist, create a new Shift with this data.
     */
    create: XOR<ShiftCreateInput, ShiftUncheckedCreateInput>
    /**
     * In case the Shift was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftUpdateInput, ShiftUncheckedUpdateInput>
  }

  /**
   * Shift delete
   */
  export type ShiftDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    /**
     * Filter which Shift to delete.
     */
    where: ShiftWhereUniqueInput
  }

  /**
   * Shift deleteMany
   */
  export type ShiftDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Shifts to delete
     */
    where?: ShiftWhereInput
  }

  /**
   * Shift.CreatedBy
   */
  export type Shift$CreatedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Shift.employees
   */
  export type Shift$employeesArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Shift.ShiftAssignment
   */
  export type Shift$ShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * Shift without action
   */
  export type ShiftDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
  }


  /**
   * Model Employee
   */

  export type AggregateEmployee = {
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  export type EmployeeAvgAggregateOutputType = {
    salary: number | null
    hourlyRate: number | null
  }

  export type EmployeeSumAggregateOutputType = {
    salary: number | null
    hourlyRate: number | null
  }

  export type EmployeeMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    photo: string | null
    departmentId: string | null
    designation: string | null
    managerId: string | null
    joinDate: Date | null
    employmentType: string | null
    status: string | null
    shiftId: string | null
    salary: number | null
    hourlyRate: number | null
    cardNumber: string | null
    faceEnrolled: boolean | null
    fingerprintEnrolled: boolean | null
    fingerprintTemplate: string | null
    fingerprintTemplateDate: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    firstName: string | null
    lastName: string | null
    email: string | null
    phone: string | null
    photo: string | null
    departmentId: string | null
    designation: string | null
    managerId: string | null
    joinDate: Date | null
    employmentType: string | null
    status: string | null
    shiftId: string | null
    salary: number | null
    hourlyRate: number | null
    cardNumber: string | null
    faceEnrolled: boolean | null
    fingerprintEnrolled: boolean | null
    fingerprintTemplate: string | null
    fingerprintTemplateDate: Date | null
    userId: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeCountAggregateOutputType = {
    id: number
    employeeId: number
    firstName: number
    lastName: number
    email: number
    phone: number
    photo: number
    departmentId: number
    designation: number
    managerId: number
    joinDate: number
    employmentType: number
    status: number
    shiftId: number
    salary: number
    hourlyRate: number
    cardNumber: number
    faceEnrolled: number
    fingerprintEnrolled: number
    fingerprintTemplate: number
    fingerprintTemplateDate: number
    userId: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeAvgAggregateInputType = {
    salary?: true
    hourlyRate?: true
  }

  export type EmployeeSumAggregateInputType = {
    salary?: true
    hourlyRate?: true
  }

  export type EmployeeMinAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    photo?: true
    departmentId?: true
    designation?: true
    managerId?: true
    joinDate?: true
    employmentType?: true
    status?: true
    shiftId?: true
    salary?: true
    hourlyRate?: true
    cardNumber?: true
    faceEnrolled?: true
    fingerprintEnrolled?: true
    fingerprintTemplate?: true
    fingerprintTemplateDate?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeMaxAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    photo?: true
    departmentId?: true
    designation?: true
    managerId?: true
    joinDate?: true
    employmentType?: true
    status?: true
    shiftId?: true
    salary?: true
    hourlyRate?: true
    cardNumber?: true
    faceEnrolled?: true
    fingerprintEnrolled?: true
    fingerprintTemplate?: true
    fingerprintTemplateDate?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeCountAggregateInputType = {
    id?: true
    employeeId?: true
    firstName?: true
    lastName?: true
    email?: true
    phone?: true
    photo?: true
    departmentId?: true
    designation?: true
    managerId?: true
    joinDate?: true
    employmentType?: true
    status?: true
    shiftId?: true
    salary?: true
    hourlyRate?: true
    cardNumber?: true
    faceEnrolled?: true
    fingerprintEnrolled?: true
    fingerprintTemplate?: true
    fingerprintTemplateDate?: true
    userId?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employee to aggregate.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Employees
    **/
    _count?: true | EmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeMaxAggregateInputType
  }

  export type GetEmployeeAggregateType<T extends EmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployee[P]>
      : GetScalarType<T[P], AggregateEmployee[P]>
  }




  export type EmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithAggregationInput | EmployeeOrderByWithAggregationInput[]
    by: EmployeeScalarFieldEnum[] | EmployeeScalarFieldEnum
    having?: EmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeCountAggregateInputType | true
    _avg?: EmployeeAvgAggregateInputType
    _sum?: EmployeeSumAggregateInputType
    _min?: EmployeeMinAggregateInputType
    _max?: EmployeeMaxAggregateInputType
  }

  export type EmployeeGroupByOutputType = {
    id: string
    employeeId: string
    firstName: string
    lastName: string
    email: string | null
    phone: string | null
    photo: string | null
    departmentId: string | null
    designation: string | null
    managerId: string | null
    joinDate: Date
    employmentType: string
    status: string
    shiftId: string | null
    salary: number | null
    hourlyRate: number | null
    cardNumber: string | null
    faceEnrolled: boolean
    fingerprintEnrolled: boolean
    fingerprintTemplate: string | null
    fingerprintTemplateDate: Date | null
    userId: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeCountAggregateOutputType | null
    _avg: EmployeeAvgAggregateOutputType | null
    _sum: EmployeeSumAggregateOutputType | null
    _min: EmployeeMinAggregateOutputType | null
    _max: EmployeeMaxAggregateOutputType | null
  }

  type GetEmployeeGroupByPayload<T extends EmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    photo?: boolean
    departmentId?: boolean
    designation?: boolean
    managerId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    status?: boolean
    shiftId?: boolean
    salary?: boolean
    hourlyRate?: boolean
    cardNumber?: boolean
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: boolean
    fingerprintTemplateDate?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AttendanceLog?: boolean | Employee$AttendanceLogArgs<ExtArgs>
    BiometricData?: boolean | Employee$BiometricDataArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    Employee?: boolean | Employee$EmployeeArgs<ExtArgs>
    other_Employee?: boolean | Employee$other_EmployeeArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    User?: boolean | Employee$UserArgs<ExtArgs>
    LeaveBalance?: boolean | Employee$LeaveBalanceArgs<ExtArgs>
    LeaveRequest?: boolean | Employee$LeaveRequestArgs<ExtArgs>
    Notification?: boolean | Employee$NotificationArgs<ExtArgs>
    ShiftAssignment?: boolean | Employee$ShiftAssignmentArgs<ExtArgs>
    TimeEntry?: boolean | Employee$TimeEntryArgs<ExtArgs>
    EmployeeRate?: boolean | Employee$EmployeeRateArgs<ExtArgs>
    EmployeeDeductions?: boolean | Employee$EmployeeDeductionsArgs<ExtArgs>
    EmployeeInfractions?: boolean | Employee$EmployeeInfractionsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    photo?: boolean
    departmentId?: boolean
    designation?: boolean
    managerId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    status?: boolean
    shiftId?: boolean
    salary?: boolean
    hourlyRate?: boolean
    cardNumber?: boolean
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: boolean
    fingerprintTemplateDate?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    department?: boolean | Employee$departmentArgs<ExtArgs>
    Employee?: boolean | Employee$EmployeeArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    User?: boolean | Employee$UserArgs<ExtArgs>
  }, ExtArgs["result"]["employee"]>

  export type EmployeeSelectScalar = {
    id?: boolean
    employeeId?: boolean
    firstName?: boolean
    lastName?: boolean
    email?: boolean
    phone?: boolean
    photo?: boolean
    departmentId?: boolean
    designation?: boolean
    managerId?: boolean
    joinDate?: boolean
    employmentType?: boolean
    status?: boolean
    shiftId?: boolean
    salary?: boolean
    hourlyRate?: boolean
    cardNumber?: boolean
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: boolean
    fingerprintTemplateDate?: boolean
    userId?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttendanceLog?: boolean | Employee$AttendanceLogArgs<ExtArgs>
    BiometricData?: boolean | Employee$BiometricDataArgs<ExtArgs>
    department?: boolean | Employee$departmentArgs<ExtArgs>
    Employee?: boolean | Employee$EmployeeArgs<ExtArgs>
    other_Employee?: boolean | Employee$other_EmployeeArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    User?: boolean | Employee$UserArgs<ExtArgs>
    LeaveBalance?: boolean | Employee$LeaveBalanceArgs<ExtArgs>
    LeaveRequest?: boolean | Employee$LeaveRequestArgs<ExtArgs>
    Notification?: boolean | Employee$NotificationArgs<ExtArgs>
    ShiftAssignment?: boolean | Employee$ShiftAssignmentArgs<ExtArgs>
    TimeEntry?: boolean | Employee$TimeEntryArgs<ExtArgs>
    EmployeeRate?: boolean | Employee$EmployeeRateArgs<ExtArgs>
    EmployeeDeductions?: boolean | Employee$EmployeeDeductionsArgs<ExtArgs>
    EmployeeInfractions?: boolean | Employee$EmployeeInfractionsArgs<ExtArgs>
    _count?: boolean | EmployeeCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type EmployeeIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    department?: boolean | Employee$departmentArgs<ExtArgs>
    Employee?: boolean | Employee$EmployeeArgs<ExtArgs>
    shift?: boolean | Employee$shiftArgs<ExtArgs>
    User?: boolean | Employee$UserArgs<ExtArgs>
  }

  export type $EmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Employee"
    objects: {
      AttendanceLog: Prisma.$AttendanceLogPayload<ExtArgs>[]
      BiometricData: Prisma.$BiometricDataPayload<ExtArgs>[]
      department: Prisma.$DepartmentPayload<ExtArgs> | null
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
      other_Employee: Prisma.$EmployeePayload<ExtArgs>[]
      shift: Prisma.$ShiftPayload<ExtArgs> | null
      User: Prisma.$UserPayload<ExtArgs> | null
      LeaveBalance: Prisma.$LeaveBalancePayload<ExtArgs>[]
      LeaveRequest: Prisma.$LeaveRequestPayload<ExtArgs>[]
      Notification: Prisma.$NotificationPayload<ExtArgs>[]
      ShiftAssignment: Prisma.$ShiftAssignmentPayload<ExtArgs>[]
      TimeEntry: Prisma.$TimeEntryPayload<ExtArgs>[]
      EmployeeRate: Prisma.$EmployeeRatePayload<ExtArgs> | null
      EmployeeDeductions: Prisma.$PayrollDeductionPayload<ExtArgs>[]
      EmployeeInfractions: Prisma.$InfractionPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      firstName: string
      lastName: string
      email: string | null
      phone: string | null
      photo: string | null
      departmentId: string | null
      designation: string | null
      managerId: string | null
      joinDate: Date
      employmentType: string
      status: string
      shiftId: string | null
      salary: number | null
      hourlyRate: number | null
      cardNumber: string | null
      faceEnrolled: boolean
      fingerprintEnrolled: boolean
      fingerprintTemplate: string | null
      fingerprintTemplateDate: Date | null
      userId: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employee"]>
    composites: {}
  }

  type EmployeeGetPayload<S extends boolean | null | undefined | EmployeeDefaultArgs> = $Result.GetResult<Prisma.$EmployeePayload, S>

  type EmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeCountAggregateInputType | true
    }

  export interface EmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Employee'], meta: { name: 'Employee' } }
    /**
     * Find zero or one Employee that matches the filter.
     * @param {EmployeeFindUniqueArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeFindUniqueArgs>(args: SelectSubset<T, EmployeeFindUniqueArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Employee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeFindUniqueOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Employee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeFindFirstArgs>(args?: SelectSubset<T, EmployeeFindFirstArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Employee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindFirstOrThrowArgs} args - Arguments to find a Employee
     * @example
     * // Get one Employee
     * const employee = await prisma.employee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Employees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Employees
     * const employees = await prisma.employee.findMany()
     * 
     * // Get first 10 Employees
     * const employees = await prisma.employee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeWithIdOnly = await prisma.employee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeFindManyArgs>(args?: SelectSubset<T, EmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Employee.
     * @param {EmployeeCreateArgs} args - Arguments to create a Employee.
     * @example
     * // Create one Employee
     * const Employee = await prisma.employee.create({
     *   data: {
     *     // ... data to create a Employee
     *   }
     * })
     * 
     */
    create<T extends EmployeeCreateArgs>(args: SelectSubset<T, EmployeeCreateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Employees.
     * @param {EmployeeCreateManyArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeCreateManyArgs>(args?: SelectSubset<T, EmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Employees and returns the data saved in the database.
     * @param {EmployeeCreateManyAndReturnArgs} args - Arguments to create many Employees.
     * @example
     * // Create many Employees
     * const employee = await prisma.employee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Employees and only return the `id`
     * const employeeWithIdOnly = await prisma.employee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Employee.
     * @param {EmployeeDeleteArgs} args - Arguments to delete one Employee.
     * @example
     * // Delete one Employee
     * const Employee = await prisma.employee.delete({
     *   where: {
     *     // ... filter to delete one Employee
     *   }
     * })
     * 
     */
    delete<T extends EmployeeDeleteArgs>(args: SelectSubset<T, EmployeeDeleteArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Employee.
     * @param {EmployeeUpdateArgs} args - Arguments to update one Employee.
     * @example
     * // Update one Employee
     * const employee = await prisma.employee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeUpdateArgs>(args: SelectSubset<T, EmployeeUpdateArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Employees.
     * @param {EmployeeDeleteManyArgs} args - Arguments to filter Employees to delete.
     * @example
     * // Delete a few Employees
     * const { count } = await prisma.employee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeDeleteManyArgs>(args?: SelectSubset<T, EmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Employees
     * const employee = await prisma.employee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeUpdateManyArgs>(args: SelectSubset<T, EmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Employee.
     * @param {EmployeeUpsertArgs} args - Arguments to update or create a Employee.
     * @example
     * // Update or create a Employee
     * const employee = await prisma.employee.upsert({
     *   create: {
     *     // ... data to create a Employee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Employee we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeUpsertArgs>(args: SelectSubset<T, EmployeeUpsertArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Employees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeCountArgs} args - Arguments to filter Employees to count.
     * @example
     * // Count the number of Employees
     * const count = await prisma.employee.count({
     *   where: {
     *     // ... the filter for the Employees we want to count
     *   }
     * })
    **/
    count<T extends EmployeeCountArgs>(
      args?: Subset<T, EmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeAggregateArgs>(args: Subset<T, EmployeeAggregateArgs>): Prisma.PrismaPromise<GetEmployeeAggregateType<T>>

    /**
     * Group by Employee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Employee model
   */
  readonly fields: EmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Employee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AttendanceLog<T extends Employee$AttendanceLogArgs<ExtArgs> = {}>(args?: Subset<T, Employee$AttendanceLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany"> | Null>
    BiometricData<T extends Employee$BiometricDataArgs<ExtArgs> = {}>(args?: Subset<T, Employee$BiometricDataArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findMany"> | Null>
    department<T extends Employee$departmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$departmentArgs<ExtArgs>>): Prisma__DepartmentClient<$Result.GetResult<Prisma.$DepartmentPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Employee<T extends Employee$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Employee$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    other_Employee<T extends Employee$other_EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Employee$other_EmployeeArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findMany"> | Null>
    shift<T extends Employee$shiftArgs<ExtArgs> = {}>(args?: Subset<T, Employee$shiftArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    User<T extends Employee$UserArgs<ExtArgs> = {}>(args?: Subset<T, Employee$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    LeaveBalance<T extends Employee$LeaveBalanceArgs<ExtArgs> = {}>(args?: Subset<T, Employee$LeaveBalanceArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany"> | Null>
    LeaveRequest<T extends Employee$LeaveRequestArgs<ExtArgs> = {}>(args?: Subset<T, Employee$LeaveRequestArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany"> | Null>
    Notification<T extends Employee$NotificationArgs<ExtArgs> = {}>(args?: Subset<T, Employee$NotificationArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany"> | Null>
    ShiftAssignment<T extends Employee$ShiftAssignmentArgs<ExtArgs> = {}>(args?: Subset<T, Employee$ShiftAssignmentArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany"> | Null>
    TimeEntry<T extends Employee$TimeEntryArgs<ExtArgs> = {}>(args?: Subset<T, Employee$TimeEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany"> | Null>
    EmployeeRate<T extends Employee$EmployeeRateArgs<ExtArgs> = {}>(args?: Subset<T, Employee$EmployeeRateArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    EmployeeDeductions<T extends Employee$EmployeeDeductionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$EmployeeDeductionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findMany"> | Null>
    EmployeeInfractions<T extends Employee$EmployeeInfractionsArgs<ExtArgs> = {}>(args?: Subset<T, Employee$EmployeeInfractionsArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Employee model
   */ 
  interface EmployeeFieldRefs {
    readonly id: FieldRef<"Employee", 'String'>
    readonly employeeId: FieldRef<"Employee", 'String'>
    readonly firstName: FieldRef<"Employee", 'String'>
    readonly lastName: FieldRef<"Employee", 'String'>
    readonly email: FieldRef<"Employee", 'String'>
    readonly phone: FieldRef<"Employee", 'String'>
    readonly photo: FieldRef<"Employee", 'String'>
    readonly departmentId: FieldRef<"Employee", 'String'>
    readonly designation: FieldRef<"Employee", 'String'>
    readonly managerId: FieldRef<"Employee", 'String'>
    readonly joinDate: FieldRef<"Employee", 'DateTime'>
    readonly employmentType: FieldRef<"Employee", 'String'>
    readonly status: FieldRef<"Employee", 'String'>
    readonly shiftId: FieldRef<"Employee", 'String'>
    readonly salary: FieldRef<"Employee", 'Float'>
    readonly hourlyRate: FieldRef<"Employee", 'Float'>
    readonly cardNumber: FieldRef<"Employee", 'String'>
    readonly faceEnrolled: FieldRef<"Employee", 'Boolean'>
    readonly fingerprintEnrolled: FieldRef<"Employee", 'Boolean'>
    readonly fingerprintTemplate: FieldRef<"Employee", 'String'>
    readonly fingerprintTemplateDate: FieldRef<"Employee", 'DateTime'>
    readonly userId: FieldRef<"Employee", 'String'>
    readonly createdAt: FieldRef<"Employee", 'DateTime'>
    readonly updatedAt: FieldRef<"Employee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Employee findUnique
   */
  export type EmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findUniqueOrThrow
   */
  export type EmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee findFirst
   */
  export type EmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findFirstOrThrow
   */
  export type EmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employee to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Employees.
     */
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee findMany
   */
  export type EmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter, which Employees to fetch.
     */
    where?: EmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Employees to fetch.
     */
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Employees.
     */
    cursor?: EmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Employees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Employees.
     */
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee create
   */
  export type EmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to create a Employee.
     */
    data: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
  }

  /**
   * Employee createMany
   */
  export type EmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Employee createManyAndReturn
   */
  export type EmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Employees.
     */
    data: EmployeeCreateManyInput | EmployeeCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Employee update
   */
  export type EmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The data needed to update a Employee.
     */
    data: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
    /**
     * Choose, which Employee to update.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee updateMany
   */
  export type EmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Employees.
     */
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyInput>
    /**
     * Filter which Employees to update
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee upsert
   */
  export type EmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * The filter to search for the Employee to update in case it exists.
     */
    where: EmployeeWhereUniqueInput
    /**
     * In case the Employee found by the `where` argument doesn't exist, create a new Employee with this data.
     */
    create: XOR<EmployeeCreateInput, EmployeeUncheckedCreateInput>
    /**
     * In case the Employee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeUpdateInput, EmployeeUncheckedUpdateInput>
  }

  /**
   * Employee delete
   */
  export type EmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    /**
     * Filter which Employee to delete.
     */
    where: EmployeeWhereUniqueInput
  }

  /**
   * Employee deleteMany
   */
  export type EmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Employees to delete
     */
    where?: EmployeeWhereInput
  }

  /**
   * Employee.AttendanceLog
   */
  export type Employee$AttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * Employee.BiometricData
   */
  export type Employee$BiometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    where?: BiometricDataWhereInput
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    cursor?: BiometricDataWhereUniqueInput
    take?: number
    skip?: number
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * Employee.department
   */
  export type Employee$departmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Department
     */
    select?: DepartmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: DepartmentInclude<ExtArgs> | null
    where?: DepartmentWhereInput
  }

  /**
   * Employee.Employee
   */
  export type Employee$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Employee.other_Employee
   */
  export type Employee$other_EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
    orderBy?: EmployeeOrderByWithRelationInput | EmployeeOrderByWithRelationInput[]
    cursor?: EmployeeWhereUniqueInput
    take?: number
    skip?: number
    distinct?: EmployeeScalarFieldEnum | EmployeeScalarFieldEnum[]
  }

  /**
   * Employee.shift
   */
  export type Employee$shiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Shift
     */
    select?: ShiftSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftInclude<ExtArgs> | null
    where?: ShiftWhereInput
  }

  /**
   * Employee.User
   */
  export type Employee$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Employee.LeaveBalance
   */
  export type Employee$LeaveBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    cursor?: LeaveBalanceWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * Employee.LeaveRequest
   */
  export type Employee$LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    cursor?: LeaveRequestWhereUniqueInput
    take?: number
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * Employee.Notification
   */
  export type Employee$NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    cursor?: NotificationWhereUniqueInput
    take?: number
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Employee.ShiftAssignment
   */
  export type Employee$ShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    cursor?: ShiftAssignmentWhereUniqueInput
    take?: number
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * Employee.TimeEntry
   */
  export type Employee$TimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Employee.EmployeeRate
   */
  export type Employee$EmployeeRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    where?: EmployeeRateWhereInput
  }

  /**
   * Employee.EmployeeDeductions
   */
  export type Employee$EmployeeDeductionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    where?: PayrollDeductionWhereInput
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    cursor?: PayrollDeductionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: PayrollDeductionScalarFieldEnum | PayrollDeductionScalarFieldEnum[]
  }

  /**
   * Employee.EmployeeInfractions
   */
  export type Employee$EmployeeInfractionsArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    cursor?: InfractionWhereUniqueInput
    take?: number
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Employee without action
   */
  export type EmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
  }


  /**
   * Model InactiveEmployee
   */

  export type AggregateInactiveEmployee = {
    _count: InactiveEmployeeCountAggregateOutputType | null
    _min: InactiveEmployeeMinAggregateOutputType | null
    _max: InactiveEmployeeMaxAggregateOutputType | null
  }

  export type InactiveEmployeeMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    employeeName: string | null
    departmentId: string | null
    inactiveReason: string | null
    details: string | null
    suspendedBy: string | null
    suspendedAt: Date | null
    reactivatedAt: Date | null
    reactivatedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InactiveEmployeeMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    employeeName: string | null
    departmentId: string | null
    inactiveReason: string | null
    details: string | null
    suspendedBy: string | null
    suspendedAt: Date | null
    reactivatedAt: Date | null
    reactivatedBy: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InactiveEmployeeCountAggregateOutputType = {
    id: number
    employeeId: number
    employeeName: number
    departmentId: number
    inactiveReason: number
    details: number
    suspendedBy: number
    suspendedAt: number
    reactivatedAt: number
    reactivatedBy: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InactiveEmployeeMinAggregateInputType = {
    id?: true
    employeeId?: true
    employeeName?: true
    departmentId?: true
    inactiveReason?: true
    details?: true
    suspendedBy?: true
    suspendedAt?: true
    reactivatedAt?: true
    reactivatedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InactiveEmployeeMaxAggregateInputType = {
    id?: true
    employeeId?: true
    employeeName?: true
    departmentId?: true
    inactiveReason?: true
    details?: true
    suspendedBy?: true
    suspendedAt?: true
    reactivatedAt?: true
    reactivatedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InactiveEmployeeCountAggregateInputType = {
    id?: true
    employeeId?: true
    employeeName?: true
    departmentId?: true
    inactiveReason?: true
    details?: true
    suspendedBy?: true
    suspendedAt?: true
    reactivatedAt?: true
    reactivatedBy?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InactiveEmployeeAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InactiveEmployee to aggregate.
     */
    where?: InactiveEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InactiveEmployees to fetch.
     */
    orderBy?: InactiveEmployeeOrderByWithRelationInput | InactiveEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InactiveEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InactiveEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InactiveEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned InactiveEmployees
    **/
    _count?: true | InactiveEmployeeCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InactiveEmployeeMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InactiveEmployeeMaxAggregateInputType
  }

  export type GetInactiveEmployeeAggregateType<T extends InactiveEmployeeAggregateArgs> = {
        [P in keyof T & keyof AggregateInactiveEmployee]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInactiveEmployee[P]>
      : GetScalarType<T[P], AggregateInactiveEmployee[P]>
  }




  export type InactiveEmployeeGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InactiveEmployeeWhereInput
    orderBy?: InactiveEmployeeOrderByWithAggregationInput | InactiveEmployeeOrderByWithAggregationInput[]
    by: InactiveEmployeeScalarFieldEnum[] | InactiveEmployeeScalarFieldEnum
    having?: InactiveEmployeeScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InactiveEmployeeCountAggregateInputType | true
    _min?: InactiveEmployeeMinAggregateInputType
    _max?: InactiveEmployeeMaxAggregateInputType
  }

  export type InactiveEmployeeGroupByOutputType = {
    id: string
    employeeId: string
    employeeName: string
    departmentId: string | null
    inactiveReason: string
    details: string | null
    suspendedBy: string | null
    suspendedAt: Date
    reactivatedAt: Date | null
    reactivatedBy: string | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InactiveEmployeeCountAggregateOutputType | null
    _min: InactiveEmployeeMinAggregateOutputType | null
    _max: InactiveEmployeeMaxAggregateOutputType | null
  }

  type GetInactiveEmployeeGroupByPayload<T extends InactiveEmployeeGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InactiveEmployeeGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InactiveEmployeeGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InactiveEmployeeGroupByOutputType[P]>
            : GetScalarType<T[P], InactiveEmployeeGroupByOutputType[P]>
        }
      >
    >


  export type InactiveEmployeeSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    employeeName?: boolean
    departmentId?: boolean
    inactiveReason?: boolean
    details?: boolean
    suspendedBy?: boolean
    suspendedAt?: boolean
    reactivatedAt?: boolean
    reactivatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inactiveEmployee"]>

  export type InactiveEmployeeSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    employeeName?: boolean
    departmentId?: boolean
    inactiveReason?: boolean
    details?: boolean
    suspendedBy?: boolean
    suspendedAt?: boolean
    reactivatedAt?: boolean
    reactivatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["inactiveEmployee"]>

  export type InactiveEmployeeSelectScalar = {
    id?: boolean
    employeeId?: boolean
    employeeName?: boolean
    departmentId?: boolean
    inactiveReason?: boolean
    details?: boolean
    suspendedBy?: boolean
    suspendedAt?: boolean
    reactivatedAt?: boolean
    reactivatedBy?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $InactiveEmployeePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "InactiveEmployee"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      employeeName: string
      departmentId: string | null
      inactiveReason: string
      details: string | null
      suspendedBy: string | null
      suspendedAt: Date
      reactivatedAt: Date | null
      reactivatedBy: string | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["inactiveEmployee"]>
    composites: {}
  }

  type InactiveEmployeeGetPayload<S extends boolean | null | undefined | InactiveEmployeeDefaultArgs> = $Result.GetResult<Prisma.$InactiveEmployeePayload, S>

  type InactiveEmployeeCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InactiveEmployeeFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InactiveEmployeeCountAggregateInputType | true
    }

  export interface InactiveEmployeeDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['InactiveEmployee'], meta: { name: 'InactiveEmployee' } }
    /**
     * Find zero or one InactiveEmployee that matches the filter.
     * @param {InactiveEmployeeFindUniqueArgs} args - Arguments to find a InactiveEmployee
     * @example
     * // Get one InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InactiveEmployeeFindUniqueArgs>(args: SelectSubset<T, InactiveEmployeeFindUniqueArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one InactiveEmployee that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InactiveEmployeeFindUniqueOrThrowArgs} args - Arguments to find a InactiveEmployee
     * @example
     * // Get one InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InactiveEmployeeFindUniqueOrThrowArgs>(args: SelectSubset<T, InactiveEmployeeFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first InactiveEmployee that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeFindFirstArgs} args - Arguments to find a InactiveEmployee
     * @example
     * // Get one InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InactiveEmployeeFindFirstArgs>(args?: SelectSubset<T, InactiveEmployeeFindFirstArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first InactiveEmployee that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeFindFirstOrThrowArgs} args - Arguments to find a InactiveEmployee
     * @example
     * // Get one InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InactiveEmployeeFindFirstOrThrowArgs>(args?: SelectSubset<T, InactiveEmployeeFindFirstOrThrowArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more InactiveEmployees that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all InactiveEmployees
     * const inactiveEmployees = await prisma.inactiveEmployee.findMany()
     * 
     * // Get first 10 InactiveEmployees
     * const inactiveEmployees = await prisma.inactiveEmployee.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const inactiveEmployeeWithIdOnly = await prisma.inactiveEmployee.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InactiveEmployeeFindManyArgs>(args?: SelectSubset<T, InactiveEmployeeFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a InactiveEmployee.
     * @param {InactiveEmployeeCreateArgs} args - Arguments to create a InactiveEmployee.
     * @example
     * // Create one InactiveEmployee
     * const InactiveEmployee = await prisma.inactiveEmployee.create({
     *   data: {
     *     // ... data to create a InactiveEmployee
     *   }
     * })
     * 
     */
    create<T extends InactiveEmployeeCreateArgs>(args: SelectSubset<T, InactiveEmployeeCreateArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many InactiveEmployees.
     * @param {InactiveEmployeeCreateManyArgs} args - Arguments to create many InactiveEmployees.
     * @example
     * // Create many InactiveEmployees
     * const inactiveEmployee = await prisma.inactiveEmployee.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InactiveEmployeeCreateManyArgs>(args?: SelectSubset<T, InactiveEmployeeCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many InactiveEmployees and returns the data saved in the database.
     * @param {InactiveEmployeeCreateManyAndReturnArgs} args - Arguments to create many InactiveEmployees.
     * @example
     * // Create many InactiveEmployees
     * const inactiveEmployee = await prisma.inactiveEmployee.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many InactiveEmployees and only return the `id`
     * const inactiveEmployeeWithIdOnly = await prisma.inactiveEmployee.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InactiveEmployeeCreateManyAndReturnArgs>(args?: SelectSubset<T, InactiveEmployeeCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a InactiveEmployee.
     * @param {InactiveEmployeeDeleteArgs} args - Arguments to delete one InactiveEmployee.
     * @example
     * // Delete one InactiveEmployee
     * const InactiveEmployee = await prisma.inactiveEmployee.delete({
     *   where: {
     *     // ... filter to delete one InactiveEmployee
     *   }
     * })
     * 
     */
    delete<T extends InactiveEmployeeDeleteArgs>(args: SelectSubset<T, InactiveEmployeeDeleteArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one InactiveEmployee.
     * @param {InactiveEmployeeUpdateArgs} args - Arguments to update one InactiveEmployee.
     * @example
     * // Update one InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InactiveEmployeeUpdateArgs>(args: SelectSubset<T, InactiveEmployeeUpdateArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more InactiveEmployees.
     * @param {InactiveEmployeeDeleteManyArgs} args - Arguments to filter InactiveEmployees to delete.
     * @example
     * // Delete a few InactiveEmployees
     * const { count } = await prisma.inactiveEmployee.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InactiveEmployeeDeleteManyArgs>(args?: SelectSubset<T, InactiveEmployeeDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more InactiveEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many InactiveEmployees
     * const inactiveEmployee = await prisma.inactiveEmployee.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InactiveEmployeeUpdateManyArgs>(args: SelectSubset<T, InactiveEmployeeUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one InactiveEmployee.
     * @param {InactiveEmployeeUpsertArgs} args - Arguments to update or create a InactiveEmployee.
     * @example
     * // Update or create a InactiveEmployee
     * const inactiveEmployee = await prisma.inactiveEmployee.upsert({
     *   create: {
     *     // ... data to create a InactiveEmployee
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the InactiveEmployee we want to update
     *   }
     * })
     */
    upsert<T extends InactiveEmployeeUpsertArgs>(args: SelectSubset<T, InactiveEmployeeUpsertArgs<ExtArgs>>): Prisma__InactiveEmployeeClient<$Result.GetResult<Prisma.$InactiveEmployeePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of InactiveEmployees.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeCountArgs} args - Arguments to filter InactiveEmployees to count.
     * @example
     * // Count the number of InactiveEmployees
     * const count = await prisma.inactiveEmployee.count({
     *   where: {
     *     // ... the filter for the InactiveEmployees we want to count
     *   }
     * })
    **/
    count<T extends InactiveEmployeeCountArgs>(
      args?: Subset<T, InactiveEmployeeCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InactiveEmployeeCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a InactiveEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InactiveEmployeeAggregateArgs>(args: Subset<T, InactiveEmployeeAggregateArgs>): Prisma.PrismaPromise<GetInactiveEmployeeAggregateType<T>>

    /**
     * Group by InactiveEmployee.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InactiveEmployeeGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InactiveEmployeeGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InactiveEmployeeGroupByArgs['orderBy'] }
        : { orderBy?: InactiveEmployeeGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InactiveEmployeeGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInactiveEmployeeGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the InactiveEmployee model
   */
  readonly fields: InactiveEmployeeFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for InactiveEmployee.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InactiveEmployeeClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the InactiveEmployee model
   */ 
  interface InactiveEmployeeFieldRefs {
    readonly id: FieldRef<"InactiveEmployee", 'String'>
    readonly employeeId: FieldRef<"InactiveEmployee", 'String'>
    readonly employeeName: FieldRef<"InactiveEmployee", 'String'>
    readonly departmentId: FieldRef<"InactiveEmployee", 'String'>
    readonly inactiveReason: FieldRef<"InactiveEmployee", 'String'>
    readonly details: FieldRef<"InactiveEmployee", 'String'>
    readonly suspendedBy: FieldRef<"InactiveEmployee", 'String'>
    readonly suspendedAt: FieldRef<"InactiveEmployee", 'DateTime'>
    readonly reactivatedAt: FieldRef<"InactiveEmployee", 'DateTime'>
    readonly reactivatedBy: FieldRef<"InactiveEmployee", 'String'>
    readonly notes: FieldRef<"InactiveEmployee", 'String'>
    readonly createdAt: FieldRef<"InactiveEmployee", 'DateTime'>
    readonly updatedAt: FieldRef<"InactiveEmployee", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * InactiveEmployee findUnique
   */
  export type InactiveEmployeeFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which InactiveEmployee to fetch.
     */
    where: InactiveEmployeeWhereUniqueInput
  }

  /**
   * InactiveEmployee findUniqueOrThrow
   */
  export type InactiveEmployeeFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which InactiveEmployee to fetch.
     */
    where: InactiveEmployeeWhereUniqueInput
  }

  /**
   * InactiveEmployee findFirst
   */
  export type InactiveEmployeeFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which InactiveEmployee to fetch.
     */
    where?: InactiveEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InactiveEmployees to fetch.
     */
    orderBy?: InactiveEmployeeOrderByWithRelationInput | InactiveEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InactiveEmployees.
     */
    cursor?: InactiveEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InactiveEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InactiveEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InactiveEmployees.
     */
    distinct?: InactiveEmployeeScalarFieldEnum | InactiveEmployeeScalarFieldEnum[]
  }

  /**
   * InactiveEmployee findFirstOrThrow
   */
  export type InactiveEmployeeFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which InactiveEmployee to fetch.
     */
    where?: InactiveEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InactiveEmployees to fetch.
     */
    orderBy?: InactiveEmployeeOrderByWithRelationInput | InactiveEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for InactiveEmployees.
     */
    cursor?: InactiveEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InactiveEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InactiveEmployees.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of InactiveEmployees.
     */
    distinct?: InactiveEmployeeScalarFieldEnum | InactiveEmployeeScalarFieldEnum[]
  }

  /**
   * InactiveEmployee findMany
   */
  export type InactiveEmployeeFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter, which InactiveEmployees to fetch.
     */
    where?: InactiveEmployeeWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of InactiveEmployees to fetch.
     */
    orderBy?: InactiveEmployeeOrderByWithRelationInput | InactiveEmployeeOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing InactiveEmployees.
     */
    cursor?: InactiveEmployeeWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` InactiveEmployees from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` InactiveEmployees.
     */
    skip?: number
    distinct?: InactiveEmployeeScalarFieldEnum | InactiveEmployeeScalarFieldEnum[]
  }

  /**
   * InactiveEmployee create
   */
  export type InactiveEmployeeCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * The data needed to create a InactiveEmployee.
     */
    data: XOR<InactiveEmployeeCreateInput, InactiveEmployeeUncheckedCreateInput>
  }

  /**
   * InactiveEmployee createMany
   */
  export type InactiveEmployeeCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many InactiveEmployees.
     */
    data: InactiveEmployeeCreateManyInput | InactiveEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InactiveEmployee createManyAndReturn
   */
  export type InactiveEmployeeCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many InactiveEmployees.
     */
    data: InactiveEmployeeCreateManyInput | InactiveEmployeeCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * InactiveEmployee update
   */
  export type InactiveEmployeeUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * The data needed to update a InactiveEmployee.
     */
    data: XOR<InactiveEmployeeUpdateInput, InactiveEmployeeUncheckedUpdateInput>
    /**
     * Choose, which InactiveEmployee to update.
     */
    where: InactiveEmployeeWhereUniqueInput
  }

  /**
   * InactiveEmployee updateMany
   */
  export type InactiveEmployeeUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update InactiveEmployees.
     */
    data: XOR<InactiveEmployeeUpdateManyMutationInput, InactiveEmployeeUncheckedUpdateManyInput>
    /**
     * Filter which InactiveEmployees to update
     */
    where?: InactiveEmployeeWhereInput
  }

  /**
   * InactiveEmployee upsert
   */
  export type InactiveEmployeeUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * The filter to search for the InactiveEmployee to update in case it exists.
     */
    where: InactiveEmployeeWhereUniqueInput
    /**
     * In case the InactiveEmployee found by the `where` argument doesn't exist, create a new InactiveEmployee with this data.
     */
    create: XOR<InactiveEmployeeCreateInput, InactiveEmployeeUncheckedCreateInput>
    /**
     * In case the InactiveEmployee was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InactiveEmployeeUpdateInput, InactiveEmployeeUncheckedUpdateInput>
  }

  /**
   * InactiveEmployee delete
   */
  export type InactiveEmployeeDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
    /**
     * Filter which InactiveEmployee to delete.
     */
    where: InactiveEmployeeWhereUniqueInput
  }

  /**
   * InactiveEmployee deleteMany
   */
  export type InactiveEmployeeDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which InactiveEmployees to delete
     */
    where?: InactiveEmployeeWhereInput
  }

  /**
   * InactiveEmployee without action
   */
  export type InactiveEmployeeDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the InactiveEmployee
     */
    select?: InactiveEmployeeSelect<ExtArgs> | null
  }


  /**
   * Model AuditLog
   */

  export type AggregateAuditLog = {
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  export type AuditLogMinAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    action: string | null
    entityType: string | null
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date | null
  }

  export type AuditLogCountAggregateOutputType = {
    id: number
    userId: number
    action: number
    entityType: number
    entityId: number
    oldValue: number
    newValue: number
    ipAddress: number
    userAgent: number
    createdAt: number
    _all: number
  }


  export type AuditLogMinAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogMaxAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
  }

  export type AuditLogCountAggregateInputType = {
    id?: true
    userId?: true
    action?: true
    entityType?: true
    entityId?: true
    oldValue?: true
    newValue?: true
    ipAddress?: true
    userAgent?: true
    createdAt?: true
    _all?: true
  }

  export type AuditLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLog to aggregate.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AuditLogs
    **/
    _count?: true | AuditLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AuditLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AuditLogMaxAggregateInputType
  }

  export type GetAuditLogAggregateType<T extends AuditLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAuditLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAuditLog[P]>
      : GetScalarType<T[P], AggregateAuditLog[P]>
  }




  export type AuditLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AuditLogWhereInput
    orderBy?: AuditLogOrderByWithAggregationInput | AuditLogOrderByWithAggregationInput[]
    by: AuditLogScalarFieldEnum[] | AuditLogScalarFieldEnum
    having?: AuditLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AuditLogCountAggregateInputType | true
    _min?: AuditLogMinAggregateInputType
    _max?: AuditLogMaxAggregateInputType
  }

  export type AuditLogGroupByOutputType = {
    id: string
    userId: string | null
    action: string
    entityType: string
    entityId: string | null
    oldValue: string | null
    newValue: string | null
    ipAddress: string | null
    userAgent: string | null
    createdAt: Date
    _count: AuditLogCountAggregateOutputType | null
    _min: AuditLogMinAggregateOutputType | null
    _max: AuditLogMaxAggregateOutputType | null
  }

  type GetAuditLogGroupByPayload<T extends AuditLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AuditLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AuditLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
            : GetScalarType<T[P], AuditLogGroupByOutputType[P]>
        }
      >
    >


  export type AuditLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }, ExtArgs["result"]["auditLog"]>

  export type AuditLogSelectScalar = {
    id?: boolean
    userId?: boolean
    action?: boolean
    entityType?: boolean
    entityId?: boolean
    oldValue?: boolean
    newValue?: boolean
    ipAddress?: boolean
    userAgent?: boolean
    createdAt?: boolean
  }

  export type AuditLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }
  export type AuditLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | AuditLog$UserArgs<ExtArgs>
  }

  export type $AuditLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AuditLog"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      action: string
      entityType: string
      entityId: string | null
      oldValue: string | null
      newValue: string | null
      ipAddress: string | null
      userAgent: string | null
      createdAt: Date
    }, ExtArgs["result"]["auditLog"]>
    composites: {}
  }

  type AuditLogGetPayload<S extends boolean | null | undefined | AuditLogDefaultArgs> = $Result.GetResult<Prisma.$AuditLogPayload, S>

  type AuditLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AuditLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AuditLogCountAggregateInputType | true
    }

  export interface AuditLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AuditLog'], meta: { name: 'AuditLog' } }
    /**
     * Find zero or one AuditLog that matches the filter.
     * @param {AuditLogFindUniqueArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AuditLogFindUniqueArgs>(args: SelectSubset<T, AuditLogFindUniqueArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AuditLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AuditLogFindUniqueOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AuditLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AuditLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AuditLogFindFirstArgs>(args?: SelectSubset<T, AuditLogFindFirstArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AuditLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindFirstOrThrowArgs} args - Arguments to find a AuditLog
     * @example
     * // Get one AuditLog
     * const auditLog = await prisma.auditLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AuditLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AuditLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AuditLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AuditLogs
     * const auditLogs = await prisma.auditLog.findMany()
     * 
     * // Get first 10 AuditLogs
     * const auditLogs = await prisma.auditLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AuditLogFindManyArgs>(args?: SelectSubset<T, AuditLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AuditLog.
     * @param {AuditLogCreateArgs} args - Arguments to create a AuditLog.
     * @example
     * // Create one AuditLog
     * const AuditLog = await prisma.auditLog.create({
     *   data: {
     *     // ... data to create a AuditLog
     *   }
     * })
     * 
     */
    create<T extends AuditLogCreateArgs>(args: SelectSubset<T, AuditLogCreateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AuditLogs.
     * @param {AuditLogCreateManyArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AuditLogCreateManyArgs>(args?: SelectSubset<T, AuditLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AuditLogs and returns the data saved in the database.
     * @param {AuditLogCreateManyAndReturnArgs} args - Arguments to create many AuditLogs.
     * @example
     * // Create many AuditLogs
     * const auditLog = await prisma.auditLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AuditLogs and only return the `id`
     * const auditLogWithIdOnly = await prisma.auditLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AuditLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AuditLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AuditLog.
     * @param {AuditLogDeleteArgs} args - Arguments to delete one AuditLog.
     * @example
     * // Delete one AuditLog
     * const AuditLog = await prisma.auditLog.delete({
     *   where: {
     *     // ... filter to delete one AuditLog
     *   }
     * })
     * 
     */
    delete<T extends AuditLogDeleteArgs>(args: SelectSubset<T, AuditLogDeleteArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AuditLog.
     * @param {AuditLogUpdateArgs} args - Arguments to update one AuditLog.
     * @example
     * // Update one AuditLog
     * const auditLog = await prisma.auditLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AuditLogUpdateArgs>(args: SelectSubset<T, AuditLogUpdateArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AuditLogs.
     * @param {AuditLogDeleteManyArgs} args - Arguments to filter AuditLogs to delete.
     * @example
     * // Delete a few AuditLogs
     * const { count } = await prisma.auditLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AuditLogDeleteManyArgs>(args?: SelectSubset<T, AuditLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AuditLogs
     * const auditLog = await prisma.auditLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AuditLogUpdateManyArgs>(args: SelectSubset<T, AuditLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AuditLog.
     * @param {AuditLogUpsertArgs} args - Arguments to update or create a AuditLog.
     * @example
     * // Update or create a AuditLog
     * const auditLog = await prisma.auditLog.upsert({
     *   create: {
     *     // ... data to create a AuditLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AuditLog we want to update
     *   }
     * })
     */
    upsert<T extends AuditLogUpsertArgs>(args: SelectSubset<T, AuditLogUpsertArgs<ExtArgs>>): Prisma__AuditLogClient<$Result.GetResult<Prisma.$AuditLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AuditLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogCountArgs} args - Arguments to filter AuditLogs to count.
     * @example
     * // Count the number of AuditLogs
     * const count = await prisma.auditLog.count({
     *   where: {
     *     // ... the filter for the AuditLogs we want to count
     *   }
     * })
    **/
    count<T extends AuditLogCountArgs>(
      args?: Subset<T, AuditLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AuditLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AuditLogAggregateArgs>(args: Subset<T, AuditLogAggregateArgs>): Prisma.PrismaPromise<GetAuditLogAggregateType<T>>

    /**
     * Group by AuditLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AuditLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AuditLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AuditLogGroupByArgs['orderBy'] }
        : { orderBy?: AuditLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AuditLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAuditLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AuditLog model
   */
  readonly fields: AuditLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AuditLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AuditLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends AuditLog$UserArgs<ExtArgs> = {}>(args?: Subset<T, AuditLog$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AuditLog model
   */ 
  interface AuditLogFieldRefs {
    readonly id: FieldRef<"AuditLog", 'String'>
    readonly userId: FieldRef<"AuditLog", 'String'>
    readonly action: FieldRef<"AuditLog", 'String'>
    readonly entityType: FieldRef<"AuditLog", 'String'>
    readonly entityId: FieldRef<"AuditLog", 'String'>
    readonly oldValue: FieldRef<"AuditLog", 'String'>
    readonly newValue: FieldRef<"AuditLog", 'String'>
    readonly ipAddress: FieldRef<"AuditLog", 'String'>
    readonly userAgent: FieldRef<"AuditLog", 'String'>
    readonly createdAt: FieldRef<"AuditLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AuditLog findUnique
   */
  export type AuditLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findUniqueOrThrow
   */
  export type AuditLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog findFirst
   */
  export type AuditLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findFirstOrThrow
   */
  export type AuditLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLog to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AuditLogs.
     */
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog findMany
   */
  export type AuditLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter, which AuditLogs to fetch.
     */
    where?: AuditLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AuditLogs to fetch.
     */
    orderBy?: AuditLogOrderByWithRelationInput | AuditLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AuditLogs.
     */
    cursor?: AuditLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AuditLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AuditLogs.
     */
    skip?: number
    distinct?: AuditLogScalarFieldEnum | AuditLogScalarFieldEnum[]
  }

  /**
   * AuditLog create
   */
  export type AuditLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AuditLog.
     */
    data: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
  }

  /**
   * AuditLog createMany
   */
  export type AuditLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AuditLog createManyAndReturn
   */
  export type AuditLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AuditLogs.
     */
    data: AuditLogCreateManyInput | AuditLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AuditLog update
   */
  export type AuditLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AuditLog.
     */
    data: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
    /**
     * Choose, which AuditLog to update.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog updateMany
   */
  export type AuditLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AuditLogs.
     */
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyInput>
    /**
     * Filter which AuditLogs to update
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog upsert
   */
  export type AuditLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AuditLog to update in case it exists.
     */
    where: AuditLogWhereUniqueInput
    /**
     * In case the AuditLog found by the `where` argument doesn't exist, create a new AuditLog with this data.
     */
    create: XOR<AuditLogCreateInput, AuditLogUncheckedCreateInput>
    /**
     * In case the AuditLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AuditLogUpdateInput, AuditLogUncheckedUpdateInput>
  }

  /**
   * AuditLog delete
   */
  export type AuditLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
    /**
     * Filter which AuditLog to delete.
     */
    where: AuditLogWhereUniqueInput
  }

  /**
   * AuditLog deleteMany
   */
  export type AuditLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AuditLogs to delete
     */
    where?: AuditLogWhereInput
  }

  /**
   * AuditLog.User
   */
  export type AuditLog$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * AuditLog without action
   */
  export type AuditLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AuditLog
     */
    select?: AuditLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AuditLogInclude<ExtArgs> | null
  }


  /**
   * Model AttendanceLog
   */

  export type AggregateAttendanceLog = {
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  export type AttendanceLogAvgAggregateOutputType = {
    temperature: number | null
  }

  export type AttendanceLogSumAggregateOutputType = {
    temperature: number | null
  }

  export type AttendanceLogMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    eventType: string | null
    timestamp: Date | null
    terminalId: string | null
    verifyMethod: string | null
    snapshot: string | null
    temperature: number | null
    maskDetected: boolean | null
    processed: boolean | null
    rawData: string | null
    createdAt: Date | null
  }

  export type AttendanceLogMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    eventType: string | null
    timestamp: Date | null
    terminalId: string | null
    verifyMethod: string | null
    snapshot: string | null
    temperature: number | null
    maskDetected: boolean | null
    processed: boolean | null
    rawData: string | null
    createdAt: Date | null
  }

  export type AttendanceLogCountAggregateOutputType = {
    id: number
    employeeId: number
    eventType: number
    timestamp: number
    terminalId: number
    verifyMethod: number
    snapshot: number
    temperature: number
    maskDetected: number
    processed: number
    rawData: number
    createdAt: number
    _all: number
  }


  export type AttendanceLogAvgAggregateInputType = {
    temperature?: true
  }

  export type AttendanceLogSumAggregateInputType = {
    temperature?: true
  }

  export type AttendanceLogMinAggregateInputType = {
    id?: true
    employeeId?: true
    eventType?: true
    timestamp?: true
    terminalId?: true
    verifyMethod?: true
    snapshot?: true
    temperature?: true
    maskDetected?: true
    processed?: true
    rawData?: true
    createdAt?: true
  }

  export type AttendanceLogMaxAggregateInputType = {
    id?: true
    employeeId?: true
    eventType?: true
    timestamp?: true
    terminalId?: true
    verifyMethod?: true
    snapshot?: true
    temperature?: true
    maskDetected?: true
    processed?: true
    rawData?: true
    createdAt?: true
  }

  export type AttendanceLogCountAggregateInputType = {
    id?: true
    employeeId?: true
    eventType?: true
    timestamp?: true
    terminalId?: true
    verifyMethod?: true
    snapshot?: true
    temperature?: true
    maskDetected?: true
    processed?: true
    rawData?: true
    createdAt?: true
    _all?: true
  }

  export type AttendanceLogAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLog to aggregate.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned AttendanceLogs
    **/
    _count?: true | AttendanceLogCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: AttendanceLogAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: AttendanceLogSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: AttendanceLogMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type GetAttendanceLogAggregateType<T extends AttendanceLogAggregateArgs> = {
        [P in keyof T & keyof AggregateAttendanceLog]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateAttendanceLog[P]>
      : GetScalarType<T[P], AggregateAttendanceLog[P]>
  }




  export type AttendanceLogGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithAggregationInput | AttendanceLogOrderByWithAggregationInput[]
    by: AttendanceLogScalarFieldEnum[] | AttendanceLogScalarFieldEnum
    having?: AttendanceLogScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: AttendanceLogCountAggregateInputType | true
    _avg?: AttendanceLogAvgAggregateInputType
    _sum?: AttendanceLogSumAggregateInputType
    _min?: AttendanceLogMinAggregateInputType
    _max?: AttendanceLogMaxAggregateInputType
  }

  export type AttendanceLogGroupByOutputType = {
    id: string
    employeeId: string
    eventType: string
    timestamp: Date
    terminalId: string | null
    verifyMethod: string | null
    snapshot: string | null
    temperature: number | null
    maskDetected: boolean | null
    processed: boolean
    rawData: string | null
    createdAt: Date
    _count: AttendanceLogCountAggregateOutputType | null
    _avg: AttendanceLogAvgAggregateOutputType | null
    _sum: AttendanceLogSumAggregateOutputType | null
    _min: AttendanceLogMinAggregateOutputType | null
    _max: AttendanceLogMaxAggregateOutputType | null
  }

  type GetAttendanceLogGroupByPayload<T extends AttendanceLogGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<AttendanceLogGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof AttendanceLogGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
            : GetScalarType<T[P], AttendanceLogGroupByOutputType[P]>
        }
      >
    >


  export type AttendanceLogSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    eventType?: boolean
    timestamp?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    snapshot?: boolean
    temperature?: boolean
    maskDetected?: boolean
    processed?: boolean
    rawData?: boolean
    createdAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | AttendanceLog$TerminalArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    eventType?: boolean
    timestamp?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    snapshot?: boolean
    temperature?: boolean
    maskDetected?: boolean
    processed?: boolean
    rawData?: boolean
    createdAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | AttendanceLog$TerminalArgs<ExtArgs>
  }, ExtArgs["result"]["attendanceLog"]>

  export type AttendanceLogSelectScalar = {
    id?: boolean
    employeeId?: boolean
    eventType?: boolean
    timestamp?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    snapshot?: boolean
    temperature?: boolean
    maskDetected?: boolean
    processed?: boolean
    rawData?: boolean
    createdAt?: boolean
  }

  export type AttendanceLogInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | AttendanceLog$TerminalArgs<ExtArgs>
  }
  export type AttendanceLogIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | AttendanceLog$TerminalArgs<ExtArgs>
  }

  export type $AttendanceLogPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "AttendanceLog"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
      Terminal: Prisma.$TerminalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      eventType: string
      timestamp: Date
      terminalId: string | null
      verifyMethod: string | null
      snapshot: string | null
      temperature: number | null
      maskDetected: boolean | null
      processed: boolean
      rawData: string | null
      createdAt: Date
    }, ExtArgs["result"]["attendanceLog"]>
    composites: {}
  }

  type AttendanceLogGetPayload<S extends boolean | null | undefined | AttendanceLogDefaultArgs> = $Result.GetResult<Prisma.$AttendanceLogPayload, S>

  type AttendanceLogCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<AttendanceLogFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: AttendanceLogCountAggregateInputType | true
    }

  export interface AttendanceLogDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['AttendanceLog'], meta: { name: 'AttendanceLog' } }
    /**
     * Find zero or one AttendanceLog that matches the filter.
     * @param {AttendanceLogFindUniqueArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends AttendanceLogFindUniqueArgs>(args: SelectSubset<T, AttendanceLogFindUniqueArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one AttendanceLog that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {AttendanceLogFindUniqueOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends AttendanceLogFindUniqueOrThrowArgs>(args: SelectSubset<T, AttendanceLogFindUniqueOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first AttendanceLog that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends AttendanceLogFindFirstArgs>(args?: SelectSubset<T, AttendanceLogFindFirstArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first AttendanceLog that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindFirstOrThrowArgs} args - Arguments to find a AttendanceLog
     * @example
     * // Get one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends AttendanceLogFindFirstOrThrowArgs>(args?: SelectSubset<T, AttendanceLogFindFirstOrThrowArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more AttendanceLogs that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany()
     * 
     * // Get first 10 AttendanceLogs
     * const attendanceLogs = await prisma.attendanceLog.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends AttendanceLogFindManyArgs>(args?: SelectSubset<T, AttendanceLogFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a AttendanceLog.
     * @param {AttendanceLogCreateArgs} args - Arguments to create a AttendanceLog.
     * @example
     * // Create one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.create({
     *   data: {
     *     // ... data to create a AttendanceLog
     *   }
     * })
     * 
     */
    create<T extends AttendanceLogCreateArgs>(args: SelectSubset<T, AttendanceLogCreateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many AttendanceLogs.
     * @param {AttendanceLogCreateManyArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends AttendanceLogCreateManyArgs>(args?: SelectSubset<T, AttendanceLogCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many AttendanceLogs and returns the data saved in the database.
     * @param {AttendanceLogCreateManyAndReturnArgs} args - Arguments to create many AttendanceLogs.
     * @example
     * // Create many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many AttendanceLogs and only return the `id`
     * const attendanceLogWithIdOnly = await prisma.attendanceLog.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends AttendanceLogCreateManyAndReturnArgs>(args?: SelectSubset<T, AttendanceLogCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a AttendanceLog.
     * @param {AttendanceLogDeleteArgs} args - Arguments to delete one AttendanceLog.
     * @example
     * // Delete one AttendanceLog
     * const AttendanceLog = await prisma.attendanceLog.delete({
     *   where: {
     *     // ... filter to delete one AttendanceLog
     *   }
     * })
     * 
     */
    delete<T extends AttendanceLogDeleteArgs>(args: SelectSubset<T, AttendanceLogDeleteArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one AttendanceLog.
     * @param {AttendanceLogUpdateArgs} args - Arguments to update one AttendanceLog.
     * @example
     * // Update one AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends AttendanceLogUpdateArgs>(args: SelectSubset<T, AttendanceLogUpdateArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more AttendanceLogs.
     * @param {AttendanceLogDeleteManyArgs} args - Arguments to filter AttendanceLogs to delete.
     * @example
     * // Delete a few AttendanceLogs
     * const { count } = await prisma.attendanceLog.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends AttendanceLogDeleteManyArgs>(args?: SelectSubset<T, AttendanceLogDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many AttendanceLogs
     * const attendanceLog = await prisma.attendanceLog.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends AttendanceLogUpdateManyArgs>(args: SelectSubset<T, AttendanceLogUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one AttendanceLog.
     * @param {AttendanceLogUpsertArgs} args - Arguments to update or create a AttendanceLog.
     * @example
     * // Update or create a AttendanceLog
     * const attendanceLog = await prisma.attendanceLog.upsert({
     *   create: {
     *     // ... data to create a AttendanceLog
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the AttendanceLog we want to update
     *   }
     * })
     */
    upsert<T extends AttendanceLogUpsertArgs>(args: SelectSubset<T, AttendanceLogUpsertArgs<ExtArgs>>): Prisma__AttendanceLogClient<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of AttendanceLogs.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogCountArgs} args - Arguments to filter AttendanceLogs to count.
     * @example
     * // Count the number of AttendanceLogs
     * const count = await prisma.attendanceLog.count({
     *   where: {
     *     // ... the filter for the AttendanceLogs we want to count
     *   }
     * })
    **/
    count<T extends AttendanceLogCountArgs>(
      args?: Subset<T, AttendanceLogCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], AttendanceLogCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends AttendanceLogAggregateArgs>(args: Subset<T, AttendanceLogAggregateArgs>): Prisma.PrismaPromise<GetAttendanceLogAggregateType<T>>

    /**
     * Group by AttendanceLog.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {AttendanceLogGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends AttendanceLogGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: AttendanceLogGroupByArgs['orderBy'] }
        : { orderBy?: AttendanceLogGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, AttendanceLogGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetAttendanceLogGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the AttendanceLog model
   */
  readonly fields: AttendanceLogFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for AttendanceLog.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__AttendanceLogClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Terminal<T extends AttendanceLog$TerminalArgs<ExtArgs> = {}>(args?: Subset<T, AttendanceLog$TerminalArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the AttendanceLog model
   */ 
  interface AttendanceLogFieldRefs {
    readonly id: FieldRef<"AttendanceLog", 'String'>
    readonly employeeId: FieldRef<"AttendanceLog", 'String'>
    readonly eventType: FieldRef<"AttendanceLog", 'String'>
    readonly timestamp: FieldRef<"AttendanceLog", 'DateTime'>
    readonly terminalId: FieldRef<"AttendanceLog", 'String'>
    readonly verifyMethod: FieldRef<"AttendanceLog", 'String'>
    readonly snapshot: FieldRef<"AttendanceLog", 'String'>
    readonly temperature: FieldRef<"AttendanceLog", 'Float'>
    readonly maskDetected: FieldRef<"AttendanceLog", 'Boolean'>
    readonly processed: FieldRef<"AttendanceLog", 'Boolean'>
    readonly rawData: FieldRef<"AttendanceLog", 'String'>
    readonly createdAt: FieldRef<"AttendanceLog", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * AttendanceLog findUnique
   */
  export type AttendanceLogFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findUniqueOrThrow
   */
  export type AttendanceLogFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog findFirst
   */
  export type AttendanceLogFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findFirstOrThrow
   */
  export type AttendanceLogFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLog to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of AttendanceLogs.
     */
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog findMany
   */
  export type AttendanceLogFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter, which AttendanceLogs to fetch.
     */
    where?: AttendanceLogWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of AttendanceLogs to fetch.
     */
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing AttendanceLogs.
     */
    cursor?: AttendanceLogWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` AttendanceLogs from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` AttendanceLogs.
     */
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * AttendanceLog create
   */
  export type AttendanceLogCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to create a AttendanceLog.
     */
    data: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
  }

  /**
   * AttendanceLog createMany
   */
  export type AttendanceLogCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * AttendanceLog createManyAndReturn
   */
  export type AttendanceLogCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many AttendanceLogs.
     */
    data: AttendanceLogCreateManyInput | AttendanceLogCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * AttendanceLog update
   */
  export type AttendanceLogUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The data needed to update a AttendanceLog.
     */
    data: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
    /**
     * Choose, which AttendanceLog to update.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog updateMany
   */
  export type AttendanceLogUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update AttendanceLogs.
     */
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyInput>
    /**
     * Filter which AttendanceLogs to update
     */
    where?: AttendanceLogWhereInput
  }

  /**
   * AttendanceLog upsert
   */
  export type AttendanceLogUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * The filter to search for the AttendanceLog to update in case it exists.
     */
    where: AttendanceLogWhereUniqueInput
    /**
     * In case the AttendanceLog found by the `where` argument doesn't exist, create a new AttendanceLog with this data.
     */
    create: XOR<AttendanceLogCreateInput, AttendanceLogUncheckedCreateInput>
    /**
     * In case the AttendanceLog was found with the provided `where` argument, update it with this data.
     */
    update: XOR<AttendanceLogUpdateInput, AttendanceLogUncheckedUpdateInput>
  }

  /**
   * AttendanceLog delete
   */
  export type AttendanceLogDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    /**
     * Filter which AttendanceLog to delete.
     */
    where: AttendanceLogWhereUniqueInput
  }

  /**
   * AttendanceLog deleteMany
   */
  export type AttendanceLogDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which AttendanceLogs to delete
     */
    where?: AttendanceLogWhereInput
  }

  /**
   * AttendanceLog.Terminal
   */
  export type AttendanceLog$TerminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    where?: TerminalWhereInput
  }

  /**
   * AttendanceLog without action
   */
  export type AttendanceLogDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
  }


  /**
   * Model BiometricData
   */

  export type AggregateBiometricData = {
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  export type BiometricDataAvgAggregateOutputType = {
    fingerNo: number | null
  }

  export type BiometricDataSumAggregateOutputType = {
    fingerNo: number | null
  }

  export type BiometricDataMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    data: string | null
    fingerNo: number | null
    enrolledAt: Date | null
  }

  export type BiometricDataMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    data: string | null
    fingerNo: number | null
    enrolledAt: Date | null
  }

  export type BiometricDataCountAggregateOutputType = {
    id: number
    employeeId: number
    type: number
    data: number
    fingerNo: number
    enrolledAt: number
    _all: number
  }


  export type BiometricDataAvgAggregateInputType = {
    fingerNo?: true
  }

  export type BiometricDataSumAggregateInputType = {
    fingerNo?: true
  }

  export type BiometricDataMinAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    data?: true
    fingerNo?: true
    enrolledAt?: true
  }

  export type BiometricDataMaxAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    data?: true
    fingerNo?: true
    enrolledAt?: true
  }

  export type BiometricDataCountAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    data?: true
    fingerNo?: true
    enrolledAt?: true
    _all?: true
  }

  export type BiometricDataAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to aggregate.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned BiometricData
    **/
    _count?: true | BiometricDataCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: BiometricDataAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: BiometricDataSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: BiometricDataMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: BiometricDataMaxAggregateInputType
  }

  export type GetBiometricDataAggregateType<T extends BiometricDataAggregateArgs> = {
        [P in keyof T & keyof AggregateBiometricData]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateBiometricData[P]>
      : GetScalarType<T[P], AggregateBiometricData[P]>
  }




  export type BiometricDataGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: BiometricDataWhereInput
    orderBy?: BiometricDataOrderByWithAggregationInput | BiometricDataOrderByWithAggregationInput[]
    by: BiometricDataScalarFieldEnum[] | BiometricDataScalarFieldEnum
    having?: BiometricDataScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: BiometricDataCountAggregateInputType | true
    _avg?: BiometricDataAvgAggregateInputType
    _sum?: BiometricDataSumAggregateInputType
    _min?: BiometricDataMinAggregateInputType
    _max?: BiometricDataMaxAggregateInputType
  }

  export type BiometricDataGroupByOutputType = {
    id: string
    employeeId: string
    type: string
    data: string | null
    fingerNo: number | null
    enrolledAt: Date
    _count: BiometricDataCountAggregateOutputType | null
    _avg: BiometricDataAvgAggregateOutputType | null
    _sum: BiometricDataSumAggregateOutputType | null
    _min: BiometricDataMinAggregateOutputType | null
    _max: BiometricDataMaxAggregateOutputType | null
  }

  type GetBiometricDataGroupByPayload<T extends BiometricDataGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<BiometricDataGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof BiometricDataGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
            : GetScalarType<T[P], BiometricDataGroupByOutputType[P]>
        }
      >
    >


  export type BiometricDataSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    data?: boolean
    fingerNo?: boolean
    enrolledAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    data?: boolean
    fingerNo?: boolean
    enrolledAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["biometricData"]>

  export type BiometricDataSelectScalar = {
    id?: boolean
    employeeId?: boolean
    type?: boolean
    data?: boolean
    fingerNo?: boolean
    enrolledAt?: boolean
  }

  export type BiometricDataInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type BiometricDataIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $BiometricDataPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "BiometricData"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      type: string
      data: string | null
      fingerNo: number | null
      enrolledAt: Date
    }, ExtArgs["result"]["biometricData"]>
    composites: {}
  }

  type BiometricDataGetPayload<S extends boolean | null | undefined | BiometricDataDefaultArgs> = $Result.GetResult<Prisma.$BiometricDataPayload, S>

  type BiometricDataCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<BiometricDataFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: BiometricDataCountAggregateInputType | true
    }

  export interface BiometricDataDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['BiometricData'], meta: { name: 'BiometricData' } }
    /**
     * Find zero or one BiometricData that matches the filter.
     * @param {BiometricDataFindUniqueArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends BiometricDataFindUniqueArgs>(args: SelectSubset<T, BiometricDataFindUniqueArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one BiometricData that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {BiometricDataFindUniqueOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends BiometricDataFindUniqueOrThrowArgs>(args: SelectSubset<T, BiometricDataFindUniqueOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends BiometricDataFindFirstArgs>(args?: SelectSubset<T, BiometricDataFindFirstArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first BiometricData that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindFirstOrThrowArgs} args - Arguments to find a BiometricData
     * @example
     * // Get one BiometricData
     * const biometricData = await prisma.biometricData.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends BiometricDataFindFirstOrThrowArgs>(args?: SelectSubset<T, BiometricDataFindFirstOrThrowArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more BiometricData that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all BiometricData
     * const biometricData = await prisma.biometricData.findMany()
     * 
     * // Get first 10 BiometricData
     * const biometricData = await prisma.biometricData.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends BiometricDataFindManyArgs>(args?: SelectSubset<T, BiometricDataFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a BiometricData.
     * @param {BiometricDataCreateArgs} args - Arguments to create a BiometricData.
     * @example
     * // Create one BiometricData
     * const BiometricData = await prisma.biometricData.create({
     *   data: {
     *     // ... data to create a BiometricData
     *   }
     * })
     * 
     */
    create<T extends BiometricDataCreateArgs>(args: SelectSubset<T, BiometricDataCreateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many BiometricData.
     * @param {BiometricDataCreateManyArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends BiometricDataCreateManyArgs>(args?: SelectSubset<T, BiometricDataCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many BiometricData and returns the data saved in the database.
     * @param {BiometricDataCreateManyAndReturnArgs} args - Arguments to create many BiometricData.
     * @example
     * // Create many BiometricData
     * const biometricData = await prisma.biometricData.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many BiometricData and only return the `id`
     * const biometricDataWithIdOnly = await prisma.biometricData.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends BiometricDataCreateManyAndReturnArgs>(args?: SelectSubset<T, BiometricDataCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a BiometricData.
     * @param {BiometricDataDeleteArgs} args - Arguments to delete one BiometricData.
     * @example
     * // Delete one BiometricData
     * const BiometricData = await prisma.biometricData.delete({
     *   where: {
     *     // ... filter to delete one BiometricData
     *   }
     * })
     * 
     */
    delete<T extends BiometricDataDeleteArgs>(args: SelectSubset<T, BiometricDataDeleteArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one BiometricData.
     * @param {BiometricDataUpdateArgs} args - Arguments to update one BiometricData.
     * @example
     * // Update one BiometricData
     * const biometricData = await prisma.biometricData.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends BiometricDataUpdateArgs>(args: SelectSubset<T, BiometricDataUpdateArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more BiometricData.
     * @param {BiometricDataDeleteManyArgs} args - Arguments to filter BiometricData to delete.
     * @example
     * // Delete a few BiometricData
     * const { count } = await prisma.biometricData.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends BiometricDataDeleteManyArgs>(args?: SelectSubset<T, BiometricDataDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many BiometricData
     * const biometricData = await prisma.biometricData.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends BiometricDataUpdateManyArgs>(args: SelectSubset<T, BiometricDataUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one BiometricData.
     * @param {BiometricDataUpsertArgs} args - Arguments to update or create a BiometricData.
     * @example
     * // Update or create a BiometricData
     * const biometricData = await prisma.biometricData.upsert({
     *   create: {
     *     // ... data to create a BiometricData
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the BiometricData we want to update
     *   }
     * })
     */
    upsert<T extends BiometricDataUpsertArgs>(args: SelectSubset<T, BiometricDataUpsertArgs<ExtArgs>>): Prisma__BiometricDataClient<$Result.GetResult<Prisma.$BiometricDataPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataCountArgs} args - Arguments to filter BiometricData to count.
     * @example
     * // Count the number of BiometricData
     * const count = await prisma.biometricData.count({
     *   where: {
     *     // ... the filter for the BiometricData we want to count
     *   }
     * })
    **/
    count<T extends BiometricDataCountArgs>(
      args?: Subset<T, BiometricDataCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], BiometricDataCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends BiometricDataAggregateArgs>(args: Subset<T, BiometricDataAggregateArgs>): Prisma.PrismaPromise<GetBiometricDataAggregateType<T>>

    /**
     * Group by BiometricData.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {BiometricDataGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends BiometricDataGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: BiometricDataGroupByArgs['orderBy'] }
        : { orderBy?: BiometricDataGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, BiometricDataGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetBiometricDataGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the BiometricData model
   */
  readonly fields: BiometricDataFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for BiometricData.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__BiometricDataClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the BiometricData model
   */ 
  interface BiometricDataFieldRefs {
    readonly id: FieldRef<"BiometricData", 'String'>
    readonly employeeId: FieldRef<"BiometricData", 'String'>
    readonly type: FieldRef<"BiometricData", 'String'>
    readonly data: FieldRef<"BiometricData", 'String'>
    readonly fingerNo: FieldRef<"BiometricData", 'Int'>
    readonly enrolledAt: FieldRef<"BiometricData", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * BiometricData findUnique
   */
  export type BiometricDataFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findUniqueOrThrow
   */
  export type BiometricDataFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData findFirst
   */
  export type BiometricDataFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findFirstOrThrow
   */
  export type BiometricDataFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of BiometricData.
     */
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData findMany
   */
  export type BiometricDataFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter, which BiometricData to fetch.
     */
    where?: BiometricDataWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of BiometricData to fetch.
     */
    orderBy?: BiometricDataOrderByWithRelationInput | BiometricDataOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing BiometricData.
     */
    cursor?: BiometricDataWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` BiometricData from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` BiometricData.
     */
    skip?: number
    distinct?: BiometricDataScalarFieldEnum | BiometricDataScalarFieldEnum[]
  }

  /**
   * BiometricData create
   */
  export type BiometricDataCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to create a BiometricData.
     */
    data: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
  }

  /**
   * BiometricData createMany
   */
  export type BiometricDataCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * BiometricData createManyAndReturn
   */
  export type BiometricDataCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many BiometricData.
     */
    data: BiometricDataCreateManyInput | BiometricDataCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * BiometricData update
   */
  export type BiometricDataUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The data needed to update a BiometricData.
     */
    data: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
    /**
     * Choose, which BiometricData to update.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData updateMany
   */
  export type BiometricDataUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update BiometricData.
     */
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyInput>
    /**
     * Filter which BiometricData to update
     */
    where?: BiometricDataWhereInput
  }

  /**
   * BiometricData upsert
   */
  export type BiometricDataUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * The filter to search for the BiometricData to update in case it exists.
     */
    where: BiometricDataWhereUniqueInput
    /**
     * In case the BiometricData found by the `where` argument doesn't exist, create a new BiometricData with this data.
     */
    create: XOR<BiometricDataCreateInput, BiometricDataUncheckedCreateInput>
    /**
     * In case the BiometricData was found with the provided `where` argument, update it with this data.
     */
    update: XOR<BiometricDataUpdateInput, BiometricDataUncheckedUpdateInput>
  }

  /**
   * BiometricData delete
   */
  export type BiometricDataDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
    /**
     * Filter which BiometricData to delete.
     */
    where: BiometricDataWhereUniqueInput
  }

  /**
   * BiometricData deleteMany
   */
  export type BiometricDataDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which BiometricData to delete
     */
    where?: BiometricDataWhereInput
  }

  /**
   * BiometricData without action
   */
  export type BiometricDataDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the BiometricData
     */
    select?: BiometricDataSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: BiometricDataInclude<ExtArgs> | null
  }


  /**
   * Model LeaveBalance
   */

  export type AggregateLeaveBalance = {
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  export type LeaveBalanceAvgAggregateOutputType = {
    year: number | null
    totalDays: number | null
    usedDays: number | null
    remainingDays: number | null
  }

  export type LeaveBalanceSumAggregateOutputType = {
    year: number | null
    totalDays: number | null
    usedDays: number | null
    remainingDays: number | null
  }

  export type LeaveBalanceMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveType: string | null
    year: number | null
    totalDays: number | null
    usedDays: number | null
    remainingDays: number | null
  }

  export type LeaveBalanceMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveType: string | null
    year: number | null
    totalDays: number | null
    usedDays: number | null
    remainingDays: number | null
  }

  export type LeaveBalanceCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    year: number
    totalDays: number
    usedDays: number
    remainingDays: number
    _all: number
  }


  export type LeaveBalanceAvgAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
    remainingDays?: true
  }

  export type LeaveBalanceSumAggregateInputType = {
    year?: true
    totalDays?: true
    usedDays?: true
    remainingDays?: true
  }

  export type LeaveBalanceMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    year?: true
    totalDays?: true
    usedDays?: true
    remainingDays?: true
  }

  export type LeaveBalanceMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    year?: true
    totalDays?: true
    usedDays?: true
    remainingDays?: true
  }

  export type LeaveBalanceCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    year?: true
    totalDays?: true
    usedDays?: true
    remainingDays?: true
    _all?: true
  }

  export type LeaveBalanceAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalance to aggregate.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveBalances
    **/
    _count?: true | LeaveBalanceCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveBalanceAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveBalanceSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveBalanceMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type GetLeaveBalanceAggregateType<T extends LeaveBalanceAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveBalance]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveBalance[P]>
      : GetScalarType<T[P], AggregateLeaveBalance[P]>
  }




  export type LeaveBalanceGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveBalanceWhereInput
    orderBy?: LeaveBalanceOrderByWithAggregationInput | LeaveBalanceOrderByWithAggregationInput[]
    by: LeaveBalanceScalarFieldEnum[] | LeaveBalanceScalarFieldEnum
    having?: LeaveBalanceScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveBalanceCountAggregateInputType | true
    _avg?: LeaveBalanceAvgAggregateInputType
    _sum?: LeaveBalanceSumAggregateInputType
    _min?: LeaveBalanceMinAggregateInputType
    _max?: LeaveBalanceMaxAggregateInputType
  }

  export type LeaveBalanceGroupByOutputType = {
    id: string
    employeeId: string
    leaveType: string
    year: number
    totalDays: number
    usedDays: number
    remainingDays: number
    _count: LeaveBalanceCountAggregateOutputType | null
    _avg: LeaveBalanceAvgAggregateOutputType | null
    _sum: LeaveBalanceSumAggregateOutputType | null
    _min: LeaveBalanceMinAggregateOutputType | null
    _max: LeaveBalanceMaxAggregateOutputType | null
  }

  type GetLeaveBalanceGroupByPayload<T extends LeaveBalanceGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveBalanceGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveBalanceGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveBalanceGroupByOutputType[P]>
        }
      >
    >


  export type LeaveBalanceSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    remainingDays?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    remainingDays?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveBalance"]>

  export type LeaveBalanceSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    year?: boolean
    totalDays?: boolean
    usedDays?: boolean
    remainingDays?: boolean
  }

  export type LeaveBalanceInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveBalanceIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeaveBalancePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveBalance"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      leaveType: string
      year: number
      totalDays: number
      usedDays: number
      remainingDays: number
    }, ExtArgs["result"]["leaveBalance"]>
    composites: {}
  }

  type LeaveBalanceGetPayload<S extends boolean | null | undefined | LeaveBalanceDefaultArgs> = $Result.GetResult<Prisma.$LeaveBalancePayload, S>

  type LeaveBalanceCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveBalanceFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveBalanceCountAggregateInputType | true
    }

  export interface LeaveBalanceDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveBalance'], meta: { name: 'LeaveBalance' } }
    /**
     * Find zero or one LeaveBalance that matches the filter.
     * @param {LeaveBalanceFindUniqueArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveBalanceFindUniqueArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveBalance that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveBalanceFindUniqueOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveBalanceFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveBalanceFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveBalanceFindFirstArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveBalance that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindFirstOrThrowArgs} args - Arguments to find a LeaveBalance
     * @example
     * // Get one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveBalanceFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveBalanceFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveBalances that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany()
     * 
     * // Get first 10 LeaveBalances
     * const leaveBalances = await prisma.leaveBalance.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveBalanceFindManyArgs>(args?: SelectSubset<T, LeaveBalanceFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveBalance.
     * @param {LeaveBalanceCreateArgs} args - Arguments to create a LeaveBalance.
     * @example
     * // Create one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.create({
     *   data: {
     *     // ... data to create a LeaveBalance
     *   }
     * })
     * 
     */
    create<T extends LeaveBalanceCreateArgs>(args: SelectSubset<T, LeaveBalanceCreateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveBalances.
     * @param {LeaveBalanceCreateManyArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveBalanceCreateManyArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveBalances and returns the data saved in the database.
     * @param {LeaveBalanceCreateManyAndReturnArgs} args - Arguments to create many LeaveBalances.
     * @example
     * // Create many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveBalances and only return the `id`
     * const leaveBalanceWithIdOnly = await prisma.leaveBalance.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveBalanceCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveBalanceCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveBalance.
     * @param {LeaveBalanceDeleteArgs} args - Arguments to delete one LeaveBalance.
     * @example
     * // Delete one LeaveBalance
     * const LeaveBalance = await prisma.leaveBalance.delete({
     *   where: {
     *     // ... filter to delete one LeaveBalance
     *   }
     * })
     * 
     */
    delete<T extends LeaveBalanceDeleteArgs>(args: SelectSubset<T, LeaveBalanceDeleteArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveBalance.
     * @param {LeaveBalanceUpdateArgs} args - Arguments to update one LeaveBalance.
     * @example
     * // Update one LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveBalanceUpdateArgs>(args: SelectSubset<T, LeaveBalanceUpdateArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveBalances.
     * @param {LeaveBalanceDeleteManyArgs} args - Arguments to filter LeaveBalances to delete.
     * @example
     * // Delete a few LeaveBalances
     * const { count } = await prisma.leaveBalance.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveBalanceDeleteManyArgs>(args?: SelectSubset<T, LeaveBalanceDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveBalances
     * const leaveBalance = await prisma.leaveBalance.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveBalanceUpdateManyArgs>(args: SelectSubset<T, LeaveBalanceUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveBalance.
     * @param {LeaveBalanceUpsertArgs} args - Arguments to update or create a LeaveBalance.
     * @example
     * // Update or create a LeaveBalance
     * const leaveBalance = await prisma.leaveBalance.upsert({
     *   create: {
     *     // ... data to create a LeaveBalance
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveBalance we want to update
     *   }
     * })
     */
    upsert<T extends LeaveBalanceUpsertArgs>(args: SelectSubset<T, LeaveBalanceUpsertArgs<ExtArgs>>): Prisma__LeaveBalanceClient<$Result.GetResult<Prisma.$LeaveBalancePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveBalances.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceCountArgs} args - Arguments to filter LeaveBalances to count.
     * @example
     * // Count the number of LeaveBalances
     * const count = await prisma.leaveBalance.count({
     *   where: {
     *     // ... the filter for the LeaveBalances we want to count
     *   }
     * })
    **/
    count<T extends LeaveBalanceCountArgs>(
      args?: Subset<T, LeaveBalanceCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveBalanceCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveBalanceAggregateArgs>(args: Subset<T, LeaveBalanceAggregateArgs>): Prisma.PrismaPromise<GetLeaveBalanceAggregateType<T>>

    /**
     * Group by LeaveBalance.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveBalanceGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveBalanceGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveBalanceGroupByArgs['orderBy'] }
        : { orderBy?: LeaveBalanceGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveBalanceGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveBalanceGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveBalance model
   */
  readonly fields: LeaveBalanceFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveBalance.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveBalanceClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveBalance model
   */ 
  interface LeaveBalanceFieldRefs {
    readonly id: FieldRef<"LeaveBalance", 'String'>
    readonly employeeId: FieldRef<"LeaveBalance", 'String'>
    readonly leaveType: FieldRef<"LeaveBalance", 'String'>
    readonly year: FieldRef<"LeaveBalance", 'Int'>
    readonly totalDays: FieldRef<"LeaveBalance", 'Int'>
    readonly usedDays: FieldRef<"LeaveBalance", 'Int'>
    readonly remainingDays: FieldRef<"LeaveBalance", 'Int'>
  }
    

  // Custom InputTypes
  /**
   * LeaveBalance findUnique
   */
  export type LeaveBalanceFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findUniqueOrThrow
   */
  export type LeaveBalanceFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance findFirst
   */
  export type LeaveBalanceFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findFirstOrThrow
   */
  export type LeaveBalanceFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalance to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveBalances.
     */
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance findMany
   */
  export type LeaveBalanceFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter, which LeaveBalances to fetch.
     */
    where?: LeaveBalanceWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveBalances to fetch.
     */
    orderBy?: LeaveBalanceOrderByWithRelationInput | LeaveBalanceOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveBalances.
     */
    cursor?: LeaveBalanceWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveBalances from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveBalances.
     */
    skip?: number
    distinct?: LeaveBalanceScalarFieldEnum | LeaveBalanceScalarFieldEnum[]
  }

  /**
   * LeaveBalance create
   */
  export type LeaveBalanceCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveBalance.
     */
    data: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
  }

  /**
   * LeaveBalance createMany
   */
  export type LeaveBalanceCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveBalance createManyAndReturn
   */
  export type LeaveBalanceCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveBalances.
     */
    data: LeaveBalanceCreateManyInput | LeaveBalanceCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveBalance update
   */
  export type LeaveBalanceUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveBalance.
     */
    data: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
    /**
     * Choose, which LeaveBalance to update.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance updateMany
   */
  export type LeaveBalanceUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveBalances.
     */
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyInput>
    /**
     * Filter which LeaveBalances to update
     */
    where?: LeaveBalanceWhereInput
  }

  /**
   * LeaveBalance upsert
   */
  export type LeaveBalanceUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveBalance to update in case it exists.
     */
    where: LeaveBalanceWhereUniqueInput
    /**
     * In case the LeaveBalance found by the `where` argument doesn't exist, create a new LeaveBalance with this data.
     */
    create: XOR<LeaveBalanceCreateInput, LeaveBalanceUncheckedCreateInput>
    /**
     * In case the LeaveBalance was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveBalanceUpdateInput, LeaveBalanceUncheckedUpdateInput>
  }

  /**
   * LeaveBalance delete
   */
  export type LeaveBalanceDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
    /**
     * Filter which LeaveBalance to delete.
     */
    where: LeaveBalanceWhereUniqueInput
  }

  /**
   * LeaveBalance deleteMany
   */
  export type LeaveBalanceDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveBalances to delete
     */
    where?: LeaveBalanceWhereInput
  }

  /**
   * LeaveBalance without action
   */
  export type LeaveBalanceDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveBalance
     */
    select?: LeaveBalanceSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveBalanceInclude<ExtArgs> | null
  }


  /**
   * Model LeaveRequest
   */

  export type AggregateLeaveRequest = {
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  export type LeaveRequestAvgAggregateOutputType = {
    totalDays: number | null
  }

  export type LeaveRequestSumAggregateOutputType = {
    totalDays: number | null
  }

  export type LeaveRequestMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    reason: string | null
    status: string | null
    approvedById: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    leaveType: string | null
    startDate: Date | null
    endDate: Date | null
    totalDays: number | null
    reason: string | null
    status: string | null
    approvedById: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type LeaveRequestCountAggregateOutputType = {
    id: number
    employeeId: number
    leaveType: number
    startDate: number
    endDate: number
    totalDays: number
    reason: number
    status: number
    approvedById: number
    approvedAt: number
    rejectionReason: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type LeaveRequestAvgAggregateInputType = {
    totalDays?: true
  }

  export type LeaveRequestSumAggregateInputType = {
    totalDays?: true
  }

  export type LeaveRequestMinAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestMaxAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
  }

  export type LeaveRequestCountAggregateInputType = {
    id?: true
    employeeId?: true
    leaveType?: true
    startDate?: true
    endDate?: true
    totalDays?: true
    reason?: true
    status?: true
    approvedById?: true
    approvedAt?: true
    rejectionReason?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type LeaveRequestAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequest to aggregate.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned LeaveRequests
    **/
    _count?: true | LeaveRequestCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: LeaveRequestAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: LeaveRequestSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: LeaveRequestMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type GetLeaveRequestAggregateType<T extends LeaveRequestAggregateArgs> = {
        [P in keyof T & keyof AggregateLeaveRequest]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateLeaveRequest[P]>
      : GetScalarType<T[P], AggregateLeaveRequest[P]>
  }




  export type LeaveRequestGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: LeaveRequestWhereInput
    orderBy?: LeaveRequestOrderByWithAggregationInput | LeaveRequestOrderByWithAggregationInput[]
    by: LeaveRequestScalarFieldEnum[] | LeaveRequestScalarFieldEnum
    having?: LeaveRequestScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: LeaveRequestCountAggregateInputType | true
    _avg?: LeaveRequestAvgAggregateInputType
    _sum?: LeaveRequestSumAggregateInputType
    _min?: LeaveRequestMinAggregateInputType
    _max?: LeaveRequestMaxAggregateInputType
  }

  export type LeaveRequestGroupByOutputType = {
    id: string
    employeeId: string
    leaveType: string
    startDate: Date
    endDate: Date
    totalDays: number
    reason: string | null
    status: string
    approvedById: string | null
    approvedAt: Date | null
    rejectionReason: string | null
    createdAt: Date
    updatedAt: Date
    _count: LeaveRequestCountAggregateOutputType | null
    _avg: LeaveRequestAvgAggregateOutputType | null
    _sum: LeaveRequestSumAggregateOutputType | null
    _min: LeaveRequestMinAggregateOutputType | null
    _max: LeaveRequestMaxAggregateOutputType | null
  }

  type GetLeaveRequestGroupByPayload<T extends LeaveRequestGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<LeaveRequestGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof LeaveRequestGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
            : GetScalarType<T[P], LeaveRequestGroupByOutputType[P]>
        }
      >
    >


  export type LeaveRequestSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | LeaveRequest$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | LeaveRequest$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["leaveRequest"]>

  export type LeaveRequestSelectScalar = {
    id?: boolean
    employeeId?: boolean
    leaveType?: boolean
    startDate?: boolean
    endDate?: boolean
    totalDays?: boolean
    reason?: boolean
    status?: boolean
    approvedById?: boolean
    approvedAt?: boolean
    rejectionReason?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type LeaveRequestInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LeaveRequest$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type LeaveRequestIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | LeaveRequest$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $LeaveRequestPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "LeaveRequest"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      Employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      leaveType: string
      startDate: Date
      endDate: Date
      totalDays: number
      reason: string | null
      status: string
      approvedById: string | null
      approvedAt: Date | null
      rejectionReason: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["leaveRequest"]>
    composites: {}
  }

  type LeaveRequestGetPayload<S extends boolean | null | undefined | LeaveRequestDefaultArgs> = $Result.GetResult<Prisma.$LeaveRequestPayload, S>

  type LeaveRequestCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<LeaveRequestFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: LeaveRequestCountAggregateInputType | true
    }

  export interface LeaveRequestDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['LeaveRequest'], meta: { name: 'LeaveRequest' } }
    /**
     * Find zero or one LeaveRequest that matches the filter.
     * @param {LeaveRequestFindUniqueArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends LeaveRequestFindUniqueArgs>(args: SelectSubset<T, LeaveRequestFindUniqueArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one LeaveRequest that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {LeaveRequestFindUniqueOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends LeaveRequestFindUniqueOrThrowArgs>(args: SelectSubset<T, LeaveRequestFindUniqueOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends LeaveRequestFindFirstArgs>(args?: SelectSubset<T, LeaveRequestFindFirstArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first LeaveRequest that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindFirstOrThrowArgs} args - Arguments to find a LeaveRequest
     * @example
     * // Get one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends LeaveRequestFindFirstOrThrowArgs>(args?: SelectSubset<T, LeaveRequestFindFirstOrThrowArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more LeaveRequests that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany()
     * 
     * // Get first 10 LeaveRequests
     * const leaveRequests = await prisma.leaveRequest.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends LeaveRequestFindManyArgs>(args?: SelectSubset<T, LeaveRequestFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a LeaveRequest.
     * @param {LeaveRequestCreateArgs} args - Arguments to create a LeaveRequest.
     * @example
     * // Create one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.create({
     *   data: {
     *     // ... data to create a LeaveRequest
     *   }
     * })
     * 
     */
    create<T extends LeaveRequestCreateArgs>(args: SelectSubset<T, LeaveRequestCreateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many LeaveRequests.
     * @param {LeaveRequestCreateManyArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends LeaveRequestCreateManyArgs>(args?: SelectSubset<T, LeaveRequestCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many LeaveRequests and returns the data saved in the database.
     * @param {LeaveRequestCreateManyAndReturnArgs} args - Arguments to create many LeaveRequests.
     * @example
     * // Create many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many LeaveRequests and only return the `id`
     * const leaveRequestWithIdOnly = await prisma.leaveRequest.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends LeaveRequestCreateManyAndReturnArgs>(args?: SelectSubset<T, LeaveRequestCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a LeaveRequest.
     * @param {LeaveRequestDeleteArgs} args - Arguments to delete one LeaveRequest.
     * @example
     * // Delete one LeaveRequest
     * const LeaveRequest = await prisma.leaveRequest.delete({
     *   where: {
     *     // ... filter to delete one LeaveRequest
     *   }
     * })
     * 
     */
    delete<T extends LeaveRequestDeleteArgs>(args: SelectSubset<T, LeaveRequestDeleteArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one LeaveRequest.
     * @param {LeaveRequestUpdateArgs} args - Arguments to update one LeaveRequest.
     * @example
     * // Update one LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends LeaveRequestUpdateArgs>(args: SelectSubset<T, LeaveRequestUpdateArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more LeaveRequests.
     * @param {LeaveRequestDeleteManyArgs} args - Arguments to filter LeaveRequests to delete.
     * @example
     * // Delete a few LeaveRequests
     * const { count } = await prisma.leaveRequest.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends LeaveRequestDeleteManyArgs>(args?: SelectSubset<T, LeaveRequestDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many LeaveRequests
     * const leaveRequest = await prisma.leaveRequest.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends LeaveRequestUpdateManyArgs>(args: SelectSubset<T, LeaveRequestUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one LeaveRequest.
     * @param {LeaveRequestUpsertArgs} args - Arguments to update or create a LeaveRequest.
     * @example
     * // Update or create a LeaveRequest
     * const leaveRequest = await prisma.leaveRequest.upsert({
     *   create: {
     *     // ... data to create a LeaveRequest
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the LeaveRequest we want to update
     *   }
     * })
     */
    upsert<T extends LeaveRequestUpsertArgs>(args: SelectSubset<T, LeaveRequestUpsertArgs<ExtArgs>>): Prisma__LeaveRequestClient<$Result.GetResult<Prisma.$LeaveRequestPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of LeaveRequests.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestCountArgs} args - Arguments to filter LeaveRequests to count.
     * @example
     * // Count the number of LeaveRequests
     * const count = await prisma.leaveRequest.count({
     *   where: {
     *     // ... the filter for the LeaveRequests we want to count
     *   }
     * })
    **/
    count<T extends LeaveRequestCountArgs>(
      args?: Subset<T, LeaveRequestCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], LeaveRequestCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends LeaveRequestAggregateArgs>(args: Subset<T, LeaveRequestAggregateArgs>): Prisma.PrismaPromise<GetLeaveRequestAggregateType<T>>

    /**
     * Group by LeaveRequest.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {LeaveRequestGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends LeaveRequestGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: LeaveRequestGroupByArgs['orderBy'] }
        : { orderBy?: LeaveRequestGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, LeaveRequestGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetLeaveRequestGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the LeaveRequest model
   */
  readonly fields: LeaveRequestFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for LeaveRequest.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__LeaveRequestClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends LeaveRequest$UserArgs<ExtArgs> = {}>(args?: Subset<T, LeaveRequest$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the LeaveRequest model
   */ 
  interface LeaveRequestFieldRefs {
    readonly id: FieldRef<"LeaveRequest", 'String'>
    readonly employeeId: FieldRef<"LeaveRequest", 'String'>
    readonly leaveType: FieldRef<"LeaveRequest", 'String'>
    readonly startDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly endDate: FieldRef<"LeaveRequest", 'DateTime'>
    readonly totalDays: FieldRef<"LeaveRequest", 'Int'>
    readonly reason: FieldRef<"LeaveRequest", 'String'>
    readonly status: FieldRef<"LeaveRequest", 'String'>
    readonly approvedById: FieldRef<"LeaveRequest", 'String'>
    readonly approvedAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly rejectionReason: FieldRef<"LeaveRequest", 'String'>
    readonly createdAt: FieldRef<"LeaveRequest", 'DateTime'>
    readonly updatedAt: FieldRef<"LeaveRequest", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * LeaveRequest findUnique
   */
  export type LeaveRequestFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findUniqueOrThrow
   */
  export type LeaveRequestFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest findFirst
   */
  export type LeaveRequestFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findFirstOrThrow
   */
  export type LeaveRequestFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequest to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of LeaveRequests.
     */
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest findMany
   */
  export type LeaveRequestFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter, which LeaveRequests to fetch.
     */
    where?: LeaveRequestWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of LeaveRequests to fetch.
     */
    orderBy?: LeaveRequestOrderByWithRelationInput | LeaveRequestOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing LeaveRequests.
     */
    cursor?: LeaveRequestWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` LeaveRequests from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` LeaveRequests.
     */
    skip?: number
    distinct?: LeaveRequestScalarFieldEnum | LeaveRequestScalarFieldEnum[]
  }

  /**
   * LeaveRequest create
   */
  export type LeaveRequestCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to create a LeaveRequest.
     */
    data: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
  }

  /**
   * LeaveRequest createMany
   */
  export type LeaveRequestCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * LeaveRequest createManyAndReturn
   */
  export type LeaveRequestCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many LeaveRequests.
     */
    data: LeaveRequestCreateManyInput | LeaveRequestCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * LeaveRequest update
   */
  export type LeaveRequestUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The data needed to update a LeaveRequest.
     */
    data: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
    /**
     * Choose, which LeaveRequest to update.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest updateMany
   */
  export type LeaveRequestUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update LeaveRequests.
     */
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyInput>
    /**
     * Filter which LeaveRequests to update
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest upsert
   */
  export type LeaveRequestUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * The filter to search for the LeaveRequest to update in case it exists.
     */
    where: LeaveRequestWhereUniqueInput
    /**
     * In case the LeaveRequest found by the `where` argument doesn't exist, create a new LeaveRequest with this data.
     */
    create: XOR<LeaveRequestCreateInput, LeaveRequestUncheckedCreateInput>
    /**
     * In case the LeaveRequest was found with the provided `where` argument, update it with this data.
     */
    update: XOR<LeaveRequestUpdateInput, LeaveRequestUncheckedUpdateInput>
  }

  /**
   * LeaveRequest delete
   */
  export type LeaveRequestDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
    /**
     * Filter which LeaveRequest to delete.
     */
    where: LeaveRequestWhereUniqueInput
  }

  /**
   * LeaveRequest deleteMany
   */
  export type LeaveRequestDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which LeaveRequests to delete
     */
    where?: LeaveRequestWhereInput
  }

  /**
   * LeaveRequest.User
   */
  export type LeaveRequest$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * LeaveRequest without action
   */
  export type LeaveRequestDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the LeaveRequest
     */
    select?: LeaveRequestSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: LeaveRequestInclude<ExtArgs> | null
  }


  /**
   * Model Notification
   */

  export type AggregateNotification = {
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  export type NotificationMinAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    data: string | null
    createdAt: Date | null
  }

  export type NotificationMaxAggregateOutputType = {
    id: string | null
    userId: string | null
    employeeId: string | null
    type: string | null
    title: string | null
    message: string | null
    isRead: boolean | null
    data: string | null
    createdAt: Date | null
  }

  export type NotificationCountAggregateOutputType = {
    id: number
    userId: number
    employeeId: number
    type: number
    title: number
    message: number
    isRead: number
    data: number
    createdAt: number
    _all: number
  }


  export type NotificationMinAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    data?: true
    createdAt?: true
  }

  export type NotificationMaxAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    data?: true
    createdAt?: true
  }

  export type NotificationCountAggregateInputType = {
    id?: true
    userId?: true
    employeeId?: true
    type?: true
    title?: true
    message?: true
    isRead?: true
    data?: true
    createdAt?: true
    _all?: true
  }

  export type NotificationAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notification to aggregate.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Notifications
    **/
    _count?: true | NotificationCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: NotificationMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: NotificationMaxAggregateInputType
  }

  export type GetNotificationAggregateType<T extends NotificationAggregateArgs> = {
        [P in keyof T & keyof AggregateNotification]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateNotification[P]>
      : GetScalarType<T[P], AggregateNotification[P]>
  }




  export type NotificationGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: NotificationWhereInput
    orderBy?: NotificationOrderByWithAggregationInput | NotificationOrderByWithAggregationInput[]
    by: NotificationScalarFieldEnum[] | NotificationScalarFieldEnum
    having?: NotificationScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: NotificationCountAggregateInputType | true
    _min?: NotificationMinAggregateInputType
    _max?: NotificationMaxAggregateInputType
  }

  export type NotificationGroupByOutputType = {
    id: string
    userId: string | null
    employeeId: string | null
    type: string
    title: string
    message: string
    isRead: boolean
    data: string | null
    createdAt: Date
    _count: NotificationCountAggregateOutputType | null
    _min: NotificationMinAggregateOutputType | null
    _max: NotificationMaxAggregateOutputType | null
  }

  type GetNotificationGroupByPayload<T extends NotificationGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<NotificationGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof NotificationGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], NotificationGroupByOutputType[P]>
            : GetScalarType<T[P], NotificationGroupByOutputType[P]>
        }
      >
    >


  export type NotificationSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    Employee?: boolean | Notification$EmployeeArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
    Employee?: boolean | Notification$EmployeeArgs<ExtArgs>
  }, ExtArgs["result"]["notification"]>

  export type NotificationSelectScalar = {
    id?: boolean
    userId?: boolean
    employeeId?: boolean
    type?: boolean
    title?: boolean
    message?: boolean
    isRead?: boolean
    data?: boolean
    createdAt?: boolean
  }

  export type NotificationInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | Notification$EmployeeArgs<ExtArgs>
  }
  export type NotificationIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | Notification$EmployeeArgs<ExtArgs>
  }

  export type $NotificationPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Notification"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      userId: string | null
      employeeId: string | null
      type: string
      title: string
      message: string
      isRead: boolean
      data: string | null
      createdAt: Date
    }, ExtArgs["result"]["notification"]>
    composites: {}
  }

  type NotificationGetPayload<S extends boolean | null | undefined | NotificationDefaultArgs> = $Result.GetResult<Prisma.$NotificationPayload, S>

  type NotificationCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<NotificationFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: NotificationCountAggregateInputType | true
    }

  export interface NotificationDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Notification'], meta: { name: 'Notification' } }
    /**
     * Find zero or one Notification that matches the filter.
     * @param {NotificationFindUniqueArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends NotificationFindUniqueArgs>(args: SelectSubset<T, NotificationFindUniqueArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Notification that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {NotificationFindUniqueOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends NotificationFindUniqueOrThrowArgs>(args: SelectSubset<T, NotificationFindUniqueOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Notification that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends NotificationFindFirstArgs>(args?: SelectSubset<T, NotificationFindFirstArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Notification that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindFirstOrThrowArgs} args - Arguments to find a Notification
     * @example
     * // Get one Notification
     * const notification = await prisma.notification.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends NotificationFindFirstOrThrowArgs>(args?: SelectSubset<T, NotificationFindFirstOrThrowArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Notifications that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Notifications
     * const notifications = await prisma.notification.findMany()
     * 
     * // Get first 10 Notifications
     * const notifications = await prisma.notification.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const notificationWithIdOnly = await prisma.notification.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends NotificationFindManyArgs>(args?: SelectSubset<T, NotificationFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Notification.
     * @param {NotificationCreateArgs} args - Arguments to create a Notification.
     * @example
     * // Create one Notification
     * const Notification = await prisma.notification.create({
     *   data: {
     *     // ... data to create a Notification
     *   }
     * })
     * 
     */
    create<T extends NotificationCreateArgs>(args: SelectSubset<T, NotificationCreateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Notifications.
     * @param {NotificationCreateManyArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends NotificationCreateManyArgs>(args?: SelectSubset<T, NotificationCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Notifications and returns the data saved in the database.
     * @param {NotificationCreateManyAndReturnArgs} args - Arguments to create many Notifications.
     * @example
     * // Create many Notifications
     * const notification = await prisma.notification.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Notifications and only return the `id`
     * const notificationWithIdOnly = await prisma.notification.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends NotificationCreateManyAndReturnArgs>(args?: SelectSubset<T, NotificationCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Notification.
     * @param {NotificationDeleteArgs} args - Arguments to delete one Notification.
     * @example
     * // Delete one Notification
     * const Notification = await prisma.notification.delete({
     *   where: {
     *     // ... filter to delete one Notification
     *   }
     * })
     * 
     */
    delete<T extends NotificationDeleteArgs>(args: SelectSubset<T, NotificationDeleteArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Notification.
     * @param {NotificationUpdateArgs} args - Arguments to update one Notification.
     * @example
     * // Update one Notification
     * const notification = await prisma.notification.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends NotificationUpdateArgs>(args: SelectSubset<T, NotificationUpdateArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Notifications.
     * @param {NotificationDeleteManyArgs} args - Arguments to filter Notifications to delete.
     * @example
     * // Delete a few Notifications
     * const { count } = await prisma.notification.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends NotificationDeleteManyArgs>(args?: SelectSubset<T, NotificationDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Notifications
     * const notification = await prisma.notification.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends NotificationUpdateManyArgs>(args: SelectSubset<T, NotificationUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Notification.
     * @param {NotificationUpsertArgs} args - Arguments to update or create a Notification.
     * @example
     * // Update or create a Notification
     * const notification = await prisma.notification.upsert({
     *   create: {
     *     // ... data to create a Notification
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Notification we want to update
     *   }
     * })
     */
    upsert<T extends NotificationUpsertArgs>(args: SelectSubset<T, NotificationUpsertArgs<ExtArgs>>): Prisma__NotificationClient<$Result.GetResult<Prisma.$NotificationPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Notifications.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationCountArgs} args - Arguments to filter Notifications to count.
     * @example
     * // Count the number of Notifications
     * const count = await prisma.notification.count({
     *   where: {
     *     // ... the filter for the Notifications we want to count
     *   }
     * })
    **/
    count<T extends NotificationCountArgs>(
      args?: Subset<T, NotificationCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], NotificationCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends NotificationAggregateArgs>(args: Subset<T, NotificationAggregateArgs>): Prisma.PrismaPromise<GetNotificationAggregateType<T>>

    /**
     * Group by Notification.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {NotificationGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends NotificationGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: NotificationGroupByArgs['orderBy'] }
        : { orderBy?: NotificationGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, NotificationGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetNotificationGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Notification model
   */
  readonly fields: NotificationFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Notification.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__NotificationClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends Notification$EmployeeArgs<ExtArgs> = {}>(args?: Subset<T, Notification$EmployeeArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Notification model
   */ 
  interface NotificationFieldRefs {
    readonly id: FieldRef<"Notification", 'String'>
    readonly userId: FieldRef<"Notification", 'String'>
    readonly employeeId: FieldRef<"Notification", 'String'>
    readonly type: FieldRef<"Notification", 'String'>
    readonly title: FieldRef<"Notification", 'String'>
    readonly message: FieldRef<"Notification", 'String'>
    readonly isRead: FieldRef<"Notification", 'Boolean'>
    readonly data: FieldRef<"Notification", 'String'>
    readonly createdAt: FieldRef<"Notification", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Notification findUnique
   */
  export type NotificationFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findUniqueOrThrow
   */
  export type NotificationFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification findFirst
   */
  export type NotificationFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findFirstOrThrow
   */
  export type NotificationFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notification to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Notifications.
     */
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification findMany
   */
  export type NotificationFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter, which Notifications to fetch.
     */
    where?: NotificationWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Notifications to fetch.
     */
    orderBy?: NotificationOrderByWithRelationInput | NotificationOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Notifications.
     */
    cursor?: NotificationWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Notifications from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Notifications.
     */
    skip?: number
    distinct?: NotificationScalarFieldEnum | NotificationScalarFieldEnum[]
  }

  /**
   * Notification create
   */
  export type NotificationCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to create a Notification.
     */
    data: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
  }

  /**
   * Notification createMany
   */
  export type NotificationCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Notification createManyAndReturn
   */
  export type NotificationCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Notifications.
     */
    data: NotificationCreateManyInput | NotificationCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Notification update
   */
  export type NotificationUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The data needed to update a Notification.
     */
    data: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
    /**
     * Choose, which Notification to update.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification updateMany
   */
  export type NotificationUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Notifications.
     */
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyInput>
    /**
     * Filter which Notifications to update
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification upsert
   */
  export type NotificationUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * The filter to search for the Notification to update in case it exists.
     */
    where: NotificationWhereUniqueInput
    /**
     * In case the Notification found by the `where` argument doesn't exist, create a new Notification with this data.
     */
    create: XOR<NotificationCreateInput, NotificationUncheckedCreateInput>
    /**
     * In case the Notification was found with the provided `where` argument, update it with this data.
     */
    update: XOR<NotificationUpdateInput, NotificationUncheckedUpdateInput>
  }

  /**
   * Notification delete
   */
  export type NotificationDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
    /**
     * Filter which Notification to delete.
     */
    where: NotificationWhereUniqueInput
  }

  /**
   * Notification deleteMany
   */
  export type NotificationDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Notifications to delete
     */
    where?: NotificationWhereInput
  }

  /**
   * Notification.Employee
   */
  export type Notification$EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Employee
     */
    select?: EmployeeSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeInclude<ExtArgs> | null
    where?: EmployeeWhereInput
  }

  /**
   * Notification without action
   */
  export type NotificationDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Notification
     */
    select?: NotificationSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: NotificationInclude<ExtArgs> | null
  }


  /**
   * Model Setting
   */

  export type AggregateSetting = {
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  export type SettingMinAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingMaxAggregateOutputType = {
    id: string | null
    key: string | null
    value: string | null
    description: string | null
    category: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type SettingCountAggregateOutputType = {
    id: number
    key: number
    value: number
    description: number
    category: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type SettingMinAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingMaxAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
  }

  export type SettingCountAggregateInputType = {
    id?: true
    key?: true
    value?: true
    description?: true
    category?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type SettingAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Setting to aggregate.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Settings
    **/
    _count?: true | SettingCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: SettingMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: SettingMaxAggregateInputType
  }

  export type GetSettingAggregateType<T extends SettingAggregateArgs> = {
        [P in keyof T & keyof AggregateSetting]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateSetting[P]>
      : GetScalarType<T[P], AggregateSetting[P]>
  }




  export type SettingGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: SettingWhereInput
    orderBy?: SettingOrderByWithAggregationInput | SettingOrderByWithAggregationInput[]
    by: SettingScalarFieldEnum[] | SettingScalarFieldEnum
    having?: SettingScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: SettingCountAggregateInputType | true
    _min?: SettingMinAggregateInputType
    _max?: SettingMaxAggregateInputType
  }

  export type SettingGroupByOutputType = {
    id: string
    key: string
    value: string
    description: string | null
    category: string
    createdAt: Date
    updatedAt: Date
    _count: SettingCountAggregateOutputType | null
    _min: SettingMinAggregateOutputType | null
    _max: SettingMaxAggregateOutputType | null
  }

  type GetSettingGroupByPayload<T extends SettingGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<SettingGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof SettingGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], SettingGroupByOutputType[P]>
            : GetScalarType<T[P], SettingGroupByOutputType[P]>
        }
      >
    >


  export type SettingSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["setting"]>

  export type SettingSelectScalar = {
    id?: boolean
    key?: boolean
    value?: boolean
    description?: boolean
    category?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }


  export type $SettingPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Setting"
    objects: {}
    scalars: $Extensions.GetPayloadResult<{
      id: string
      key: string
      value: string
      description: string | null
      category: string
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["setting"]>
    composites: {}
  }

  type SettingGetPayload<S extends boolean | null | undefined | SettingDefaultArgs> = $Result.GetResult<Prisma.$SettingPayload, S>

  type SettingCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<SettingFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: SettingCountAggregateInputType | true
    }

  export interface SettingDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Setting'], meta: { name: 'Setting' } }
    /**
     * Find zero or one Setting that matches the filter.
     * @param {SettingFindUniqueArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends SettingFindUniqueArgs>(args: SelectSubset<T, SettingFindUniqueArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Setting that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {SettingFindUniqueOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends SettingFindUniqueOrThrowArgs>(args: SelectSubset<T, SettingFindUniqueOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Setting that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends SettingFindFirstArgs>(args?: SelectSubset<T, SettingFindFirstArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Setting that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindFirstOrThrowArgs} args - Arguments to find a Setting
     * @example
     * // Get one Setting
     * const setting = await prisma.setting.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends SettingFindFirstOrThrowArgs>(args?: SelectSubset<T, SettingFindFirstOrThrowArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Settings that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Settings
     * const settings = await prisma.setting.findMany()
     * 
     * // Get first 10 Settings
     * const settings = await prisma.setting.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const settingWithIdOnly = await prisma.setting.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends SettingFindManyArgs>(args?: SelectSubset<T, SettingFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Setting.
     * @param {SettingCreateArgs} args - Arguments to create a Setting.
     * @example
     * // Create one Setting
     * const Setting = await prisma.setting.create({
     *   data: {
     *     // ... data to create a Setting
     *   }
     * })
     * 
     */
    create<T extends SettingCreateArgs>(args: SelectSubset<T, SettingCreateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Settings.
     * @param {SettingCreateManyArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends SettingCreateManyArgs>(args?: SelectSubset<T, SettingCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Settings and returns the data saved in the database.
     * @param {SettingCreateManyAndReturnArgs} args - Arguments to create many Settings.
     * @example
     * // Create many Settings
     * const setting = await prisma.setting.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Settings and only return the `id`
     * const settingWithIdOnly = await prisma.setting.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends SettingCreateManyAndReturnArgs>(args?: SelectSubset<T, SettingCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Setting.
     * @param {SettingDeleteArgs} args - Arguments to delete one Setting.
     * @example
     * // Delete one Setting
     * const Setting = await prisma.setting.delete({
     *   where: {
     *     // ... filter to delete one Setting
     *   }
     * })
     * 
     */
    delete<T extends SettingDeleteArgs>(args: SelectSubset<T, SettingDeleteArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Setting.
     * @param {SettingUpdateArgs} args - Arguments to update one Setting.
     * @example
     * // Update one Setting
     * const setting = await prisma.setting.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends SettingUpdateArgs>(args: SelectSubset<T, SettingUpdateArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Settings.
     * @param {SettingDeleteManyArgs} args - Arguments to filter Settings to delete.
     * @example
     * // Delete a few Settings
     * const { count } = await prisma.setting.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends SettingDeleteManyArgs>(args?: SelectSubset<T, SettingDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Settings
     * const setting = await prisma.setting.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends SettingUpdateManyArgs>(args: SelectSubset<T, SettingUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Setting.
     * @param {SettingUpsertArgs} args - Arguments to update or create a Setting.
     * @example
     * // Update or create a Setting
     * const setting = await prisma.setting.upsert({
     *   create: {
     *     // ... data to create a Setting
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Setting we want to update
     *   }
     * })
     */
    upsert<T extends SettingUpsertArgs>(args: SelectSubset<T, SettingUpsertArgs<ExtArgs>>): Prisma__SettingClient<$Result.GetResult<Prisma.$SettingPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Settings.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingCountArgs} args - Arguments to filter Settings to count.
     * @example
     * // Count the number of Settings
     * const count = await prisma.setting.count({
     *   where: {
     *     // ... the filter for the Settings we want to count
     *   }
     * })
    **/
    count<T extends SettingCountArgs>(
      args?: Subset<T, SettingCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], SettingCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends SettingAggregateArgs>(args: Subset<T, SettingAggregateArgs>): Prisma.PrismaPromise<GetSettingAggregateType<T>>

    /**
     * Group by Setting.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {SettingGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends SettingGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: SettingGroupByArgs['orderBy'] }
        : { orderBy?: SettingGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, SettingGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetSettingGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Setting model
   */
  readonly fields: SettingFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Setting.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__SettingClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Setting model
   */ 
  interface SettingFieldRefs {
    readonly id: FieldRef<"Setting", 'String'>
    readonly key: FieldRef<"Setting", 'String'>
    readonly value: FieldRef<"Setting", 'String'>
    readonly description: FieldRef<"Setting", 'String'>
    readonly category: FieldRef<"Setting", 'String'>
    readonly createdAt: FieldRef<"Setting", 'DateTime'>
    readonly updatedAt: FieldRef<"Setting", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Setting findUnique
   */
  export type SettingFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findUniqueOrThrow
   */
  export type SettingFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting findFirst
   */
  export type SettingFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findFirstOrThrow
   */
  export type SettingFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Setting to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Settings.
     */
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting findMany
   */
  export type SettingFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter, which Settings to fetch.
     */
    where?: SettingWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Settings to fetch.
     */
    orderBy?: SettingOrderByWithRelationInput | SettingOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Settings.
     */
    cursor?: SettingWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Settings from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Settings.
     */
    skip?: number
    distinct?: SettingScalarFieldEnum | SettingScalarFieldEnum[]
  }

  /**
   * Setting create
   */
  export type SettingCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to create a Setting.
     */
    data: XOR<SettingCreateInput, SettingUncheckedCreateInput>
  }

  /**
   * Setting createMany
   */
  export type SettingCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting createManyAndReturn
   */
  export type SettingCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Settings.
     */
    data: SettingCreateManyInput | SettingCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Setting update
   */
  export type SettingUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The data needed to update a Setting.
     */
    data: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
    /**
     * Choose, which Setting to update.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting updateMany
   */
  export type SettingUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Settings.
     */
    data: XOR<SettingUpdateManyMutationInput, SettingUncheckedUpdateManyInput>
    /**
     * Filter which Settings to update
     */
    where?: SettingWhereInput
  }

  /**
   * Setting upsert
   */
  export type SettingUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * The filter to search for the Setting to update in case it exists.
     */
    where: SettingWhereUniqueInput
    /**
     * In case the Setting found by the `where` argument doesn't exist, create a new Setting with this data.
     */
    create: XOR<SettingCreateInput, SettingUncheckedCreateInput>
    /**
     * In case the Setting was found with the provided `where` argument, update it with this data.
     */
    update: XOR<SettingUpdateInput, SettingUncheckedUpdateInput>
  }

  /**
   * Setting delete
   */
  export type SettingDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
    /**
     * Filter which Setting to delete.
     */
    where: SettingWhereUniqueInput
  }

  /**
   * Setting deleteMany
   */
  export type SettingDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Settings to delete
     */
    where?: SettingWhereInput
  }

  /**
   * Setting without action
   */
  export type SettingDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Setting
     */
    select?: SettingSelect<ExtArgs> | null
  }


  /**
   * Model ShiftAssignment
   */

  export type AggregateShiftAssignment = {
    _count: ShiftAssignmentCountAggregateOutputType | null
    _min: ShiftAssignmentMinAggregateOutputType | null
    _max: ShiftAssignmentMaxAggregateOutputType | null
  }

  export type ShiftAssignmentMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    assignedById: string | null
    createdAt: Date | null
  }

  export type ShiftAssignmentMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    shiftId: string | null
    startDate: Date | null
    endDate: Date | null
    isActive: boolean | null
    assignedById: string | null
    createdAt: Date | null
  }

  export type ShiftAssignmentCountAggregateOutputType = {
    id: number
    employeeId: number
    shiftId: number
    startDate: number
    endDate: number
    isActive: number
    assignedById: number
    createdAt: number
    _all: number
  }


  export type ShiftAssignmentMinAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assignedById?: true
    createdAt?: true
  }

  export type ShiftAssignmentMaxAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assignedById?: true
    createdAt?: true
  }

  export type ShiftAssignmentCountAggregateInputType = {
    id?: true
    employeeId?: true
    shiftId?: true
    startDate?: true
    endDate?: true
    isActive?: true
    assignedById?: true
    createdAt?: true
    _all?: true
  }

  export type ShiftAssignmentAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAssignment to aggregate.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned ShiftAssignments
    **/
    _count?: true | ShiftAssignmentCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: ShiftAssignmentMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: ShiftAssignmentMaxAggregateInputType
  }

  export type GetShiftAssignmentAggregateType<T extends ShiftAssignmentAggregateArgs> = {
        [P in keyof T & keyof AggregateShiftAssignment]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateShiftAssignment[P]>
      : GetScalarType<T[P], AggregateShiftAssignment[P]>
  }




  export type ShiftAssignmentGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: ShiftAssignmentWhereInput
    orderBy?: ShiftAssignmentOrderByWithAggregationInput | ShiftAssignmentOrderByWithAggregationInput[]
    by: ShiftAssignmentScalarFieldEnum[] | ShiftAssignmentScalarFieldEnum
    having?: ShiftAssignmentScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: ShiftAssignmentCountAggregateInputType | true
    _min?: ShiftAssignmentMinAggregateInputType
    _max?: ShiftAssignmentMaxAggregateInputType
  }

  export type ShiftAssignmentGroupByOutputType = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date
    endDate: Date | null
    isActive: boolean
    assignedById: string | null
    createdAt: Date
    _count: ShiftAssignmentCountAggregateOutputType | null
    _min: ShiftAssignmentMinAggregateOutputType | null
    _max: ShiftAssignmentMaxAggregateOutputType | null
  }

  type GetShiftAssignmentGroupByPayload<T extends ShiftAssignmentGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<ShiftAssignmentGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof ShiftAssignmentGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], ShiftAssignmentGroupByOutputType[P]>
            : GetScalarType<T[P], ShiftAssignmentGroupByOutputType[P]>
        }
      >
    >


  export type ShiftAssignmentSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assignedById?: boolean
    createdAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Shift?: boolean | ShiftDefaultArgs<ExtArgs>
    AssignedBy?: boolean | ShiftAssignment$AssignedByArgs<ExtArgs>
  }, ExtArgs["result"]["shiftAssignment"]>

  export type ShiftAssignmentSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assignedById?: boolean
    createdAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Shift?: boolean | ShiftDefaultArgs<ExtArgs>
    AssignedBy?: boolean | ShiftAssignment$AssignedByArgs<ExtArgs>
  }, ExtArgs["result"]["shiftAssignment"]>

  export type ShiftAssignmentSelectScalar = {
    id?: boolean
    employeeId?: boolean
    shiftId?: boolean
    startDate?: boolean
    endDate?: boolean
    isActive?: boolean
    assignedById?: boolean
    createdAt?: boolean
  }

  export type ShiftAssignmentInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Shift?: boolean | ShiftDefaultArgs<ExtArgs>
    AssignedBy?: boolean | ShiftAssignment$AssignedByArgs<ExtArgs>
  }
  export type ShiftAssignmentIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Shift?: boolean | ShiftDefaultArgs<ExtArgs>
    AssignedBy?: boolean | ShiftAssignment$AssignedByArgs<ExtArgs>
  }

  export type $ShiftAssignmentPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "ShiftAssignment"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
      Shift: Prisma.$ShiftPayload<ExtArgs>
      AssignedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      shiftId: string
      startDate: Date
      endDate: Date | null
      isActive: boolean
      assignedById: string | null
      createdAt: Date
    }, ExtArgs["result"]["shiftAssignment"]>
    composites: {}
  }

  type ShiftAssignmentGetPayload<S extends boolean | null | undefined | ShiftAssignmentDefaultArgs> = $Result.GetResult<Prisma.$ShiftAssignmentPayload, S>

  type ShiftAssignmentCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<ShiftAssignmentFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: ShiftAssignmentCountAggregateInputType | true
    }

  export interface ShiftAssignmentDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['ShiftAssignment'], meta: { name: 'ShiftAssignment' } }
    /**
     * Find zero or one ShiftAssignment that matches the filter.
     * @param {ShiftAssignmentFindUniqueArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends ShiftAssignmentFindUniqueArgs>(args: SelectSubset<T, ShiftAssignmentFindUniqueArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one ShiftAssignment that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {ShiftAssignmentFindUniqueOrThrowArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends ShiftAssignmentFindUniqueOrThrowArgs>(args: SelectSubset<T, ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first ShiftAssignment that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindFirstArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends ShiftAssignmentFindFirstArgs>(args?: SelectSubset<T, ShiftAssignmentFindFirstArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first ShiftAssignment that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindFirstOrThrowArgs} args - Arguments to find a ShiftAssignment
     * @example
     * // Get one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends ShiftAssignmentFindFirstOrThrowArgs>(args?: SelectSubset<T, ShiftAssignmentFindFirstOrThrowArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more ShiftAssignments that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all ShiftAssignments
     * const shiftAssignments = await prisma.shiftAssignment.findMany()
     * 
     * // Get first 10 ShiftAssignments
     * const shiftAssignments = await prisma.shiftAssignment.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const shiftAssignmentWithIdOnly = await prisma.shiftAssignment.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends ShiftAssignmentFindManyArgs>(args?: SelectSubset<T, ShiftAssignmentFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a ShiftAssignment.
     * @param {ShiftAssignmentCreateArgs} args - Arguments to create a ShiftAssignment.
     * @example
     * // Create one ShiftAssignment
     * const ShiftAssignment = await prisma.shiftAssignment.create({
     *   data: {
     *     // ... data to create a ShiftAssignment
     *   }
     * })
     * 
     */
    create<T extends ShiftAssignmentCreateArgs>(args: SelectSubset<T, ShiftAssignmentCreateArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many ShiftAssignments.
     * @param {ShiftAssignmentCreateManyArgs} args - Arguments to create many ShiftAssignments.
     * @example
     * // Create many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends ShiftAssignmentCreateManyArgs>(args?: SelectSubset<T, ShiftAssignmentCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many ShiftAssignments and returns the data saved in the database.
     * @param {ShiftAssignmentCreateManyAndReturnArgs} args - Arguments to create many ShiftAssignments.
     * @example
     * // Create many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many ShiftAssignments and only return the `id`
     * const shiftAssignmentWithIdOnly = await prisma.shiftAssignment.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends ShiftAssignmentCreateManyAndReturnArgs>(args?: SelectSubset<T, ShiftAssignmentCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a ShiftAssignment.
     * @param {ShiftAssignmentDeleteArgs} args - Arguments to delete one ShiftAssignment.
     * @example
     * // Delete one ShiftAssignment
     * const ShiftAssignment = await prisma.shiftAssignment.delete({
     *   where: {
     *     // ... filter to delete one ShiftAssignment
     *   }
     * })
     * 
     */
    delete<T extends ShiftAssignmentDeleteArgs>(args: SelectSubset<T, ShiftAssignmentDeleteArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one ShiftAssignment.
     * @param {ShiftAssignmentUpdateArgs} args - Arguments to update one ShiftAssignment.
     * @example
     * // Update one ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends ShiftAssignmentUpdateArgs>(args: SelectSubset<T, ShiftAssignmentUpdateArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more ShiftAssignments.
     * @param {ShiftAssignmentDeleteManyArgs} args - Arguments to filter ShiftAssignments to delete.
     * @example
     * // Delete a few ShiftAssignments
     * const { count } = await prisma.shiftAssignment.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends ShiftAssignmentDeleteManyArgs>(args?: SelectSubset<T, ShiftAssignmentDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more ShiftAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many ShiftAssignments
     * const shiftAssignment = await prisma.shiftAssignment.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends ShiftAssignmentUpdateManyArgs>(args: SelectSubset<T, ShiftAssignmentUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one ShiftAssignment.
     * @param {ShiftAssignmentUpsertArgs} args - Arguments to update or create a ShiftAssignment.
     * @example
     * // Update or create a ShiftAssignment
     * const shiftAssignment = await prisma.shiftAssignment.upsert({
     *   create: {
     *     // ... data to create a ShiftAssignment
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the ShiftAssignment we want to update
     *   }
     * })
     */
    upsert<T extends ShiftAssignmentUpsertArgs>(args: SelectSubset<T, ShiftAssignmentUpsertArgs<ExtArgs>>): Prisma__ShiftAssignmentClient<$Result.GetResult<Prisma.$ShiftAssignmentPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of ShiftAssignments.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentCountArgs} args - Arguments to filter ShiftAssignments to count.
     * @example
     * // Count the number of ShiftAssignments
     * const count = await prisma.shiftAssignment.count({
     *   where: {
     *     // ... the filter for the ShiftAssignments we want to count
     *   }
     * })
    **/
    count<T extends ShiftAssignmentCountArgs>(
      args?: Subset<T, ShiftAssignmentCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], ShiftAssignmentCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a ShiftAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends ShiftAssignmentAggregateArgs>(args: Subset<T, ShiftAssignmentAggregateArgs>): Prisma.PrismaPromise<GetShiftAssignmentAggregateType<T>>

    /**
     * Group by ShiftAssignment.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {ShiftAssignmentGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends ShiftAssignmentGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: ShiftAssignmentGroupByArgs['orderBy'] }
        : { orderBy?: ShiftAssignmentGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, ShiftAssignmentGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetShiftAssignmentGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the ShiftAssignment model
   */
  readonly fields: ShiftAssignmentFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for ShiftAssignment.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__ShiftAssignmentClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Shift<T extends ShiftDefaultArgs<ExtArgs> = {}>(args?: Subset<T, ShiftDefaultArgs<ExtArgs>>): Prisma__ShiftClient<$Result.GetResult<Prisma.$ShiftPayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    AssignedBy<T extends ShiftAssignment$AssignedByArgs<ExtArgs> = {}>(args?: Subset<T, ShiftAssignment$AssignedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the ShiftAssignment model
   */ 
  interface ShiftAssignmentFieldRefs {
    readonly id: FieldRef<"ShiftAssignment", 'String'>
    readonly employeeId: FieldRef<"ShiftAssignment", 'String'>
    readonly shiftId: FieldRef<"ShiftAssignment", 'String'>
    readonly startDate: FieldRef<"ShiftAssignment", 'DateTime'>
    readonly endDate: FieldRef<"ShiftAssignment", 'DateTime'>
    readonly isActive: FieldRef<"ShiftAssignment", 'Boolean'>
    readonly assignedById: FieldRef<"ShiftAssignment", 'String'>
    readonly createdAt: FieldRef<"ShiftAssignment", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * ShiftAssignment findUnique
   */
  export type ShiftAssignmentFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment findUniqueOrThrow
   */
  export type ShiftAssignmentFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment findFirst
   */
  export type ShiftAssignmentFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAssignments.
     */
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment findFirstOrThrow
   */
  export type ShiftAssignmentFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignment to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of ShiftAssignments.
     */
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment findMany
   */
  export type ShiftAssignmentFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter, which ShiftAssignments to fetch.
     */
    where?: ShiftAssignmentWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of ShiftAssignments to fetch.
     */
    orderBy?: ShiftAssignmentOrderByWithRelationInput | ShiftAssignmentOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing ShiftAssignments.
     */
    cursor?: ShiftAssignmentWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` ShiftAssignments from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` ShiftAssignments.
     */
    skip?: number
    distinct?: ShiftAssignmentScalarFieldEnum | ShiftAssignmentScalarFieldEnum[]
  }

  /**
   * ShiftAssignment create
   */
  export type ShiftAssignmentCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to create a ShiftAssignment.
     */
    data: XOR<ShiftAssignmentCreateInput, ShiftAssignmentUncheckedCreateInput>
  }

  /**
   * ShiftAssignment createMany
   */
  export type ShiftAssignmentCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many ShiftAssignments.
     */
    data: ShiftAssignmentCreateManyInput | ShiftAssignmentCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * ShiftAssignment createManyAndReturn
   */
  export type ShiftAssignmentCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many ShiftAssignments.
     */
    data: ShiftAssignmentCreateManyInput | ShiftAssignmentCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * ShiftAssignment update
   */
  export type ShiftAssignmentUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The data needed to update a ShiftAssignment.
     */
    data: XOR<ShiftAssignmentUpdateInput, ShiftAssignmentUncheckedUpdateInput>
    /**
     * Choose, which ShiftAssignment to update.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment updateMany
   */
  export type ShiftAssignmentUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update ShiftAssignments.
     */
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyInput>
    /**
     * Filter which ShiftAssignments to update
     */
    where?: ShiftAssignmentWhereInput
  }

  /**
   * ShiftAssignment upsert
   */
  export type ShiftAssignmentUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * The filter to search for the ShiftAssignment to update in case it exists.
     */
    where: ShiftAssignmentWhereUniqueInput
    /**
     * In case the ShiftAssignment found by the `where` argument doesn't exist, create a new ShiftAssignment with this data.
     */
    create: XOR<ShiftAssignmentCreateInput, ShiftAssignmentUncheckedCreateInput>
    /**
     * In case the ShiftAssignment was found with the provided `where` argument, update it with this data.
     */
    update: XOR<ShiftAssignmentUpdateInput, ShiftAssignmentUncheckedUpdateInput>
  }

  /**
   * ShiftAssignment delete
   */
  export type ShiftAssignmentDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
    /**
     * Filter which ShiftAssignment to delete.
     */
    where: ShiftAssignmentWhereUniqueInput
  }

  /**
   * ShiftAssignment deleteMany
   */
  export type ShiftAssignmentDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which ShiftAssignments to delete
     */
    where?: ShiftAssignmentWhereInput
  }

  /**
   * ShiftAssignment.AssignedBy
   */
  export type ShiftAssignment$AssignedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * ShiftAssignment without action
   */
  export type ShiftAssignmentDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the ShiftAssignment
     */
    select?: ShiftAssignmentSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: ShiftAssignmentInclude<ExtArgs> | null
  }


  /**
   * Model Terminal
   */

  export type AggregateTerminal = {
    _count: TerminalCountAggregateOutputType | null
    _avg: TerminalAvgAggregateOutputType | null
    _sum: TerminalSumAggregateOutputType | null
    _min: TerminalMinAggregateOutputType | null
    _max: TerminalMaxAggregateOutputType | null
  }

  export type TerminalAvgAggregateOutputType = {
    port: number | null
  }

  export type TerminalSumAggregateOutputType = {
    port: number | null
  }

  export type TerminalMinAggregateOutputType = {
    id: string | null
    name: string | null
    ipAddress: string | null
    port: number | null
    username: string | null
    password: string | null
    deviceType: string | null
    serialNumber: string | null
    firmwareVersion: string | null
    location: string | null
    isOnline: boolean | null
    lastSyncAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalMaxAggregateOutputType = {
    id: string | null
    name: string | null
    ipAddress: string | null
    port: number | null
    username: string | null
    password: string | null
    deviceType: string | null
    serialNumber: string | null
    firmwareVersion: string | null
    location: string | null
    isOnline: boolean | null
    lastSyncAt: Date | null
    isActive: boolean | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TerminalCountAggregateOutputType = {
    id: number
    name: number
    ipAddress: number
    port: number
    username: number
    password: number
    deviceType: number
    serialNumber: number
    firmwareVersion: number
    location: number
    isOnline: number
    lastSyncAt: number
    isActive: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TerminalAvgAggregateInputType = {
    port?: true
  }

  export type TerminalSumAggregateInputType = {
    port?: true
  }

  export type TerminalMinAggregateInputType = {
    id?: true
    name?: true
    ipAddress?: true
    port?: true
    username?: true
    password?: true
    deviceType?: true
    serialNumber?: true
    firmwareVersion?: true
    location?: true
    isOnline?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalMaxAggregateInputType = {
    id?: true
    name?: true
    ipAddress?: true
    port?: true
    username?: true
    password?: true
    deviceType?: true
    serialNumber?: true
    firmwareVersion?: true
    location?: true
    isOnline?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TerminalCountAggregateInputType = {
    id?: true
    name?: true
    ipAddress?: true
    port?: true
    username?: true
    password?: true
    deviceType?: true
    serialNumber?: true
    firmwareVersion?: true
    location?: true
    isOnline?: true
    lastSyncAt?: true
    isActive?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TerminalAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terminal to aggregate.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Terminals
    **/
    _count?: true | TerminalCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TerminalAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TerminalSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TerminalMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TerminalMaxAggregateInputType
  }

  export type GetTerminalAggregateType<T extends TerminalAggregateArgs> = {
        [P in keyof T & keyof AggregateTerminal]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTerminal[P]>
      : GetScalarType<T[P], AggregateTerminal[P]>
  }




  export type TerminalGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TerminalWhereInput
    orderBy?: TerminalOrderByWithAggregationInput | TerminalOrderByWithAggregationInput[]
    by: TerminalScalarFieldEnum[] | TerminalScalarFieldEnum
    having?: TerminalScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TerminalCountAggregateInputType | true
    _avg?: TerminalAvgAggregateInputType
    _sum?: TerminalSumAggregateInputType
    _min?: TerminalMinAggregateInputType
    _max?: TerminalMaxAggregateInputType
  }

  export type TerminalGroupByOutputType = {
    id: string
    name: string
    ipAddress: string
    port: number
    username: string
    password: string
    deviceType: string | null
    serialNumber: string | null
    firmwareVersion: string | null
    location: string | null
    isOnline: boolean
    lastSyncAt: Date | null
    isActive: boolean
    createdAt: Date
    updatedAt: Date
    _count: TerminalCountAggregateOutputType | null
    _avg: TerminalAvgAggregateOutputType | null
    _sum: TerminalSumAggregateOutputType | null
    _min: TerminalMinAggregateOutputType | null
    _max: TerminalMaxAggregateOutputType | null
  }

  type GetTerminalGroupByPayload<T extends TerminalGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TerminalGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TerminalGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TerminalGroupByOutputType[P]>
            : GetScalarType<T[P], TerminalGroupByOutputType[P]>
        }
      >
    >


  export type TerminalSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    firmwareVersion?: boolean
    location?: boolean
    isOnline?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    AttendanceLog?: boolean | Terminal$AttendanceLogArgs<ExtArgs>
    TimeEntry?: boolean | Terminal$TimeEntryArgs<ExtArgs>
    _count?: boolean | TerminalCountOutputTypeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["terminal"]>

  export type TerminalSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    firmwareVersion?: boolean
    location?: boolean
    isOnline?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }, ExtArgs["result"]["terminal"]>

  export type TerminalSelectScalar = {
    id?: boolean
    name?: boolean
    ipAddress?: boolean
    port?: boolean
    username?: boolean
    password?: boolean
    deviceType?: boolean
    serialNumber?: boolean
    firmwareVersion?: boolean
    location?: boolean
    isOnline?: boolean
    lastSyncAt?: boolean
    isActive?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TerminalInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    AttendanceLog?: boolean | Terminal$AttendanceLogArgs<ExtArgs>
    TimeEntry?: boolean | Terminal$TimeEntryArgs<ExtArgs>
    _count?: boolean | TerminalCountOutputTypeDefaultArgs<ExtArgs>
  }
  export type TerminalIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {}

  export type $TerminalPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Terminal"
    objects: {
      AttendanceLog: Prisma.$AttendanceLogPayload<ExtArgs>[]
      TimeEntry: Prisma.$TimeEntryPayload<ExtArgs>[]
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      name: string
      ipAddress: string
      port: number
      username: string
      password: string
      deviceType: string | null
      serialNumber: string | null
      firmwareVersion: string | null
      location: string | null
      isOnline: boolean
      lastSyncAt: Date | null
      isActive: boolean
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["terminal"]>
    composites: {}
  }

  type TerminalGetPayload<S extends boolean | null | undefined | TerminalDefaultArgs> = $Result.GetResult<Prisma.$TerminalPayload, S>

  type TerminalCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TerminalFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TerminalCountAggregateInputType | true
    }

  export interface TerminalDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Terminal'], meta: { name: 'Terminal' } }
    /**
     * Find zero or one Terminal that matches the filter.
     * @param {TerminalFindUniqueArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TerminalFindUniqueArgs>(args: SelectSubset<T, TerminalFindUniqueArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Terminal that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TerminalFindUniqueOrThrowArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TerminalFindUniqueOrThrowArgs>(args: SelectSubset<T, TerminalFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Terminal that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindFirstArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TerminalFindFirstArgs>(args?: SelectSubset<T, TerminalFindFirstArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Terminal that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindFirstOrThrowArgs} args - Arguments to find a Terminal
     * @example
     * // Get one Terminal
     * const terminal = await prisma.terminal.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TerminalFindFirstOrThrowArgs>(args?: SelectSubset<T, TerminalFindFirstOrThrowArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Terminals that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Terminals
     * const terminals = await prisma.terminal.findMany()
     * 
     * // Get first 10 Terminals
     * const terminals = await prisma.terminal.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const terminalWithIdOnly = await prisma.terminal.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TerminalFindManyArgs>(args?: SelectSubset<T, TerminalFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Terminal.
     * @param {TerminalCreateArgs} args - Arguments to create a Terminal.
     * @example
     * // Create one Terminal
     * const Terminal = await prisma.terminal.create({
     *   data: {
     *     // ... data to create a Terminal
     *   }
     * })
     * 
     */
    create<T extends TerminalCreateArgs>(args: SelectSubset<T, TerminalCreateArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Terminals.
     * @param {TerminalCreateManyArgs} args - Arguments to create many Terminals.
     * @example
     * // Create many Terminals
     * const terminal = await prisma.terminal.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TerminalCreateManyArgs>(args?: SelectSubset<T, TerminalCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Terminals and returns the data saved in the database.
     * @param {TerminalCreateManyAndReturnArgs} args - Arguments to create many Terminals.
     * @example
     * // Create many Terminals
     * const terminal = await prisma.terminal.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Terminals and only return the `id`
     * const terminalWithIdOnly = await prisma.terminal.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TerminalCreateManyAndReturnArgs>(args?: SelectSubset<T, TerminalCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Terminal.
     * @param {TerminalDeleteArgs} args - Arguments to delete one Terminal.
     * @example
     * // Delete one Terminal
     * const Terminal = await prisma.terminal.delete({
     *   where: {
     *     // ... filter to delete one Terminal
     *   }
     * })
     * 
     */
    delete<T extends TerminalDeleteArgs>(args: SelectSubset<T, TerminalDeleteArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Terminal.
     * @param {TerminalUpdateArgs} args - Arguments to update one Terminal.
     * @example
     * // Update one Terminal
     * const terminal = await prisma.terminal.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TerminalUpdateArgs>(args: SelectSubset<T, TerminalUpdateArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Terminals.
     * @param {TerminalDeleteManyArgs} args - Arguments to filter Terminals to delete.
     * @example
     * // Delete a few Terminals
     * const { count } = await prisma.terminal.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TerminalDeleteManyArgs>(args?: SelectSubset<T, TerminalDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Terminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Terminals
     * const terminal = await prisma.terminal.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TerminalUpdateManyArgs>(args: SelectSubset<T, TerminalUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Terminal.
     * @param {TerminalUpsertArgs} args - Arguments to update or create a Terminal.
     * @example
     * // Update or create a Terminal
     * const terminal = await prisma.terminal.upsert({
     *   create: {
     *     // ... data to create a Terminal
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Terminal we want to update
     *   }
     * })
     */
    upsert<T extends TerminalUpsertArgs>(args: SelectSubset<T, TerminalUpsertArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Terminals.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalCountArgs} args - Arguments to filter Terminals to count.
     * @example
     * // Count the number of Terminals
     * const count = await prisma.terminal.count({
     *   where: {
     *     // ... the filter for the Terminals we want to count
     *   }
     * })
    **/
    count<T extends TerminalCountArgs>(
      args?: Subset<T, TerminalCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TerminalCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Terminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TerminalAggregateArgs>(args: Subset<T, TerminalAggregateArgs>): Prisma.PrismaPromise<GetTerminalAggregateType<T>>

    /**
     * Group by Terminal.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TerminalGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TerminalGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TerminalGroupByArgs['orderBy'] }
        : { orderBy?: TerminalGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TerminalGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTerminalGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Terminal model
   */
  readonly fields: TerminalFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Terminal.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TerminalClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    AttendanceLog<T extends Terminal$AttendanceLogArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$AttendanceLogArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$AttendanceLogPayload<ExtArgs>, T, "findMany"> | Null>
    TimeEntry<T extends Terminal$TimeEntryArgs<ExtArgs> = {}>(args?: Subset<T, Terminal$TimeEntryArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany"> | Null>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Terminal model
   */ 
  interface TerminalFieldRefs {
    readonly id: FieldRef<"Terminal", 'String'>
    readonly name: FieldRef<"Terminal", 'String'>
    readonly ipAddress: FieldRef<"Terminal", 'String'>
    readonly port: FieldRef<"Terminal", 'Int'>
    readonly username: FieldRef<"Terminal", 'String'>
    readonly password: FieldRef<"Terminal", 'String'>
    readonly deviceType: FieldRef<"Terminal", 'String'>
    readonly serialNumber: FieldRef<"Terminal", 'String'>
    readonly firmwareVersion: FieldRef<"Terminal", 'String'>
    readonly location: FieldRef<"Terminal", 'String'>
    readonly isOnline: FieldRef<"Terminal", 'Boolean'>
    readonly lastSyncAt: FieldRef<"Terminal", 'DateTime'>
    readonly isActive: FieldRef<"Terminal", 'Boolean'>
    readonly createdAt: FieldRef<"Terminal", 'DateTime'>
    readonly updatedAt: FieldRef<"Terminal", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Terminal findUnique
   */
  export type TerminalFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal findUniqueOrThrow
   */
  export type TerminalFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal findFirst
   */
  export type TerminalFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminals.
     */
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal findFirstOrThrow
   */
  export type TerminalFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminal to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Terminals.
     */
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal findMany
   */
  export type TerminalFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter, which Terminals to fetch.
     */
    where?: TerminalWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Terminals to fetch.
     */
    orderBy?: TerminalOrderByWithRelationInput | TerminalOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Terminals.
     */
    cursor?: TerminalWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Terminals from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Terminals.
     */
    skip?: number
    distinct?: TerminalScalarFieldEnum | TerminalScalarFieldEnum[]
  }

  /**
   * Terminal create
   */
  export type TerminalCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The data needed to create a Terminal.
     */
    data: XOR<TerminalCreateInput, TerminalUncheckedCreateInput>
  }

  /**
   * Terminal createMany
   */
  export type TerminalCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Terminals.
     */
    data: TerminalCreateManyInput | TerminalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Terminal createManyAndReturn
   */
  export type TerminalCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Terminals.
     */
    data: TerminalCreateManyInput | TerminalCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Terminal update
   */
  export type TerminalUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The data needed to update a Terminal.
     */
    data: XOR<TerminalUpdateInput, TerminalUncheckedUpdateInput>
    /**
     * Choose, which Terminal to update.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal updateMany
   */
  export type TerminalUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Terminals.
     */
    data: XOR<TerminalUpdateManyMutationInput, TerminalUncheckedUpdateManyInput>
    /**
     * Filter which Terminals to update
     */
    where?: TerminalWhereInput
  }

  /**
   * Terminal upsert
   */
  export type TerminalUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * The filter to search for the Terminal to update in case it exists.
     */
    where: TerminalWhereUniqueInput
    /**
     * In case the Terminal found by the `where` argument doesn't exist, create a new Terminal with this data.
     */
    create: XOR<TerminalCreateInput, TerminalUncheckedCreateInput>
    /**
     * In case the Terminal was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TerminalUpdateInput, TerminalUncheckedUpdateInput>
  }

  /**
   * Terminal delete
   */
  export type TerminalDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    /**
     * Filter which Terminal to delete.
     */
    where: TerminalWhereUniqueInput
  }

  /**
   * Terminal deleteMany
   */
  export type TerminalDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Terminals to delete
     */
    where?: TerminalWhereInput
  }

  /**
   * Terminal.AttendanceLog
   */
  export type Terminal$AttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the AttendanceLog
     */
    select?: AttendanceLogSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: AttendanceLogInclude<ExtArgs> | null
    where?: AttendanceLogWhereInput
    orderBy?: AttendanceLogOrderByWithRelationInput | AttendanceLogOrderByWithRelationInput[]
    cursor?: AttendanceLogWhereUniqueInput
    take?: number
    skip?: number
    distinct?: AttendanceLogScalarFieldEnum | AttendanceLogScalarFieldEnum[]
  }

  /**
   * Terminal.TimeEntry
   */
  export type Terminal$TimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    cursor?: TimeEntryWhereUniqueInput
    take?: number
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * Terminal without action
   */
  export type TerminalDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
  }


  /**
   * Model TimeEntry
   */

  export type AggregateTimeEntry = {
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  export type TimeEntryAvgAggregateOutputType = {
    totalHours: number | null
    regularHours: number | null
    overtimeHours: number | null
    breakMinutes: number | null
  }

  export type TimeEntrySumAggregateOutputType = {
    totalHours: number | null
    regularHours: number | null
    overtimeHours: number | null
    breakMinutes: number | null
  }

  export type TimeEntryMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    clockIn: Date | null
    clockOut: Date | null
    breakStart: Date | null
    breakEnd: Date | null
    totalHours: number | null
    regularHours: number | null
    overtimeHours: number | null
    breakMinutes: number | null
    status: string | null
    location: string | null
    terminalId: string | null
    verifyMethod: string | null
    clockInPhoto: string | null
    clockOutPhoto: string | null
    notes: string | null
    isManualEntry: boolean | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    clockIn: Date | null
    clockOut: Date | null
    breakStart: Date | null
    breakEnd: Date | null
    totalHours: number | null
    regularHours: number | null
    overtimeHours: number | null
    breakMinutes: number | null
    status: string | null
    location: string | null
    terminalId: string | null
    verifyMethod: string | null
    clockInPhoto: string | null
    clockOutPhoto: string | null
    notes: string | null
    isManualEntry: boolean | null
    approvedById: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type TimeEntryCountAggregateOutputType = {
    id: number
    employeeId: number
    clockIn: number
    clockOut: number
    breakStart: number
    breakEnd: number
    totalHours: number
    regularHours: number
    overtimeHours: number
    breakMinutes: number
    status: number
    location: number
    terminalId: number
    verifyMethod: number
    clockInPhoto: number
    clockOutPhoto: number
    notes: number
    isManualEntry: number
    approvedById: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type TimeEntryAvgAggregateInputType = {
    totalHours?: true
    regularHours?: true
    overtimeHours?: true
    breakMinutes?: true
  }

  export type TimeEntrySumAggregateInputType = {
    totalHours?: true
    regularHours?: true
    overtimeHours?: true
    breakMinutes?: true
  }

  export type TimeEntryMinAggregateInputType = {
    id?: true
    employeeId?: true
    clockIn?: true
    clockOut?: true
    breakStart?: true
    breakEnd?: true
    totalHours?: true
    regularHours?: true
    overtimeHours?: true
    breakMinutes?: true
    status?: true
    location?: true
    terminalId?: true
    verifyMethod?: true
    clockInPhoto?: true
    clockOutPhoto?: true
    notes?: true
    isManualEntry?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryMaxAggregateInputType = {
    id?: true
    employeeId?: true
    clockIn?: true
    clockOut?: true
    breakStart?: true
    breakEnd?: true
    totalHours?: true
    regularHours?: true
    overtimeHours?: true
    breakMinutes?: true
    status?: true
    location?: true
    terminalId?: true
    verifyMethod?: true
    clockInPhoto?: true
    clockOutPhoto?: true
    notes?: true
    isManualEntry?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
  }

  export type TimeEntryCountAggregateInputType = {
    id?: true
    employeeId?: true
    clockIn?: true
    clockOut?: true
    breakStart?: true
    breakEnd?: true
    totalHours?: true
    regularHours?: true
    overtimeHours?: true
    breakMinutes?: true
    status?: true
    location?: true
    terminalId?: true
    verifyMethod?: true
    clockInPhoto?: true
    clockOutPhoto?: true
    notes?: true
    isManualEntry?: true
    approvedById?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type TimeEntryAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntry to aggregate.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned TimeEntries
    **/
    _count?: true | TimeEntryCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: TimeEntryAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: TimeEntrySumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: TimeEntryMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: TimeEntryMaxAggregateInputType
  }

  export type GetTimeEntryAggregateType<T extends TimeEntryAggregateArgs> = {
        [P in keyof T & keyof AggregateTimeEntry]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateTimeEntry[P]>
      : GetScalarType<T[P], AggregateTimeEntry[P]>
  }




  export type TimeEntryGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: TimeEntryWhereInput
    orderBy?: TimeEntryOrderByWithAggregationInput | TimeEntryOrderByWithAggregationInput[]
    by: TimeEntryScalarFieldEnum[] | TimeEntryScalarFieldEnum
    having?: TimeEntryScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: TimeEntryCountAggregateInputType | true
    _avg?: TimeEntryAvgAggregateInputType
    _sum?: TimeEntrySumAggregateInputType
    _min?: TimeEntryMinAggregateInputType
    _max?: TimeEntryMaxAggregateInputType
  }

  export type TimeEntryGroupByOutputType = {
    id: string
    employeeId: string
    clockIn: Date
    clockOut: Date | null
    breakStart: Date | null
    breakEnd: Date | null
    totalHours: number | null
    regularHours: number | null
    overtimeHours: number | null
    breakMinutes: number | null
    status: string
    location: string | null
    terminalId: string | null
    verifyMethod: string | null
    clockInPhoto: string | null
    clockOutPhoto: string | null
    notes: string | null
    isManualEntry: boolean
    approvedById: string | null
    createdAt: Date
    updatedAt: Date
    _count: TimeEntryCountAggregateOutputType | null
    _avg: TimeEntryAvgAggregateOutputType | null
    _sum: TimeEntrySumAggregateOutputType | null
    _min: TimeEntryMinAggregateOutputType | null
    _max: TimeEntryMaxAggregateOutputType | null
  }

  type GetTimeEntryGroupByPayload<T extends TimeEntryGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<TimeEntryGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof TimeEntryGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
            : GetScalarType<T[P], TimeEntryGroupByOutputType[P]>
        }
      >
    >


  export type TimeEntrySelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    clockIn?: boolean
    clockOut?: boolean
    breakStart?: boolean
    breakEnd?: boolean
    totalHours?: boolean
    regularHours?: boolean
    overtimeHours?: boolean
    breakMinutes?: boolean
    status?: boolean
    location?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    clockInPhoto?: boolean
    clockOutPhoto?: boolean
    notes?: boolean
    isManualEntry?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | TimeEntry$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | TimeEntry$TerminalArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    clockIn?: boolean
    clockOut?: boolean
    breakStart?: boolean
    breakEnd?: boolean
    totalHours?: boolean
    regularHours?: boolean
    overtimeHours?: boolean
    breakMinutes?: boolean
    status?: boolean
    location?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    clockInPhoto?: boolean
    clockOutPhoto?: boolean
    notes?: boolean
    isManualEntry?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    User?: boolean | TimeEntry$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | TimeEntry$TerminalArgs<ExtArgs>
  }, ExtArgs["result"]["timeEntry"]>

  export type TimeEntrySelectScalar = {
    id?: boolean
    employeeId?: boolean
    clockIn?: boolean
    clockOut?: boolean
    breakStart?: boolean
    breakEnd?: boolean
    totalHours?: boolean
    regularHours?: boolean
    overtimeHours?: boolean
    breakMinutes?: boolean
    status?: boolean
    location?: boolean
    terminalId?: boolean
    verifyMethod?: boolean
    clockInPhoto?: boolean
    clockOutPhoto?: boolean
    notes?: boolean
    isManualEntry?: boolean
    approvedById?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type TimeEntryInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | TimeEntry$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | TimeEntry$TerminalArgs<ExtArgs>
  }
  export type TimeEntryIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    User?: boolean | TimeEntry$UserArgs<ExtArgs>
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    Terminal?: boolean | TimeEntry$TerminalArgs<ExtArgs>
  }

  export type $TimeEntryPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "TimeEntry"
    objects: {
      User: Prisma.$UserPayload<ExtArgs> | null
      Employee: Prisma.$EmployeePayload<ExtArgs>
      Terminal: Prisma.$TerminalPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      clockIn: Date
      clockOut: Date | null
      breakStart: Date | null
      breakEnd: Date | null
      totalHours: number | null
      regularHours: number | null
      overtimeHours: number | null
      breakMinutes: number | null
      status: string
      location: string | null
      terminalId: string | null
      verifyMethod: string | null
      clockInPhoto: string | null
      clockOutPhoto: string | null
      notes: string | null
      isManualEntry: boolean
      approvedById: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["timeEntry"]>
    composites: {}
  }

  type TimeEntryGetPayload<S extends boolean | null | undefined | TimeEntryDefaultArgs> = $Result.GetResult<Prisma.$TimeEntryPayload, S>

  type TimeEntryCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<TimeEntryFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: TimeEntryCountAggregateInputType | true
    }

  export interface TimeEntryDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['TimeEntry'], meta: { name: 'TimeEntry' } }
    /**
     * Find zero or one TimeEntry that matches the filter.
     * @param {TimeEntryFindUniqueArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends TimeEntryFindUniqueArgs>(args: SelectSubset<T, TimeEntryFindUniqueArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one TimeEntry that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {TimeEntryFindUniqueOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends TimeEntryFindUniqueOrThrowArgs>(args: SelectSubset<T, TimeEntryFindUniqueOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first TimeEntry that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends TimeEntryFindFirstArgs>(args?: SelectSubset<T, TimeEntryFindFirstArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first TimeEntry that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindFirstOrThrowArgs} args - Arguments to find a TimeEntry
     * @example
     * // Get one TimeEntry
     * const timeEntry = await prisma.timeEntry.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends TimeEntryFindFirstOrThrowArgs>(args?: SelectSubset<T, TimeEntryFindFirstOrThrowArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more TimeEntries that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany()
     * 
     * // Get first 10 TimeEntries
     * const timeEntries = await prisma.timeEntry.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends TimeEntryFindManyArgs>(args?: SelectSubset<T, TimeEntryFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a TimeEntry.
     * @param {TimeEntryCreateArgs} args - Arguments to create a TimeEntry.
     * @example
     * // Create one TimeEntry
     * const TimeEntry = await prisma.timeEntry.create({
     *   data: {
     *     // ... data to create a TimeEntry
     *   }
     * })
     * 
     */
    create<T extends TimeEntryCreateArgs>(args: SelectSubset<T, TimeEntryCreateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many TimeEntries.
     * @param {TimeEntryCreateManyArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends TimeEntryCreateManyArgs>(args?: SelectSubset<T, TimeEntryCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many TimeEntries and returns the data saved in the database.
     * @param {TimeEntryCreateManyAndReturnArgs} args - Arguments to create many TimeEntries.
     * @example
     * // Create many TimeEntries
     * const timeEntry = await prisma.timeEntry.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many TimeEntries and only return the `id`
     * const timeEntryWithIdOnly = await prisma.timeEntry.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends TimeEntryCreateManyAndReturnArgs>(args?: SelectSubset<T, TimeEntryCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a TimeEntry.
     * @param {TimeEntryDeleteArgs} args - Arguments to delete one TimeEntry.
     * @example
     * // Delete one TimeEntry
     * const TimeEntry = await prisma.timeEntry.delete({
     *   where: {
     *     // ... filter to delete one TimeEntry
     *   }
     * })
     * 
     */
    delete<T extends TimeEntryDeleteArgs>(args: SelectSubset<T, TimeEntryDeleteArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one TimeEntry.
     * @param {TimeEntryUpdateArgs} args - Arguments to update one TimeEntry.
     * @example
     * // Update one TimeEntry
     * const timeEntry = await prisma.timeEntry.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends TimeEntryUpdateArgs>(args: SelectSubset<T, TimeEntryUpdateArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more TimeEntries.
     * @param {TimeEntryDeleteManyArgs} args - Arguments to filter TimeEntries to delete.
     * @example
     * // Delete a few TimeEntries
     * const { count } = await prisma.timeEntry.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends TimeEntryDeleteManyArgs>(args?: SelectSubset<T, TimeEntryDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many TimeEntries
     * const timeEntry = await prisma.timeEntry.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends TimeEntryUpdateManyArgs>(args: SelectSubset<T, TimeEntryUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one TimeEntry.
     * @param {TimeEntryUpsertArgs} args - Arguments to update or create a TimeEntry.
     * @example
     * // Update or create a TimeEntry
     * const timeEntry = await prisma.timeEntry.upsert({
     *   create: {
     *     // ... data to create a TimeEntry
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the TimeEntry we want to update
     *   }
     * })
     */
    upsert<T extends TimeEntryUpsertArgs>(args: SelectSubset<T, TimeEntryUpsertArgs<ExtArgs>>): Prisma__TimeEntryClient<$Result.GetResult<Prisma.$TimeEntryPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of TimeEntries.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryCountArgs} args - Arguments to filter TimeEntries to count.
     * @example
     * // Count the number of TimeEntries
     * const count = await prisma.timeEntry.count({
     *   where: {
     *     // ... the filter for the TimeEntries we want to count
     *   }
     * })
    **/
    count<T extends TimeEntryCountArgs>(
      args?: Subset<T, TimeEntryCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], TimeEntryCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends TimeEntryAggregateArgs>(args: Subset<T, TimeEntryAggregateArgs>): Prisma.PrismaPromise<GetTimeEntryAggregateType<T>>

    /**
     * Group by TimeEntry.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {TimeEntryGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends TimeEntryGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: TimeEntryGroupByArgs['orderBy'] }
        : { orderBy?: TimeEntryGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, TimeEntryGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetTimeEntryGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the TimeEntry model
   */
  readonly fields: TimeEntryFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for TimeEntry.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__TimeEntryClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    User<T extends TimeEntry$UserArgs<ExtArgs> = {}>(args?: Subset<T, TimeEntry$UserArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    Terminal<T extends TimeEntry$TerminalArgs<ExtArgs> = {}>(args?: Subset<T, TimeEntry$TerminalArgs<ExtArgs>>): Prisma__TerminalClient<$Result.GetResult<Prisma.$TerminalPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the TimeEntry model
   */ 
  interface TimeEntryFieldRefs {
    readonly id: FieldRef<"TimeEntry", 'String'>
    readonly employeeId: FieldRef<"TimeEntry", 'String'>
    readonly clockIn: FieldRef<"TimeEntry", 'DateTime'>
    readonly clockOut: FieldRef<"TimeEntry", 'DateTime'>
    readonly breakStart: FieldRef<"TimeEntry", 'DateTime'>
    readonly breakEnd: FieldRef<"TimeEntry", 'DateTime'>
    readonly totalHours: FieldRef<"TimeEntry", 'Float'>
    readonly regularHours: FieldRef<"TimeEntry", 'Float'>
    readonly overtimeHours: FieldRef<"TimeEntry", 'Float'>
    readonly breakMinutes: FieldRef<"TimeEntry", 'Int'>
    readonly status: FieldRef<"TimeEntry", 'String'>
    readonly location: FieldRef<"TimeEntry", 'String'>
    readonly terminalId: FieldRef<"TimeEntry", 'String'>
    readonly verifyMethod: FieldRef<"TimeEntry", 'String'>
    readonly clockInPhoto: FieldRef<"TimeEntry", 'String'>
    readonly clockOutPhoto: FieldRef<"TimeEntry", 'String'>
    readonly notes: FieldRef<"TimeEntry", 'String'>
    readonly isManualEntry: FieldRef<"TimeEntry", 'Boolean'>
    readonly approvedById: FieldRef<"TimeEntry", 'String'>
    readonly createdAt: FieldRef<"TimeEntry", 'DateTime'>
    readonly updatedAt: FieldRef<"TimeEntry", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * TimeEntry findUnique
   */
  export type TimeEntryFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findUniqueOrThrow
   */
  export type TimeEntryFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry findFirst
   */
  export type TimeEntryFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findFirstOrThrow
   */
  export type TimeEntryFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntry to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of TimeEntries.
     */
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry findMany
   */
  export type TimeEntryFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter, which TimeEntries to fetch.
     */
    where?: TimeEntryWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of TimeEntries to fetch.
     */
    orderBy?: TimeEntryOrderByWithRelationInput | TimeEntryOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing TimeEntries.
     */
    cursor?: TimeEntryWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` TimeEntries from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` TimeEntries.
     */
    skip?: number
    distinct?: TimeEntryScalarFieldEnum | TimeEntryScalarFieldEnum[]
  }

  /**
   * TimeEntry create
   */
  export type TimeEntryCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to create a TimeEntry.
     */
    data: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
  }

  /**
   * TimeEntry createMany
   */
  export type TimeEntryCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * TimeEntry createManyAndReturn
   */
  export type TimeEntryCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many TimeEntries.
     */
    data: TimeEntryCreateManyInput | TimeEntryCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * TimeEntry update
   */
  export type TimeEntryUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The data needed to update a TimeEntry.
     */
    data: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
    /**
     * Choose, which TimeEntry to update.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry updateMany
   */
  export type TimeEntryUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update TimeEntries.
     */
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyInput>
    /**
     * Filter which TimeEntries to update
     */
    where?: TimeEntryWhereInput
  }

  /**
   * TimeEntry upsert
   */
  export type TimeEntryUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * The filter to search for the TimeEntry to update in case it exists.
     */
    where: TimeEntryWhereUniqueInput
    /**
     * In case the TimeEntry found by the `where` argument doesn't exist, create a new TimeEntry with this data.
     */
    create: XOR<TimeEntryCreateInput, TimeEntryUncheckedCreateInput>
    /**
     * In case the TimeEntry was found with the provided `where` argument, update it with this data.
     */
    update: XOR<TimeEntryUpdateInput, TimeEntryUncheckedUpdateInput>
  }

  /**
   * TimeEntry delete
   */
  export type TimeEntryDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
    /**
     * Filter which TimeEntry to delete.
     */
    where: TimeEntryWhereUniqueInput
  }

  /**
   * TimeEntry deleteMany
   */
  export type TimeEntryDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which TimeEntries to delete
     */
    where?: TimeEntryWhereInput
  }

  /**
   * TimeEntry.User
   */
  export type TimeEntry$UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * TimeEntry.Terminal
   */
  export type TimeEntry$TerminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Terminal
     */
    select?: TerminalSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TerminalInclude<ExtArgs> | null
    where?: TerminalWhereInput
  }

  /**
   * TimeEntry without action
   */
  export type TimeEntryDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the TimeEntry
     */
    select?: TimeEntrySelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: TimeEntryInclude<ExtArgs> | null
  }


  /**
   * Model EmployeeRate
   */

  export type AggregateEmployeeRate = {
    _count: EmployeeRateCountAggregateOutputType | null
    _avg: EmployeeRateAvgAggregateOutputType | null
    _sum: EmployeeRateSumAggregateOutputType | null
    _min: EmployeeRateMinAggregateOutputType | null
    _max: EmployeeRateMaxAggregateOutputType | null
  }

  export type EmployeeRateAvgAggregateOutputType = {
    hourlyRate: number | null
    dailyRate: number | null
    salary: number | null
    overtimeRate: number | null
  }

  export type EmployeeRateSumAggregateOutputType = {
    hourlyRate: number | null
    dailyRate: number | null
    salary: number | null
    overtimeRate: number | null
  }

  export type EmployeeRateMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    hourlyRate: number | null
    dailyRate: number | null
    salary: number | null
    overtimeRate: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    currency: string | null
    rateType: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeRateMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    hourlyRate: number | null
    dailyRate: number | null
    salary: number | null
    overtimeRate: number | null
    effectiveFrom: Date | null
    effectiveTo: Date | null
    currency: string | null
    rateType: string | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type EmployeeRateCountAggregateOutputType = {
    id: number
    employeeId: number
    hourlyRate: number
    dailyRate: number
    salary: number
    overtimeRate: number
    effectiveFrom: number
    effectiveTo: number
    currency: number
    rateType: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type EmployeeRateAvgAggregateInputType = {
    hourlyRate?: true
    dailyRate?: true
    salary?: true
    overtimeRate?: true
  }

  export type EmployeeRateSumAggregateInputType = {
    hourlyRate?: true
    dailyRate?: true
    salary?: true
    overtimeRate?: true
  }

  export type EmployeeRateMinAggregateInputType = {
    id?: true
    employeeId?: true
    hourlyRate?: true
    dailyRate?: true
    salary?: true
    overtimeRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    currency?: true
    rateType?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeRateMaxAggregateInputType = {
    id?: true
    employeeId?: true
    hourlyRate?: true
    dailyRate?: true
    salary?: true
    overtimeRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    currency?: true
    rateType?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type EmployeeRateCountAggregateInputType = {
    id?: true
    employeeId?: true
    hourlyRate?: true
    dailyRate?: true
    salary?: true
    overtimeRate?: true
    effectiveFrom?: true
    effectiveTo?: true
    currency?: true
    rateType?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type EmployeeRateAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRate to aggregate.
     */
    where?: EmployeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRates to fetch.
     */
    orderBy?: EmployeeRateOrderByWithRelationInput | EmployeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: EmployeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned EmployeeRates
    **/
    _count?: true | EmployeeRateCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: EmployeeRateAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: EmployeeRateSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: EmployeeRateMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: EmployeeRateMaxAggregateInputType
  }

  export type GetEmployeeRateAggregateType<T extends EmployeeRateAggregateArgs> = {
        [P in keyof T & keyof AggregateEmployeeRate]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateEmployeeRate[P]>
      : GetScalarType<T[P], AggregateEmployeeRate[P]>
  }




  export type EmployeeRateGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: EmployeeRateWhereInput
    orderBy?: EmployeeRateOrderByWithAggregationInput | EmployeeRateOrderByWithAggregationInput[]
    by: EmployeeRateScalarFieldEnum[] | EmployeeRateScalarFieldEnum
    having?: EmployeeRateScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: EmployeeRateCountAggregateInputType | true
    _avg?: EmployeeRateAvgAggregateInputType
    _sum?: EmployeeRateSumAggregateInputType
    _min?: EmployeeRateMinAggregateInputType
    _max?: EmployeeRateMaxAggregateInputType
  }

  export type EmployeeRateGroupByOutputType = {
    id: string
    employeeId: string
    hourlyRate: number
    dailyRate: number | null
    salary: number | null
    overtimeRate: number | null
    effectiveFrom: Date
    effectiveTo: Date | null
    currency: string
    rateType: string
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: EmployeeRateCountAggregateOutputType | null
    _avg: EmployeeRateAvgAggregateOutputType | null
    _sum: EmployeeRateSumAggregateOutputType | null
    _min: EmployeeRateMinAggregateOutputType | null
    _max: EmployeeRateMaxAggregateOutputType | null
  }

  type GetEmployeeRateGroupByPayload<T extends EmployeeRateGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<EmployeeRateGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof EmployeeRateGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], EmployeeRateGroupByOutputType[P]>
            : GetScalarType<T[P], EmployeeRateGroupByOutputType[P]>
        }
      >
    >


  export type EmployeeRateSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    hourlyRate?: boolean
    dailyRate?: boolean
    salary?: boolean
    overtimeRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    currency?: boolean
    rateType?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRate"]>

  export type EmployeeRateSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    hourlyRate?: boolean
    dailyRate?: boolean
    salary?: boolean
    overtimeRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    currency?: boolean
    rateType?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }, ExtArgs["result"]["employeeRate"]>

  export type EmployeeRateSelectScalar = {
    id?: boolean
    employeeId?: boolean
    hourlyRate?: boolean
    dailyRate?: boolean
    salary?: boolean
    overtimeRate?: boolean
    effectiveFrom?: boolean
    effectiveTo?: boolean
    currency?: boolean
    rateType?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type EmployeeRateInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }
  export type EmployeeRateIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
  }

  export type $EmployeeRatePayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "EmployeeRate"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      hourlyRate: number
      dailyRate: number | null
      salary: number | null
      overtimeRate: number | null
      effectiveFrom: Date
      effectiveTo: Date | null
      currency: string
      rateType: string
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["employeeRate"]>
    composites: {}
  }

  type EmployeeRateGetPayload<S extends boolean | null | undefined | EmployeeRateDefaultArgs> = $Result.GetResult<Prisma.$EmployeeRatePayload, S>

  type EmployeeRateCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<EmployeeRateFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: EmployeeRateCountAggregateInputType | true
    }

  export interface EmployeeRateDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['EmployeeRate'], meta: { name: 'EmployeeRate' } }
    /**
     * Find zero or one EmployeeRate that matches the filter.
     * @param {EmployeeRateFindUniqueArgs} args - Arguments to find a EmployeeRate
     * @example
     * // Get one EmployeeRate
     * const employeeRate = await prisma.employeeRate.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends EmployeeRateFindUniqueArgs>(args: SelectSubset<T, EmployeeRateFindUniqueArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one EmployeeRate that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {EmployeeRateFindUniqueOrThrowArgs} args - Arguments to find a EmployeeRate
     * @example
     * // Get one EmployeeRate
     * const employeeRate = await prisma.employeeRate.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends EmployeeRateFindUniqueOrThrowArgs>(args: SelectSubset<T, EmployeeRateFindUniqueOrThrowArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first EmployeeRate that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateFindFirstArgs} args - Arguments to find a EmployeeRate
     * @example
     * // Get one EmployeeRate
     * const employeeRate = await prisma.employeeRate.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends EmployeeRateFindFirstArgs>(args?: SelectSubset<T, EmployeeRateFindFirstArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first EmployeeRate that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateFindFirstOrThrowArgs} args - Arguments to find a EmployeeRate
     * @example
     * // Get one EmployeeRate
     * const employeeRate = await prisma.employeeRate.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends EmployeeRateFindFirstOrThrowArgs>(args?: SelectSubset<T, EmployeeRateFindFirstOrThrowArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more EmployeeRates that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all EmployeeRates
     * const employeeRates = await prisma.employeeRate.findMany()
     * 
     * // Get first 10 EmployeeRates
     * const employeeRates = await prisma.employeeRate.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const employeeRateWithIdOnly = await prisma.employeeRate.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends EmployeeRateFindManyArgs>(args?: SelectSubset<T, EmployeeRateFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "findMany">>

    /**
     * Create a EmployeeRate.
     * @param {EmployeeRateCreateArgs} args - Arguments to create a EmployeeRate.
     * @example
     * // Create one EmployeeRate
     * const EmployeeRate = await prisma.employeeRate.create({
     *   data: {
     *     // ... data to create a EmployeeRate
     *   }
     * })
     * 
     */
    create<T extends EmployeeRateCreateArgs>(args: SelectSubset<T, EmployeeRateCreateArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many EmployeeRates.
     * @param {EmployeeRateCreateManyArgs} args - Arguments to create many EmployeeRates.
     * @example
     * // Create many EmployeeRates
     * const employeeRate = await prisma.employeeRate.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends EmployeeRateCreateManyArgs>(args?: SelectSubset<T, EmployeeRateCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many EmployeeRates and returns the data saved in the database.
     * @param {EmployeeRateCreateManyAndReturnArgs} args - Arguments to create many EmployeeRates.
     * @example
     * // Create many EmployeeRates
     * const employeeRate = await prisma.employeeRate.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many EmployeeRates and only return the `id`
     * const employeeRateWithIdOnly = await prisma.employeeRate.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends EmployeeRateCreateManyAndReturnArgs>(args?: SelectSubset<T, EmployeeRateCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a EmployeeRate.
     * @param {EmployeeRateDeleteArgs} args - Arguments to delete one EmployeeRate.
     * @example
     * // Delete one EmployeeRate
     * const EmployeeRate = await prisma.employeeRate.delete({
     *   where: {
     *     // ... filter to delete one EmployeeRate
     *   }
     * })
     * 
     */
    delete<T extends EmployeeRateDeleteArgs>(args: SelectSubset<T, EmployeeRateDeleteArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one EmployeeRate.
     * @param {EmployeeRateUpdateArgs} args - Arguments to update one EmployeeRate.
     * @example
     * // Update one EmployeeRate
     * const employeeRate = await prisma.employeeRate.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends EmployeeRateUpdateArgs>(args: SelectSubset<T, EmployeeRateUpdateArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more EmployeeRates.
     * @param {EmployeeRateDeleteManyArgs} args - Arguments to filter EmployeeRates to delete.
     * @example
     * // Delete a few EmployeeRates
     * const { count } = await prisma.employeeRate.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends EmployeeRateDeleteManyArgs>(args?: SelectSubset<T, EmployeeRateDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more EmployeeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many EmployeeRates
     * const employeeRate = await prisma.employeeRate.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends EmployeeRateUpdateManyArgs>(args: SelectSubset<T, EmployeeRateUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one EmployeeRate.
     * @param {EmployeeRateUpsertArgs} args - Arguments to update or create a EmployeeRate.
     * @example
     * // Update or create a EmployeeRate
     * const employeeRate = await prisma.employeeRate.upsert({
     *   create: {
     *     // ... data to create a EmployeeRate
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the EmployeeRate we want to update
     *   }
     * })
     */
    upsert<T extends EmployeeRateUpsertArgs>(args: SelectSubset<T, EmployeeRateUpsertArgs<ExtArgs>>): Prisma__EmployeeRateClient<$Result.GetResult<Prisma.$EmployeeRatePayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of EmployeeRates.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateCountArgs} args - Arguments to filter EmployeeRates to count.
     * @example
     * // Count the number of EmployeeRates
     * const count = await prisma.employeeRate.count({
     *   where: {
     *     // ... the filter for the EmployeeRates we want to count
     *   }
     * })
    **/
    count<T extends EmployeeRateCountArgs>(
      args?: Subset<T, EmployeeRateCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], EmployeeRateCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a EmployeeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends EmployeeRateAggregateArgs>(args: Subset<T, EmployeeRateAggregateArgs>): Prisma.PrismaPromise<GetEmployeeRateAggregateType<T>>

    /**
     * Group by EmployeeRate.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {EmployeeRateGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends EmployeeRateGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: EmployeeRateGroupByArgs['orderBy'] }
        : { orderBy?: EmployeeRateGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, EmployeeRateGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetEmployeeRateGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the EmployeeRate model
   */
  readonly fields: EmployeeRateFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for EmployeeRate.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__EmployeeRateClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the EmployeeRate model
   */ 
  interface EmployeeRateFieldRefs {
    readonly id: FieldRef<"EmployeeRate", 'String'>
    readonly employeeId: FieldRef<"EmployeeRate", 'String'>
    readonly hourlyRate: FieldRef<"EmployeeRate", 'Float'>
    readonly dailyRate: FieldRef<"EmployeeRate", 'Float'>
    readonly salary: FieldRef<"EmployeeRate", 'Float'>
    readonly overtimeRate: FieldRef<"EmployeeRate", 'Float'>
    readonly effectiveFrom: FieldRef<"EmployeeRate", 'DateTime'>
    readonly effectiveTo: FieldRef<"EmployeeRate", 'DateTime'>
    readonly currency: FieldRef<"EmployeeRate", 'String'>
    readonly rateType: FieldRef<"EmployeeRate", 'String'>
    readonly notes: FieldRef<"EmployeeRate", 'String'>
    readonly createdAt: FieldRef<"EmployeeRate", 'DateTime'>
    readonly updatedAt: FieldRef<"EmployeeRate", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * EmployeeRate findUnique
   */
  export type EmployeeRateFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRate to fetch.
     */
    where: EmployeeRateWhereUniqueInput
  }

  /**
   * EmployeeRate findUniqueOrThrow
   */
  export type EmployeeRateFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRate to fetch.
     */
    where: EmployeeRateWhereUniqueInput
  }

  /**
   * EmployeeRate findFirst
   */
  export type EmployeeRateFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRate to fetch.
     */
    where?: EmployeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRates to fetch.
     */
    orderBy?: EmployeeRateOrderByWithRelationInput | EmployeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRates.
     */
    cursor?: EmployeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRates.
     */
    distinct?: EmployeeRateScalarFieldEnum | EmployeeRateScalarFieldEnum[]
  }

  /**
   * EmployeeRate findFirstOrThrow
   */
  export type EmployeeRateFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRate to fetch.
     */
    where?: EmployeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRates to fetch.
     */
    orderBy?: EmployeeRateOrderByWithRelationInput | EmployeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for EmployeeRates.
     */
    cursor?: EmployeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRates.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of EmployeeRates.
     */
    distinct?: EmployeeRateScalarFieldEnum | EmployeeRateScalarFieldEnum[]
  }

  /**
   * EmployeeRate findMany
   */
  export type EmployeeRateFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter, which EmployeeRates to fetch.
     */
    where?: EmployeeRateWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of EmployeeRates to fetch.
     */
    orderBy?: EmployeeRateOrderByWithRelationInput | EmployeeRateOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing EmployeeRates.
     */
    cursor?: EmployeeRateWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` EmployeeRates from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` EmployeeRates.
     */
    skip?: number
    distinct?: EmployeeRateScalarFieldEnum | EmployeeRateScalarFieldEnum[]
  }

  /**
   * EmployeeRate create
   */
  export type EmployeeRateCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * The data needed to create a EmployeeRate.
     */
    data: XOR<EmployeeRateCreateInput, EmployeeRateUncheckedCreateInput>
  }

  /**
   * EmployeeRate createMany
   */
  export type EmployeeRateCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many EmployeeRates.
     */
    data: EmployeeRateCreateManyInput | EmployeeRateCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * EmployeeRate createManyAndReturn
   */
  export type EmployeeRateCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many EmployeeRates.
     */
    data: EmployeeRateCreateManyInput | EmployeeRateCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * EmployeeRate update
   */
  export type EmployeeRateUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * The data needed to update a EmployeeRate.
     */
    data: XOR<EmployeeRateUpdateInput, EmployeeRateUncheckedUpdateInput>
    /**
     * Choose, which EmployeeRate to update.
     */
    where: EmployeeRateWhereUniqueInput
  }

  /**
   * EmployeeRate updateMany
   */
  export type EmployeeRateUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update EmployeeRates.
     */
    data: XOR<EmployeeRateUpdateManyMutationInput, EmployeeRateUncheckedUpdateManyInput>
    /**
     * Filter which EmployeeRates to update
     */
    where?: EmployeeRateWhereInput
  }

  /**
   * EmployeeRate upsert
   */
  export type EmployeeRateUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * The filter to search for the EmployeeRate to update in case it exists.
     */
    where: EmployeeRateWhereUniqueInput
    /**
     * In case the EmployeeRate found by the `where` argument doesn't exist, create a new EmployeeRate with this data.
     */
    create: XOR<EmployeeRateCreateInput, EmployeeRateUncheckedCreateInput>
    /**
     * In case the EmployeeRate was found with the provided `where` argument, update it with this data.
     */
    update: XOR<EmployeeRateUpdateInput, EmployeeRateUncheckedUpdateInput>
  }

  /**
   * EmployeeRate delete
   */
  export type EmployeeRateDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
    /**
     * Filter which EmployeeRate to delete.
     */
    where: EmployeeRateWhereUniqueInput
  }

  /**
   * EmployeeRate deleteMany
   */
  export type EmployeeRateDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which EmployeeRates to delete
     */
    where?: EmployeeRateWhereInput
  }

  /**
   * EmployeeRate without action
   */
  export type EmployeeRateDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the EmployeeRate
     */
    select?: EmployeeRateSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: EmployeeRateInclude<ExtArgs> | null
  }


  /**
   * Model PayrollDeduction
   */

  export type AggregatePayrollDeduction = {
    _count: PayrollDeductionCountAggregateOutputType | null
    _avg: PayrollDeductionAvgAggregateOutputType | null
    _sum: PayrollDeductionSumAggregateOutputType | null
    _min: PayrollDeductionMinAggregateOutputType | null
    _max: PayrollDeductionMaxAggregateOutputType | null
  }

  export type PayrollDeductionAvgAggregateOutputType = {
    amount: number | null
  }

  export type PayrollDeductionSumAggregateOutputType = {
    amount: number | null
  }

  export type PayrollDeductionMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    deductionType: string | null
    amount: number | null
    reason: string | null
    description: string | null
    month: Date | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
    appliedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollDeductionMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    deductionType: string | null
    amount: number | null
    reason: string | null
    description: string | null
    month: Date | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
    appliedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type PayrollDeductionCountAggregateOutputType = {
    id: number
    employeeId: number
    deductionType: number
    amount: number
    reason: number
    description: number
    month: number
    status: number
    approvedBy: number
    approvedAt: number
    appliedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type PayrollDeductionAvgAggregateInputType = {
    amount?: true
  }

  export type PayrollDeductionSumAggregateInputType = {
    amount?: true
  }

  export type PayrollDeductionMinAggregateInputType = {
    id?: true
    employeeId?: true
    deductionType?: true
    amount?: true
    reason?: true
    description?: true
    month?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    appliedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollDeductionMaxAggregateInputType = {
    id?: true
    employeeId?: true
    deductionType?: true
    amount?: true
    reason?: true
    description?: true
    month?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    appliedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type PayrollDeductionCountAggregateInputType = {
    id?: true
    employeeId?: true
    deductionType?: true
    amount?: true
    reason?: true
    description?: true
    month?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    appliedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type PayrollDeductionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollDeduction to aggregate.
     */
    where?: PayrollDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollDeductions to fetch.
     */
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: PayrollDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned PayrollDeductions
    **/
    _count?: true | PayrollDeductionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: PayrollDeductionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: PayrollDeductionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: PayrollDeductionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: PayrollDeductionMaxAggregateInputType
  }

  export type GetPayrollDeductionAggregateType<T extends PayrollDeductionAggregateArgs> = {
        [P in keyof T & keyof AggregatePayrollDeduction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregatePayrollDeduction[P]>
      : GetScalarType<T[P], AggregatePayrollDeduction[P]>
  }




  export type PayrollDeductionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: PayrollDeductionWhereInput
    orderBy?: PayrollDeductionOrderByWithAggregationInput | PayrollDeductionOrderByWithAggregationInput[]
    by: PayrollDeductionScalarFieldEnum[] | PayrollDeductionScalarFieldEnum
    having?: PayrollDeductionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: PayrollDeductionCountAggregateInputType | true
    _avg?: PayrollDeductionAvgAggregateInputType
    _sum?: PayrollDeductionSumAggregateInputType
    _min?: PayrollDeductionMinAggregateInputType
    _max?: PayrollDeductionMaxAggregateInputType
  }

  export type PayrollDeductionGroupByOutputType = {
    id: string
    employeeId: string
    deductionType: string
    amount: number
    reason: string | null
    description: string | null
    month: Date
    status: string
    approvedBy: string | null
    approvedAt: Date | null
    appliedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: PayrollDeductionCountAggregateOutputType | null
    _avg: PayrollDeductionAvgAggregateOutputType | null
    _sum: PayrollDeductionSumAggregateOutputType | null
    _min: PayrollDeductionMinAggregateOutputType | null
    _max: PayrollDeductionMaxAggregateOutputType | null
  }

  type GetPayrollDeductionGroupByPayload<T extends PayrollDeductionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<PayrollDeductionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof PayrollDeductionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], PayrollDeductionGroupByOutputType[P]>
            : GetScalarType<T[P], PayrollDeductionGroupByOutputType[P]>
        }
      >
    >


  export type PayrollDeductionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    deductionType?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    month?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    appliedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ApprovedBy?: boolean | PayrollDeduction$ApprovedByArgs<ExtArgs>
  }, ExtArgs["result"]["payrollDeduction"]>

  export type PayrollDeductionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    deductionType?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    month?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    appliedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ApprovedBy?: boolean | PayrollDeduction$ApprovedByArgs<ExtArgs>
  }, ExtArgs["result"]["payrollDeduction"]>

  export type PayrollDeductionSelectScalar = {
    id?: boolean
    employeeId?: boolean
    deductionType?: boolean
    amount?: boolean
    reason?: boolean
    description?: boolean
    month?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    appliedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type PayrollDeductionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ApprovedBy?: boolean | PayrollDeduction$ApprovedByArgs<ExtArgs>
  }
  export type PayrollDeductionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ApprovedBy?: boolean | PayrollDeduction$ApprovedByArgs<ExtArgs>
  }

  export type $PayrollDeductionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "PayrollDeduction"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
      ApprovedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      deductionType: string
      amount: number
      reason: string | null
      description: string | null
      month: Date
      status: string
      approvedBy: string | null
      approvedAt: Date | null
      appliedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["payrollDeduction"]>
    composites: {}
  }

  type PayrollDeductionGetPayload<S extends boolean | null | undefined | PayrollDeductionDefaultArgs> = $Result.GetResult<Prisma.$PayrollDeductionPayload, S>

  type PayrollDeductionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<PayrollDeductionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: PayrollDeductionCountAggregateInputType | true
    }

  export interface PayrollDeductionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['PayrollDeduction'], meta: { name: 'PayrollDeduction' } }
    /**
     * Find zero or one PayrollDeduction that matches the filter.
     * @param {PayrollDeductionFindUniqueArgs} args - Arguments to find a PayrollDeduction
     * @example
     * // Get one PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends PayrollDeductionFindUniqueArgs>(args: SelectSubset<T, PayrollDeductionFindUniqueArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one PayrollDeduction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {PayrollDeductionFindUniqueOrThrowArgs} args - Arguments to find a PayrollDeduction
     * @example
     * // Get one PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends PayrollDeductionFindUniqueOrThrowArgs>(args: SelectSubset<T, PayrollDeductionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first PayrollDeduction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionFindFirstArgs} args - Arguments to find a PayrollDeduction
     * @example
     * // Get one PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends PayrollDeductionFindFirstArgs>(args?: SelectSubset<T, PayrollDeductionFindFirstArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first PayrollDeduction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionFindFirstOrThrowArgs} args - Arguments to find a PayrollDeduction
     * @example
     * // Get one PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends PayrollDeductionFindFirstOrThrowArgs>(args?: SelectSubset<T, PayrollDeductionFindFirstOrThrowArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more PayrollDeductions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all PayrollDeductions
     * const payrollDeductions = await prisma.payrollDeduction.findMany()
     * 
     * // Get first 10 PayrollDeductions
     * const payrollDeductions = await prisma.payrollDeduction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const payrollDeductionWithIdOnly = await prisma.payrollDeduction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends PayrollDeductionFindManyArgs>(args?: SelectSubset<T, PayrollDeductionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a PayrollDeduction.
     * @param {PayrollDeductionCreateArgs} args - Arguments to create a PayrollDeduction.
     * @example
     * // Create one PayrollDeduction
     * const PayrollDeduction = await prisma.payrollDeduction.create({
     *   data: {
     *     // ... data to create a PayrollDeduction
     *   }
     * })
     * 
     */
    create<T extends PayrollDeductionCreateArgs>(args: SelectSubset<T, PayrollDeductionCreateArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many PayrollDeductions.
     * @param {PayrollDeductionCreateManyArgs} args - Arguments to create many PayrollDeductions.
     * @example
     * // Create many PayrollDeductions
     * const payrollDeduction = await prisma.payrollDeduction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends PayrollDeductionCreateManyArgs>(args?: SelectSubset<T, PayrollDeductionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many PayrollDeductions and returns the data saved in the database.
     * @param {PayrollDeductionCreateManyAndReturnArgs} args - Arguments to create many PayrollDeductions.
     * @example
     * // Create many PayrollDeductions
     * const payrollDeduction = await prisma.payrollDeduction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many PayrollDeductions and only return the `id`
     * const payrollDeductionWithIdOnly = await prisma.payrollDeduction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends PayrollDeductionCreateManyAndReturnArgs>(args?: SelectSubset<T, PayrollDeductionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a PayrollDeduction.
     * @param {PayrollDeductionDeleteArgs} args - Arguments to delete one PayrollDeduction.
     * @example
     * // Delete one PayrollDeduction
     * const PayrollDeduction = await prisma.payrollDeduction.delete({
     *   where: {
     *     // ... filter to delete one PayrollDeduction
     *   }
     * })
     * 
     */
    delete<T extends PayrollDeductionDeleteArgs>(args: SelectSubset<T, PayrollDeductionDeleteArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one PayrollDeduction.
     * @param {PayrollDeductionUpdateArgs} args - Arguments to update one PayrollDeduction.
     * @example
     * // Update one PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends PayrollDeductionUpdateArgs>(args: SelectSubset<T, PayrollDeductionUpdateArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more PayrollDeductions.
     * @param {PayrollDeductionDeleteManyArgs} args - Arguments to filter PayrollDeductions to delete.
     * @example
     * // Delete a few PayrollDeductions
     * const { count } = await prisma.payrollDeduction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends PayrollDeductionDeleteManyArgs>(args?: SelectSubset<T, PayrollDeductionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more PayrollDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many PayrollDeductions
     * const payrollDeduction = await prisma.payrollDeduction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends PayrollDeductionUpdateManyArgs>(args: SelectSubset<T, PayrollDeductionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one PayrollDeduction.
     * @param {PayrollDeductionUpsertArgs} args - Arguments to update or create a PayrollDeduction.
     * @example
     * // Update or create a PayrollDeduction
     * const payrollDeduction = await prisma.payrollDeduction.upsert({
     *   create: {
     *     // ... data to create a PayrollDeduction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the PayrollDeduction we want to update
     *   }
     * })
     */
    upsert<T extends PayrollDeductionUpsertArgs>(args: SelectSubset<T, PayrollDeductionUpsertArgs<ExtArgs>>): Prisma__PayrollDeductionClient<$Result.GetResult<Prisma.$PayrollDeductionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of PayrollDeductions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionCountArgs} args - Arguments to filter PayrollDeductions to count.
     * @example
     * // Count the number of PayrollDeductions
     * const count = await prisma.payrollDeduction.count({
     *   where: {
     *     // ... the filter for the PayrollDeductions we want to count
     *   }
     * })
    **/
    count<T extends PayrollDeductionCountArgs>(
      args?: Subset<T, PayrollDeductionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], PayrollDeductionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a PayrollDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends PayrollDeductionAggregateArgs>(args: Subset<T, PayrollDeductionAggregateArgs>): Prisma.PrismaPromise<GetPayrollDeductionAggregateType<T>>

    /**
     * Group by PayrollDeduction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {PayrollDeductionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends PayrollDeductionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: PayrollDeductionGroupByArgs['orderBy'] }
        : { orderBy?: PayrollDeductionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, PayrollDeductionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetPayrollDeductionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the PayrollDeduction model
   */
  readonly fields: PayrollDeductionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for PayrollDeduction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__PayrollDeductionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ApprovedBy<T extends PayrollDeduction$ApprovedByArgs<ExtArgs> = {}>(args?: Subset<T, PayrollDeduction$ApprovedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the PayrollDeduction model
   */ 
  interface PayrollDeductionFieldRefs {
    readonly id: FieldRef<"PayrollDeduction", 'String'>
    readonly employeeId: FieldRef<"PayrollDeduction", 'String'>
    readonly deductionType: FieldRef<"PayrollDeduction", 'String'>
    readonly amount: FieldRef<"PayrollDeduction", 'Float'>
    readonly reason: FieldRef<"PayrollDeduction", 'String'>
    readonly description: FieldRef<"PayrollDeduction", 'String'>
    readonly month: FieldRef<"PayrollDeduction", 'DateTime'>
    readonly status: FieldRef<"PayrollDeduction", 'String'>
    readonly approvedBy: FieldRef<"PayrollDeduction", 'String'>
    readonly approvedAt: FieldRef<"PayrollDeduction", 'DateTime'>
    readonly appliedAt: FieldRef<"PayrollDeduction", 'DateTime'>
    readonly notes: FieldRef<"PayrollDeduction", 'String'>
    readonly createdAt: FieldRef<"PayrollDeduction", 'DateTime'>
    readonly updatedAt: FieldRef<"PayrollDeduction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * PayrollDeduction findUnique
   */
  export type PayrollDeductionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter, which PayrollDeduction to fetch.
     */
    where: PayrollDeductionWhereUniqueInput
  }

  /**
   * PayrollDeduction findUniqueOrThrow
   */
  export type PayrollDeductionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter, which PayrollDeduction to fetch.
     */
    where: PayrollDeductionWhereUniqueInput
  }

  /**
   * PayrollDeduction findFirst
   */
  export type PayrollDeductionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter, which PayrollDeduction to fetch.
     */
    where?: PayrollDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollDeductions to fetch.
     */
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollDeductions.
     */
    cursor?: PayrollDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollDeductions.
     */
    distinct?: PayrollDeductionScalarFieldEnum | PayrollDeductionScalarFieldEnum[]
  }

  /**
   * PayrollDeduction findFirstOrThrow
   */
  export type PayrollDeductionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter, which PayrollDeduction to fetch.
     */
    where?: PayrollDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollDeductions to fetch.
     */
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for PayrollDeductions.
     */
    cursor?: PayrollDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollDeductions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of PayrollDeductions.
     */
    distinct?: PayrollDeductionScalarFieldEnum | PayrollDeductionScalarFieldEnum[]
  }

  /**
   * PayrollDeduction findMany
   */
  export type PayrollDeductionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter, which PayrollDeductions to fetch.
     */
    where?: PayrollDeductionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of PayrollDeductions to fetch.
     */
    orderBy?: PayrollDeductionOrderByWithRelationInput | PayrollDeductionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing PayrollDeductions.
     */
    cursor?: PayrollDeductionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` PayrollDeductions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` PayrollDeductions.
     */
    skip?: number
    distinct?: PayrollDeductionScalarFieldEnum | PayrollDeductionScalarFieldEnum[]
  }

  /**
   * PayrollDeduction create
   */
  export type PayrollDeductionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * The data needed to create a PayrollDeduction.
     */
    data: XOR<PayrollDeductionCreateInput, PayrollDeductionUncheckedCreateInput>
  }

  /**
   * PayrollDeduction createMany
   */
  export type PayrollDeductionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many PayrollDeductions.
     */
    data: PayrollDeductionCreateManyInput | PayrollDeductionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * PayrollDeduction createManyAndReturn
   */
  export type PayrollDeductionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many PayrollDeductions.
     */
    data: PayrollDeductionCreateManyInput | PayrollDeductionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * PayrollDeduction update
   */
  export type PayrollDeductionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * The data needed to update a PayrollDeduction.
     */
    data: XOR<PayrollDeductionUpdateInput, PayrollDeductionUncheckedUpdateInput>
    /**
     * Choose, which PayrollDeduction to update.
     */
    where: PayrollDeductionWhereUniqueInput
  }

  /**
   * PayrollDeduction updateMany
   */
  export type PayrollDeductionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update PayrollDeductions.
     */
    data: XOR<PayrollDeductionUpdateManyMutationInput, PayrollDeductionUncheckedUpdateManyInput>
    /**
     * Filter which PayrollDeductions to update
     */
    where?: PayrollDeductionWhereInput
  }

  /**
   * PayrollDeduction upsert
   */
  export type PayrollDeductionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * The filter to search for the PayrollDeduction to update in case it exists.
     */
    where: PayrollDeductionWhereUniqueInput
    /**
     * In case the PayrollDeduction found by the `where` argument doesn't exist, create a new PayrollDeduction with this data.
     */
    create: XOR<PayrollDeductionCreateInput, PayrollDeductionUncheckedCreateInput>
    /**
     * In case the PayrollDeduction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<PayrollDeductionUpdateInput, PayrollDeductionUncheckedUpdateInput>
  }

  /**
   * PayrollDeduction delete
   */
  export type PayrollDeductionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
    /**
     * Filter which PayrollDeduction to delete.
     */
    where: PayrollDeductionWhereUniqueInput
  }

  /**
   * PayrollDeduction deleteMany
   */
  export type PayrollDeductionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which PayrollDeductions to delete
     */
    where?: PayrollDeductionWhereInput
  }

  /**
   * PayrollDeduction.ApprovedBy
   */
  export type PayrollDeduction$ApprovedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * PayrollDeduction without action
   */
  export type PayrollDeductionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the PayrollDeduction
     */
    select?: PayrollDeductionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: PayrollDeductionInclude<ExtArgs> | null
  }


  /**
   * Model Infraction
   */

  export type AggregateInfraction = {
    _count: InfractionCountAggregateOutputType | null
    _avg: InfractionAvgAggregateOutputType | null
    _sum: InfractionSumAggregateOutputType | null
    _min: InfractionMinAggregateOutputType | null
    _max: InfractionMaxAggregateOutputType | null
  }

  export type InfractionAvgAggregateOutputType = {
    amount: number | null
  }

  export type InfractionSumAggregateOutputType = {
    amount: number | null
  }

  export type InfractionMinAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    severity: string | null
    amount: number | null
    description: string | null
    date: Date | null
    reportedBy: string | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfractionMaxAggregateOutputType = {
    id: string | null
    employeeId: string | null
    type: string | null
    severity: string | null
    amount: number | null
    description: string | null
    date: Date | null
    reportedBy: string | null
    status: string | null
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date | null
    updatedAt: Date | null
  }

  export type InfractionCountAggregateOutputType = {
    id: number
    employeeId: number
    type: number
    severity: number
    amount: number
    description: number
    date: number
    reportedBy: number
    status: number
    approvedBy: number
    approvedAt: number
    notes: number
    createdAt: number
    updatedAt: number
    _all: number
  }


  export type InfractionAvgAggregateInputType = {
    amount?: true
  }

  export type InfractionSumAggregateInputType = {
    amount?: true
  }

  export type InfractionMinAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    severity?: true
    amount?: true
    description?: true
    date?: true
    reportedBy?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfractionMaxAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    severity?: true
    amount?: true
    description?: true
    date?: true
    reportedBy?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
  }

  export type InfractionCountAggregateInputType = {
    id?: true
    employeeId?: true
    type?: true
    severity?: true
    amount?: true
    description?: true
    date?: true
    reportedBy?: true
    status?: true
    approvedBy?: true
    approvedAt?: true
    notes?: true
    createdAt?: true
    updatedAt?: true
    _all?: true
  }

  export type InfractionAggregateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Infraction to aggregate.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the start position
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Count returned Infractions
    **/
    _count?: true | InfractionCountAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to average
    **/
    _avg?: InfractionAvgAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to sum
    **/
    _sum?: InfractionSumAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the minimum value
    **/
    _min?: InfractionMinAggregateInputType
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/aggregations Aggregation Docs}
     * 
     * Select which fields to find the maximum value
    **/
    _max?: InfractionMaxAggregateInputType
  }

  export type GetInfractionAggregateType<T extends InfractionAggregateArgs> = {
        [P in keyof T & keyof AggregateInfraction]: P extends '_count' | 'count'
      ? T[P] extends true
        ? number
        : GetScalarType<T[P], AggregateInfraction[P]>
      : GetScalarType<T[P], AggregateInfraction[P]>
  }




  export type InfractionGroupByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    where?: InfractionWhereInput
    orderBy?: InfractionOrderByWithAggregationInput | InfractionOrderByWithAggregationInput[]
    by: InfractionScalarFieldEnum[] | InfractionScalarFieldEnum
    having?: InfractionScalarWhereWithAggregatesInput
    take?: number
    skip?: number
    _count?: InfractionCountAggregateInputType | true
    _avg?: InfractionAvgAggregateInputType
    _sum?: InfractionSumAggregateInputType
    _min?: InfractionMinAggregateInputType
    _max?: InfractionMaxAggregateInputType
  }

  export type InfractionGroupByOutputType = {
    id: string
    employeeId: string
    type: string
    severity: string
    amount: number | null
    description: string
    date: Date
    reportedBy: string | null
    status: string
    approvedBy: string | null
    approvedAt: Date | null
    notes: string | null
    createdAt: Date
    updatedAt: Date
    _count: InfractionCountAggregateOutputType | null
    _avg: InfractionAvgAggregateOutputType | null
    _sum: InfractionSumAggregateOutputType | null
    _min: InfractionMinAggregateOutputType | null
    _max: InfractionMaxAggregateOutputType | null
  }

  type GetInfractionGroupByPayload<T extends InfractionGroupByArgs> = Prisma.PrismaPromise<
    Array<
      PickEnumerable<InfractionGroupByOutputType, T['by']> &
        {
          [P in ((keyof T) & (keyof InfractionGroupByOutputType))]: P extends '_count'
            ? T[P] extends boolean
              ? number
              : GetScalarType<T[P], InfractionGroupByOutputType[P]>
            : GetScalarType<T[P], InfractionGroupByOutputType[P]>
        }
      >
    >


  export type InfractionSelect<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    severity?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    reportedBy?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ReportedBy?: boolean | Infraction$ReportedByArgs<ExtArgs>
    ApprovedBy?: boolean | Infraction$ApprovedByArgs<ExtArgs>
  }, ExtArgs["result"]["infraction"]>

  export type InfractionSelectCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = $Extensions.GetSelect<{
    id?: boolean
    employeeId?: boolean
    type?: boolean
    severity?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    reportedBy?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ReportedBy?: boolean | Infraction$ReportedByArgs<ExtArgs>
    ApprovedBy?: boolean | Infraction$ApprovedByArgs<ExtArgs>
  }, ExtArgs["result"]["infraction"]>

  export type InfractionSelectScalar = {
    id?: boolean
    employeeId?: boolean
    type?: boolean
    severity?: boolean
    amount?: boolean
    description?: boolean
    date?: boolean
    reportedBy?: boolean
    status?: boolean
    approvedBy?: boolean
    approvedAt?: boolean
    notes?: boolean
    createdAt?: boolean
    updatedAt?: boolean
  }

  export type InfractionInclude<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ReportedBy?: boolean | Infraction$ReportedByArgs<ExtArgs>
    ApprovedBy?: boolean | Infraction$ApprovedByArgs<ExtArgs>
  }
  export type InfractionIncludeCreateManyAndReturn<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    Employee?: boolean | EmployeeDefaultArgs<ExtArgs>
    ReportedBy?: boolean | Infraction$ReportedByArgs<ExtArgs>
    ApprovedBy?: boolean | Infraction$ApprovedByArgs<ExtArgs>
  }

  export type $InfractionPayload<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    name: "Infraction"
    objects: {
      Employee: Prisma.$EmployeePayload<ExtArgs>
      ReportedBy: Prisma.$UserPayload<ExtArgs> | null
      ApprovedBy: Prisma.$UserPayload<ExtArgs> | null
    }
    scalars: $Extensions.GetPayloadResult<{
      id: string
      employeeId: string
      type: string
      severity: string
      amount: number | null
      description: string
      date: Date
      reportedBy: string | null
      status: string
      approvedBy: string | null
      approvedAt: Date | null
      notes: string | null
      createdAt: Date
      updatedAt: Date
    }, ExtArgs["result"]["infraction"]>
    composites: {}
  }

  type InfractionGetPayload<S extends boolean | null | undefined | InfractionDefaultArgs> = $Result.GetResult<Prisma.$InfractionPayload, S>

  type InfractionCountArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = 
    Omit<InfractionFindManyArgs, 'select' | 'include' | 'distinct'> & {
      select?: InfractionCountAggregateInputType | true
    }

  export interface InfractionDelegate<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> {
    [K: symbol]: { types: Prisma.TypeMap<ExtArgs>['model']['Infraction'], meta: { name: 'Infraction' } }
    /**
     * Find zero or one Infraction that matches the filter.
     * @param {InfractionFindUniqueArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findUnique({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUnique<T extends InfractionFindUniqueArgs>(args: SelectSubset<T, InfractionFindUniqueArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findUnique"> | null, null, ExtArgs>

    /**
     * Find one Infraction that matches the filter or throw an error with `error.code='P2025'` 
     * if no matches were found.
     * @param {InfractionFindUniqueOrThrowArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findUniqueOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findUniqueOrThrow<T extends InfractionFindUniqueOrThrowArgs>(args: SelectSubset<T, InfractionFindUniqueOrThrowArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findUniqueOrThrow">, never, ExtArgs>

    /**
     * Find the first Infraction that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindFirstArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findFirst({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirst<T extends InfractionFindFirstArgs>(args?: SelectSubset<T, InfractionFindFirstArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findFirst"> | null, null, ExtArgs>

    /**
     * Find the first Infraction that matches the filter or
     * throw `PrismaKnownClientError` with `P2025` code if no matches were found.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindFirstOrThrowArgs} args - Arguments to find a Infraction
     * @example
     * // Get one Infraction
     * const infraction = await prisma.infraction.findFirstOrThrow({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     */
    findFirstOrThrow<T extends InfractionFindFirstOrThrowArgs>(args?: SelectSubset<T, InfractionFindFirstOrThrowArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findFirstOrThrow">, never, ExtArgs>

    /**
     * Find zero or more Infractions that matches the filter.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionFindManyArgs} args - Arguments to filter and select certain fields only.
     * @example
     * // Get all Infractions
     * const infractions = await prisma.infraction.findMany()
     * 
     * // Get first 10 Infractions
     * const infractions = await prisma.infraction.findMany({ take: 10 })
     * 
     * // Only select the `id`
     * const infractionWithIdOnly = await prisma.infraction.findMany({ select: { id: true } })
     * 
     */
    findMany<T extends InfractionFindManyArgs>(args?: SelectSubset<T, InfractionFindManyArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "findMany">>

    /**
     * Create a Infraction.
     * @param {InfractionCreateArgs} args - Arguments to create a Infraction.
     * @example
     * // Create one Infraction
     * const Infraction = await prisma.infraction.create({
     *   data: {
     *     // ... data to create a Infraction
     *   }
     * })
     * 
     */
    create<T extends InfractionCreateArgs>(args: SelectSubset<T, InfractionCreateArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "create">, never, ExtArgs>

    /**
     * Create many Infractions.
     * @param {InfractionCreateManyArgs} args - Arguments to create many Infractions.
     * @example
     * // Create many Infractions
     * const infraction = await prisma.infraction.createMany({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     *     
     */
    createMany<T extends InfractionCreateManyArgs>(args?: SelectSubset<T, InfractionCreateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create many Infractions and returns the data saved in the database.
     * @param {InfractionCreateManyAndReturnArgs} args - Arguments to create many Infractions.
     * @example
     * // Create many Infractions
     * const infraction = await prisma.infraction.createManyAndReturn({
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * 
     * // Create many Infractions and only return the `id`
     * const infractionWithIdOnly = await prisma.infraction.createManyAndReturn({ 
     *   select: { id: true },
     *   data: [
     *     // ... provide data here
     *   ]
     * })
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * 
     */
    createManyAndReturn<T extends InfractionCreateManyAndReturnArgs>(args?: SelectSubset<T, InfractionCreateManyAndReturnArgs<ExtArgs>>): Prisma.PrismaPromise<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "createManyAndReturn">>

    /**
     * Delete a Infraction.
     * @param {InfractionDeleteArgs} args - Arguments to delete one Infraction.
     * @example
     * // Delete one Infraction
     * const Infraction = await prisma.infraction.delete({
     *   where: {
     *     // ... filter to delete one Infraction
     *   }
     * })
     * 
     */
    delete<T extends InfractionDeleteArgs>(args: SelectSubset<T, InfractionDeleteArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "delete">, never, ExtArgs>

    /**
     * Update one Infraction.
     * @param {InfractionUpdateArgs} args - Arguments to update one Infraction.
     * @example
     * // Update one Infraction
     * const infraction = await prisma.infraction.update({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    update<T extends InfractionUpdateArgs>(args: SelectSubset<T, InfractionUpdateArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "update">, never, ExtArgs>

    /**
     * Delete zero or more Infractions.
     * @param {InfractionDeleteManyArgs} args - Arguments to filter Infractions to delete.
     * @example
     * // Delete a few Infractions
     * const { count } = await prisma.infraction.deleteMany({
     *   where: {
     *     // ... provide filter here
     *   }
     * })
     * 
     */
    deleteMany<T extends InfractionDeleteManyArgs>(args?: SelectSubset<T, InfractionDeleteManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Update zero or more Infractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionUpdateManyArgs} args - Arguments to update one or more rows.
     * @example
     * // Update many Infractions
     * const infraction = await prisma.infraction.updateMany({
     *   where: {
     *     // ... provide filter here
     *   },
     *   data: {
     *     // ... provide data here
     *   }
     * })
     * 
     */
    updateMany<T extends InfractionUpdateManyArgs>(args: SelectSubset<T, InfractionUpdateManyArgs<ExtArgs>>): Prisma.PrismaPromise<BatchPayload>

    /**
     * Create or update one Infraction.
     * @param {InfractionUpsertArgs} args - Arguments to update or create a Infraction.
     * @example
     * // Update or create a Infraction
     * const infraction = await prisma.infraction.upsert({
     *   create: {
     *     // ... data to create a Infraction
     *   },
     *   update: {
     *     // ... in case it already exists, update
     *   },
     *   where: {
     *     // ... the filter for the Infraction we want to update
     *   }
     * })
     */
    upsert<T extends InfractionUpsertArgs>(args: SelectSubset<T, InfractionUpsertArgs<ExtArgs>>): Prisma__InfractionClient<$Result.GetResult<Prisma.$InfractionPayload<ExtArgs>, T, "upsert">, never, ExtArgs>


    /**
     * Count the number of Infractions.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionCountArgs} args - Arguments to filter Infractions to count.
     * @example
     * // Count the number of Infractions
     * const count = await prisma.infraction.count({
     *   where: {
     *     // ... the filter for the Infractions we want to count
     *   }
     * })
    **/
    count<T extends InfractionCountArgs>(
      args?: Subset<T, InfractionCountArgs>,
    ): Prisma.PrismaPromise<
      T extends $Utils.Record<'select', any>
        ? T['select'] extends true
          ? number
          : GetScalarType<T['select'], InfractionCountAggregateOutputType>
        : number
    >

    /**
     * Allows you to perform aggregations operations on a Infraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionAggregateArgs} args - Select which aggregations you would like to apply and on what fields.
     * @example
     * // Ordered by age ascending
     * // Where email contains prisma.io
     * // Limited to the 10 users
     * const aggregations = await prisma.user.aggregate({
     *   _avg: {
     *     age: true,
     *   },
     *   where: {
     *     email: {
     *       contains: "prisma.io",
     *     },
     *   },
     *   orderBy: {
     *     age: "asc",
     *   },
     *   take: 10,
     * })
    **/
    aggregate<T extends InfractionAggregateArgs>(args: Subset<T, InfractionAggregateArgs>): Prisma.PrismaPromise<GetInfractionAggregateType<T>>

    /**
     * Group by Infraction.
     * Note, that providing `undefined` is treated as the value not being there.
     * Read more here: https://pris.ly/d/null-undefined
     * @param {InfractionGroupByArgs} args - Group by arguments.
     * @example
     * // Group by city, order by createdAt, get count
     * const result = await prisma.user.groupBy({
     *   by: ['city', 'createdAt'],
     *   orderBy: {
     *     createdAt: true
     *   },
     *   _count: {
     *     _all: true
     *   },
     * })
     * 
    **/
    groupBy<
      T extends InfractionGroupByArgs,
      HasSelectOrTake extends Or<
        Extends<'skip', Keys<T>>,
        Extends<'take', Keys<T>>
      >,
      OrderByArg extends True extends HasSelectOrTake
        ? { orderBy: InfractionGroupByArgs['orderBy'] }
        : { orderBy?: InfractionGroupByArgs['orderBy'] },
      OrderFields extends ExcludeUnderscoreKeys<Keys<MaybeTupleToUnion<T['orderBy']>>>,
      ByFields extends MaybeTupleToUnion<T['by']>,
      ByValid extends Has<ByFields, OrderFields>,
      HavingFields extends GetHavingFields<T['having']>,
      HavingValid extends Has<ByFields, HavingFields>,
      ByEmpty extends T['by'] extends never[] ? True : False,
      InputErrors extends ByEmpty extends True
      ? `Error: "by" must not be empty.`
      : HavingValid extends False
      ? {
          [P in HavingFields]: P extends ByFields
            ? never
            : P extends string
            ? `Error: Field "${P}" used in "having" needs to be provided in "by".`
            : [
                Error,
                'Field ',
                P,
                ` in "having" needs to be provided in "by"`,
              ]
        }[HavingFields]
      : 'take' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "take", you also need to provide "orderBy"'
      : 'skip' extends Keys<T>
      ? 'orderBy' extends Keys<T>
        ? ByValid extends True
          ? {}
          : {
              [P in OrderFields]: P extends ByFields
                ? never
                : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
            }[OrderFields]
        : 'Error: If you provide "skip", you also need to provide "orderBy"'
      : ByValid extends True
      ? {}
      : {
          [P in OrderFields]: P extends ByFields
            ? never
            : `Error: Field "${P}" in "orderBy" needs to be provided in "by"`
        }[OrderFields]
    >(args: SubsetIntersection<T, InfractionGroupByArgs, OrderByArg> & InputErrors): {} extends InputErrors ? GetInfractionGroupByPayload<T> : Prisma.PrismaPromise<InputErrors>
  /**
   * Fields of the Infraction model
   */
  readonly fields: InfractionFieldRefs;
  }

  /**
   * The delegate class that acts as a "Promise-like" for Infraction.
   * Why is this prefixed with `Prisma__`?
   * Because we want to prevent naming conflicts as mentioned in
   * https://github.com/prisma/prisma-client-js/issues/707
   */
  export interface Prisma__InfractionClient<T, Null = never, ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> extends Prisma.PrismaPromise<T> {
    readonly [Symbol.toStringTag]: "PrismaPromise"
    Employee<T extends EmployeeDefaultArgs<ExtArgs> = {}>(args?: Subset<T, EmployeeDefaultArgs<ExtArgs>>): Prisma__EmployeeClient<$Result.GetResult<Prisma.$EmployeePayload<ExtArgs>, T, "findUniqueOrThrow"> | Null, Null, ExtArgs>
    ReportedBy<T extends Infraction$ReportedByArgs<ExtArgs> = {}>(args?: Subset<T, Infraction$ReportedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    ApprovedBy<T extends Infraction$ApprovedByArgs<ExtArgs> = {}>(args?: Subset<T, Infraction$ApprovedByArgs<ExtArgs>>): Prisma__UserClient<$Result.GetResult<Prisma.$UserPayload<ExtArgs>, T, "findUniqueOrThrow"> | null, null, ExtArgs>
    /**
     * Attaches callbacks for the resolution and/or rejection of the Promise.
     * @param onfulfilled The callback to execute when the Promise is resolved.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of which ever callback is executed.
     */
    then<TResult1 = T, TResult2 = never>(onfulfilled?: ((value: T) => TResult1 | PromiseLike<TResult1>) | undefined | null, onrejected?: ((reason: any) => TResult2 | PromiseLike<TResult2>) | undefined | null): $Utils.JsPromise<TResult1 | TResult2>
    /**
     * Attaches a callback for only the rejection of the Promise.
     * @param onrejected The callback to execute when the Promise is rejected.
     * @returns A Promise for the completion of the callback.
     */
    catch<TResult = never>(onrejected?: ((reason: any) => TResult | PromiseLike<TResult>) | undefined | null): $Utils.JsPromise<T | TResult>
    /**
     * Attaches a callback that is invoked when the Promise is settled (fulfilled or rejected). The
     * resolved value cannot be modified from the callback.
     * @param onfinally The callback to execute when the Promise is settled (fulfilled or rejected).
     * @returns A Promise for the completion of the callback.
     */
    finally(onfinally?: (() => void) | undefined | null): $Utils.JsPromise<T>
  }




  /**
   * Fields of the Infraction model
   */ 
  interface InfractionFieldRefs {
    readonly id: FieldRef<"Infraction", 'String'>
    readonly employeeId: FieldRef<"Infraction", 'String'>
    readonly type: FieldRef<"Infraction", 'String'>
    readonly severity: FieldRef<"Infraction", 'String'>
    readonly amount: FieldRef<"Infraction", 'Float'>
    readonly description: FieldRef<"Infraction", 'String'>
    readonly date: FieldRef<"Infraction", 'DateTime'>
    readonly reportedBy: FieldRef<"Infraction", 'String'>
    readonly status: FieldRef<"Infraction", 'String'>
    readonly approvedBy: FieldRef<"Infraction", 'String'>
    readonly approvedAt: FieldRef<"Infraction", 'DateTime'>
    readonly notes: FieldRef<"Infraction", 'String'>
    readonly createdAt: FieldRef<"Infraction", 'DateTime'>
    readonly updatedAt: FieldRef<"Infraction", 'DateTime'>
  }
    

  // Custom InputTypes
  /**
   * Infraction findUnique
   */
  export type InfractionFindUniqueArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction findUniqueOrThrow
   */
  export type InfractionFindUniqueOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction findFirst
   */
  export type InfractionFindFirstArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Infractions.
     */
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction findFirstOrThrow
   */
  export type InfractionFindFirstOrThrowArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infraction to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for searching for Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/distinct Distinct Docs}
     * 
     * Filter by unique combinations of Infractions.
     */
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction findMany
   */
  export type InfractionFindManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter, which Infractions to fetch.
     */
    where?: InfractionWhereInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/sorting Sorting Docs}
     * 
     * Determine the order of Infractions to fetch.
     */
    orderBy?: InfractionOrderByWithRelationInput | InfractionOrderByWithRelationInput[]
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination#cursor-based-pagination Cursor Docs}
     * 
     * Sets the position for listing Infractions.
     */
    cursor?: InfractionWhereUniqueInput
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Take `±n` Infractions from the position of the cursor.
     */
    take?: number
    /**
     * {@link https://www.prisma.io/docs/concepts/components/prisma-client/pagination Pagination Docs}
     * 
     * Skip the first `n` Infractions.
     */
    skip?: number
    distinct?: InfractionScalarFieldEnum | InfractionScalarFieldEnum[]
  }

  /**
   * Infraction create
   */
  export type InfractionCreateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The data needed to create a Infraction.
     */
    data: XOR<InfractionCreateInput, InfractionUncheckedCreateInput>
  }

  /**
   * Infraction createMany
   */
  export type InfractionCreateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to create many Infractions.
     */
    data: InfractionCreateManyInput | InfractionCreateManyInput[]
    skipDuplicates?: boolean
  }

  /**
   * Infraction createManyAndReturn
   */
  export type InfractionCreateManyAndReturnArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelectCreateManyAndReturn<ExtArgs> | null
    /**
     * The data used to create many Infractions.
     */
    data: InfractionCreateManyInput | InfractionCreateManyInput[]
    skipDuplicates?: boolean
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionIncludeCreateManyAndReturn<ExtArgs> | null
  }

  /**
   * Infraction update
   */
  export type InfractionUpdateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The data needed to update a Infraction.
     */
    data: XOR<InfractionUpdateInput, InfractionUncheckedUpdateInput>
    /**
     * Choose, which Infraction to update.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction updateMany
   */
  export type InfractionUpdateManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * The data used to update Infractions.
     */
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyInput>
    /**
     * Filter which Infractions to update
     */
    where?: InfractionWhereInput
  }

  /**
   * Infraction upsert
   */
  export type InfractionUpsertArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * The filter to search for the Infraction to update in case it exists.
     */
    where: InfractionWhereUniqueInput
    /**
     * In case the Infraction found by the `where` argument doesn't exist, create a new Infraction with this data.
     */
    create: XOR<InfractionCreateInput, InfractionUncheckedCreateInput>
    /**
     * In case the Infraction was found with the provided `where` argument, update it with this data.
     */
    update: XOR<InfractionUpdateInput, InfractionUncheckedUpdateInput>
  }

  /**
   * Infraction delete
   */
  export type InfractionDeleteArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
    /**
     * Filter which Infraction to delete.
     */
    where: InfractionWhereUniqueInput
  }

  /**
   * Infraction deleteMany
   */
  export type InfractionDeleteManyArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Filter which Infractions to delete
     */
    where?: InfractionWhereInput
  }

  /**
   * Infraction.ReportedBy
   */
  export type Infraction$ReportedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Infraction.ApprovedBy
   */
  export type Infraction$ApprovedByArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the User
     */
    select?: UserSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: UserInclude<ExtArgs> | null
    where?: UserWhereInput
  }

  /**
   * Infraction without action
   */
  export type InfractionDefaultArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = {
    /**
     * Select specific fields to fetch from the Infraction
     */
    select?: InfractionSelect<ExtArgs> | null
    /**
     * Choose, which related nodes to fetch as well
     */
    include?: InfractionInclude<ExtArgs> | null
  }


  /**
   * Enums
   */

  export const TransactionIsolationLevel: {
    ReadUncommitted: 'ReadUncommitted',
    ReadCommitted: 'ReadCommitted',
    RepeatableRead: 'RepeatableRead',
    Serializable: 'Serializable'
  };

  export type TransactionIsolationLevel = (typeof TransactionIsolationLevel)[keyof typeof TransactionIsolationLevel]


  export const UserScalarFieldEnum: {
    id: 'id',
    email: 'email',
    password: 'password',
    firstName: 'firstName',
    lastName: 'lastName',
    role: 'role',
    permissions: 'permissions',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type UserScalarFieldEnum = (typeof UserScalarFieldEnum)[keyof typeof UserScalarFieldEnum]


  export const DepartmentScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    managerId: 'managerId',
    color: 'color',
    budget: 'budget',
    isActive: 'isActive',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type DepartmentScalarFieldEnum = (typeof DepartmentScalarFieldEnum)[keyof typeof DepartmentScalarFieldEnum]


  export const ShiftScalarFieldEnum: {
    id: 'id',
    name: 'name',
    description: 'description',
    startTime: 'startTime',
    endTime: 'endTime',
    breakDuration: 'breakDuration',
    graceMinutes: 'graceMinutes',
    overtimeAfter: 'overtimeAfter',
    workingDays: 'workingDays',
    color: 'color',
    isNightShift: 'isNightShift',
    isActive: 'isActive',
    createdById: 'createdById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type ShiftScalarFieldEnum = (typeof ShiftScalarFieldEnum)[keyof typeof ShiftScalarFieldEnum]


  export const EmployeeScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    firstName: 'firstName',
    lastName: 'lastName',
    email: 'email',
    phone: 'phone',
    photo: 'photo',
    departmentId: 'departmentId',
    designation: 'designation',
    managerId: 'managerId',
    joinDate: 'joinDate',
    employmentType: 'employmentType',
    status: 'status',
    shiftId: 'shiftId',
    salary: 'salary',
    hourlyRate: 'hourlyRate',
    cardNumber: 'cardNumber',
    faceEnrolled: 'faceEnrolled',
    fingerprintEnrolled: 'fingerprintEnrolled',
    fingerprintTemplate: 'fingerprintTemplate',
    fingerprintTemplateDate: 'fingerprintTemplateDate',
    userId: 'userId',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeScalarFieldEnum = (typeof EmployeeScalarFieldEnum)[keyof typeof EmployeeScalarFieldEnum]


  export const InactiveEmployeeScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    employeeName: 'employeeName',
    departmentId: 'departmentId',
    inactiveReason: 'inactiveReason',
    details: 'details',
    suspendedBy: 'suspendedBy',
    suspendedAt: 'suspendedAt',
    reactivatedAt: 'reactivatedAt',
    reactivatedBy: 'reactivatedBy',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InactiveEmployeeScalarFieldEnum = (typeof InactiveEmployeeScalarFieldEnum)[keyof typeof InactiveEmployeeScalarFieldEnum]


  export const AuditLogScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    action: 'action',
    entityType: 'entityType',
    entityId: 'entityId',
    oldValue: 'oldValue',
    newValue: 'newValue',
    ipAddress: 'ipAddress',
    userAgent: 'userAgent',
    createdAt: 'createdAt'
  };

  export type AuditLogScalarFieldEnum = (typeof AuditLogScalarFieldEnum)[keyof typeof AuditLogScalarFieldEnum]


  export const AttendanceLogScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    eventType: 'eventType',
    timestamp: 'timestamp',
    terminalId: 'terminalId',
    verifyMethod: 'verifyMethod',
    snapshot: 'snapshot',
    temperature: 'temperature',
    maskDetected: 'maskDetected',
    processed: 'processed',
    rawData: 'rawData',
    createdAt: 'createdAt'
  };

  export type AttendanceLogScalarFieldEnum = (typeof AttendanceLogScalarFieldEnum)[keyof typeof AttendanceLogScalarFieldEnum]


  export const BiometricDataScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    type: 'type',
    data: 'data',
    fingerNo: 'fingerNo',
    enrolledAt: 'enrolledAt'
  };

  export type BiometricDataScalarFieldEnum = (typeof BiometricDataScalarFieldEnum)[keyof typeof BiometricDataScalarFieldEnum]


  export const LeaveBalanceScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    year: 'year',
    totalDays: 'totalDays',
    usedDays: 'usedDays',
    remainingDays: 'remainingDays'
  };

  export type LeaveBalanceScalarFieldEnum = (typeof LeaveBalanceScalarFieldEnum)[keyof typeof LeaveBalanceScalarFieldEnum]


  export const LeaveRequestScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    leaveType: 'leaveType',
    startDate: 'startDate',
    endDate: 'endDate',
    totalDays: 'totalDays',
    reason: 'reason',
    status: 'status',
    approvedById: 'approvedById',
    approvedAt: 'approvedAt',
    rejectionReason: 'rejectionReason',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type LeaveRequestScalarFieldEnum = (typeof LeaveRequestScalarFieldEnum)[keyof typeof LeaveRequestScalarFieldEnum]


  export const NotificationScalarFieldEnum: {
    id: 'id',
    userId: 'userId',
    employeeId: 'employeeId',
    type: 'type',
    title: 'title',
    message: 'message',
    isRead: 'isRead',
    data: 'data',
    createdAt: 'createdAt'
  };

  export type NotificationScalarFieldEnum = (typeof NotificationScalarFieldEnum)[keyof typeof NotificationScalarFieldEnum]


  export const SettingScalarFieldEnum: {
    id: 'id',
    key: 'key',
    value: 'value',
    description: 'description',
    category: 'category',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type SettingScalarFieldEnum = (typeof SettingScalarFieldEnum)[keyof typeof SettingScalarFieldEnum]


  export const ShiftAssignmentScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    shiftId: 'shiftId',
    startDate: 'startDate',
    endDate: 'endDate',
    isActive: 'isActive',
    assignedById: 'assignedById',
    createdAt: 'createdAt'
  };

  export type ShiftAssignmentScalarFieldEnum = (typeof ShiftAssignmentScalarFieldEnum)[keyof typeof ShiftAssignmentScalarFieldEnum]


  export const TerminalScalarFieldEnum: {
    id: 'id',
    name: 'name',
    ipAddress: 'ipAddress',
    port: 'port',
    username: 'username',
    password: 'password',
    deviceType: 'deviceType',
    serialNumber: 'serialNumber',
    firmwareVersion: 'firmwareVersion',
    location: 'location',
    isOnline: 'isOnline',
    lastSyncAt: 'lastSyncAt',
    isActive: 'isActive',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TerminalScalarFieldEnum = (typeof TerminalScalarFieldEnum)[keyof typeof TerminalScalarFieldEnum]


  export const TimeEntryScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    clockIn: 'clockIn',
    clockOut: 'clockOut',
    breakStart: 'breakStart',
    breakEnd: 'breakEnd',
    totalHours: 'totalHours',
    regularHours: 'regularHours',
    overtimeHours: 'overtimeHours',
    breakMinutes: 'breakMinutes',
    status: 'status',
    location: 'location',
    terminalId: 'terminalId',
    verifyMethod: 'verifyMethod',
    clockInPhoto: 'clockInPhoto',
    clockOutPhoto: 'clockOutPhoto',
    notes: 'notes',
    isManualEntry: 'isManualEntry',
    approvedById: 'approvedById',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type TimeEntryScalarFieldEnum = (typeof TimeEntryScalarFieldEnum)[keyof typeof TimeEntryScalarFieldEnum]


  export const EmployeeRateScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    hourlyRate: 'hourlyRate',
    dailyRate: 'dailyRate',
    salary: 'salary',
    overtimeRate: 'overtimeRate',
    effectiveFrom: 'effectiveFrom',
    effectiveTo: 'effectiveTo',
    currency: 'currency',
    rateType: 'rateType',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type EmployeeRateScalarFieldEnum = (typeof EmployeeRateScalarFieldEnum)[keyof typeof EmployeeRateScalarFieldEnum]


  export const PayrollDeductionScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    deductionType: 'deductionType',
    amount: 'amount',
    reason: 'reason',
    description: 'description',
    month: 'month',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    appliedAt: 'appliedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type PayrollDeductionScalarFieldEnum = (typeof PayrollDeductionScalarFieldEnum)[keyof typeof PayrollDeductionScalarFieldEnum]


  export const InfractionScalarFieldEnum: {
    id: 'id',
    employeeId: 'employeeId',
    type: 'type',
    severity: 'severity',
    amount: 'amount',
    description: 'description',
    date: 'date',
    reportedBy: 'reportedBy',
    status: 'status',
    approvedBy: 'approvedBy',
    approvedAt: 'approvedAt',
    notes: 'notes',
    createdAt: 'createdAt',
    updatedAt: 'updatedAt'
  };

  export type InfractionScalarFieldEnum = (typeof InfractionScalarFieldEnum)[keyof typeof InfractionScalarFieldEnum]


  export const SortOrder: {
    asc: 'asc',
    desc: 'desc'
  };

  export type SortOrder = (typeof SortOrder)[keyof typeof SortOrder]


  export const QueryMode: {
    default: 'default',
    insensitive: 'insensitive'
  };

  export type QueryMode = (typeof QueryMode)[keyof typeof QueryMode]


  export const NullsOrder: {
    first: 'first',
    last: 'last'
  };

  export type NullsOrder = (typeof NullsOrder)[keyof typeof NullsOrder]


  /**
   * Field references 
   */


  /**
   * Reference to a field of type 'String'
   */
  export type StringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String'>
    


  /**
   * Reference to a field of type 'String[]'
   */
  export type ListStringFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'String[]'>
    


  /**
   * Reference to a field of type 'Boolean'
   */
  export type BooleanFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Boolean'>
    


  /**
   * Reference to a field of type 'DateTime'
   */
  export type DateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime'>
    


  /**
   * Reference to a field of type 'DateTime[]'
   */
  export type ListDateTimeFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'DateTime[]'>
    


  /**
   * Reference to a field of type 'Float'
   */
  export type FloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float'>
    


  /**
   * Reference to a field of type 'Float[]'
   */
  export type ListFloatFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Float[]'>
    


  /**
   * Reference to a field of type 'Int'
   */
  export type IntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int'>
    


  /**
   * Reference to a field of type 'Int[]'
   */
  export type ListIntFieldRefInput<$PrismaModel> = FieldRefInputType<$PrismaModel, 'Int[]'>
    
  /**
   * Deep Input Types
   */


  export type UserWhereInput = {
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    id?: StringFilter<"User"> | string
    email?: StringFilter<"User"> | string
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    permissions?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    AuditLog?: AuditLogListRelationFilter
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    LeaveRequest?: LeaveRequestListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
    DepartmentsCreated?: DepartmentListRelationFilter
    ShiftsCreated?: ShiftListRelationFilter
    ShiftAssignmentsCreated?: ShiftAssignmentListRelationFilter
    DeductionApprovals?: PayrollDeductionListRelationFilter
    InfractionReports?: InfractionListRelationFilter
    InfractionApprovals?: InfractionListRelationFilter
  }

  export type UserOrderByWithRelationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AuditLog?: AuditLogOrderByRelationAggregateInput
    Employee?: EmployeeOrderByWithRelationInput
    LeaveRequest?: LeaveRequestOrderByRelationAggregateInput
    TimeEntry?: TimeEntryOrderByRelationAggregateInput
    DepartmentsCreated?: DepartmentOrderByRelationAggregateInput
    ShiftsCreated?: ShiftOrderByRelationAggregateInput
    ShiftAssignmentsCreated?: ShiftAssignmentOrderByRelationAggregateInput
    DeductionApprovals?: PayrollDeductionOrderByRelationAggregateInput
    InfractionReports?: InfractionOrderByRelationAggregateInput
    InfractionApprovals?: InfractionOrderByRelationAggregateInput
  }

  export type UserWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    email?: string
    AND?: UserWhereInput | UserWhereInput[]
    OR?: UserWhereInput[]
    NOT?: UserWhereInput | UserWhereInput[]
    password?: StringFilter<"User"> | string
    firstName?: StringFilter<"User"> | string
    lastName?: StringFilter<"User"> | string
    role?: StringFilter<"User"> | string
    permissions?: StringFilter<"User"> | string
    isActive?: BoolFilter<"User"> | boolean
    createdAt?: DateTimeFilter<"User"> | Date | string
    updatedAt?: DateTimeFilter<"User"> | Date | string
    AuditLog?: AuditLogListRelationFilter
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    LeaveRequest?: LeaveRequestListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
    DepartmentsCreated?: DepartmentListRelationFilter
    ShiftsCreated?: ShiftListRelationFilter
    ShiftAssignmentsCreated?: ShiftAssignmentListRelationFilter
    DeductionApprovals?: PayrollDeductionListRelationFilter
    InfractionReports?: InfractionListRelationFilter
    InfractionApprovals?: InfractionListRelationFilter
  }, "id" | "email">

  export type UserOrderByWithAggregationInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: UserCountOrderByAggregateInput
    _max?: UserMaxOrderByAggregateInput
    _min?: UserMinOrderByAggregateInput
  }

  export type UserScalarWhereWithAggregatesInput = {
    AND?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    OR?: UserScalarWhereWithAggregatesInput[]
    NOT?: UserScalarWhereWithAggregatesInput | UserScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"User"> | string
    email?: StringWithAggregatesFilter<"User"> | string
    password?: StringWithAggregatesFilter<"User"> | string
    firstName?: StringWithAggregatesFilter<"User"> | string
    lastName?: StringWithAggregatesFilter<"User"> | string
    role?: StringWithAggregatesFilter<"User"> | string
    permissions?: StringWithAggregatesFilter<"User"> | string
    isActive?: BoolWithAggregatesFilter<"User"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"User"> | Date | string
  }

  export type DepartmentWhereInput = {
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    color?: StringNullableFilter<"Department"> | string | null
    budget?: FloatNullableFilter<"Department"> | number | null
    isActive?: BoolFilter<"Department"> | boolean
    createdById?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    CreatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    employees?: EmployeeListRelationFilter
  }

  export type DepartmentOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CreatedBy?: UserOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
  }

  export type DepartmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    name?: string
    AND?: DepartmentWhereInput | DepartmentWhereInput[]
    OR?: DepartmentWhereInput[]
    NOT?: DepartmentWhereInput | DepartmentWhereInput[]
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    color?: StringNullableFilter<"Department"> | string | null
    budget?: FloatNullableFilter<"Department"> | number | null
    isActive?: BoolFilter<"Department"> | boolean
    createdById?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
    CreatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    employees?: EmployeeListRelationFilter
  }, "id" | "name">

  export type DepartmentOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    color?: SortOrderInput | SortOrder
    budget?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: DepartmentCountOrderByAggregateInput
    _avg?: DepartmentAvgOrderByAggregateInput
    _max?: DepartmentMaxOrderByAggregateInput
    _min?: DepartmentMinOrderByAggregateInput
    _sum?: DepartmentSumOrderByAggregateInput
  }

  export type DepartmentScalarWhereWithAggregatesInput = {
    AND?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    OR?: DepartmentScalarWhereWithAggregatesInput[]
    NOT?: DepartmentScalarWhereWithAggregatesInput | DepartmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Department"> | string
    name?: StringWithAggregatesFilter<"Department"> | string
    description?: StringNullableWithAggregatesFilter<"Department"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Department"> | string | null
    color?: StringNullableWithAggregatesFilter<"Department"> | string | null
    budget?: FloatNullableWithAggregatesFilter<"Department"> | number | null
    isActive?: BoolWithAggregatesFilter<"Department"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"Department"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Department"> | Date | string
  }

  export type ShiftWhereInput = {
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    description?: StringNullableFilter<"Shift"> | string | null
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    breakDuration?: IntFilter<"Shift"> | number
    graceMinutes?: IntFilter<"Shift"> | number
    overtimeAfter?: FloatFilter<"Shift"> | number
    workingDays?: StringFilter<"Shift"> | string
    color?: StringNullableFilter<"Shift"> | string | null
    isNightShift?: BoolFilter<"Shift"> | boolean
    isActive?: BoolFilter<"Shift"> | boolean
    createdById?: StringNullableFilter<"Shift"> | string | null
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    CreatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    employees?: EmployeeListRelationFilter
    ShiftAssignment?: ShiftAssignmentListRelationFilter
  }

  export type ShiftOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
    workingDays?: SortOrder
    color?: SortOrderInput | SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    CreatedBy?: UserOrderByWithRelationInput
    employees?: EmployeeOrderByRelationAggregateInput
    ShiftAssignment?: ShiftAssignmentOrderByRelationAggregateInput
  }

  export type ShiftWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftWhereInput | ShiftWhereInput[]
    OR?: ShiftWhereInput[]
    NOT?: ShiftWhereInput | ShiftWhereInput[]
    name?: StringFilter<"Shift"> | string
    description?: StringNullableFilter<"Shift"> | string | null
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    breakDuration?: IntFilter<"Shift"> | number
    graceMinutes?: IntFilter<"Shift"> | number
    overtimeAfter?: FloatFilter<"Shift"> | number
    workingDays?: StringFilter<"Shift"> | string
    color?: StringNullableFilter<"Shift"> | string | null
    isNightShift?: BoolFilter<"Shift"> | boolean
    isActive?: BoolFilter<"Shift"> | boolean
    createdById?: StringNullableFilter<"Shift"> | string | null
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
    CreatedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    employees?: EmployeeListRelationFilter
    ShiftAssignment?: ShiftAssignmentListRelationFilter
  }, "id">

  export type ShiftOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrderInput | SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
    workingDays?: SortOrder
    color?: SortOrderInput | SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: ShiftCountOrderByAggregateInput
    _avg?: ShiftAvgOrderByAggregateInput
    _max?: ShiftMaxOrderByAggregateInput
    _min?: ShiftMinOrderByAggregateInput
    _sum?: ShiftSumOrderByAggregateInput
  }

  export type ShiftScalarWhereWithAggregatesInput = {
    AND?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    OR?: ShiftScalarWhereWithAggregatesInput[]
    NOT?: ShiftScalarWhereWithAggregatesInput | ShiftScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Shift"> | string
    name?: StringWithAggregatesFilter<"Shift"> | string
    description?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    startTime?: StringWithAggregatesFilter<"Shift"> | string
    endTime?: StringWithAggregatesFilter<"Shift"> | string
    breakDuration?: IntWithAggregatesFilter<"Shift"> | number
    graceMinutes?: IntWithAggregatesFilter<"Shift"> | number
    overtimeAfter?: FloatWithAggregatesFilter<"Shift"> | number
    workingDays?: StringWithAggregatesFilter<"Shift"> | string
    color?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    isNightShift?: BoolWithAggregatesFilter<"Shift"> | boolean
    isActive?: BoolWithAggregatesFilter<"Shift"> | boolean
    createdById?: StringNullableWithAggregatesFilter<"Shift"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Shift"> | Date | string
  }

  export type EmployeeWhereInput = {
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    photo?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designation?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeFilter<"Employee"> | Date | string
    employmentType?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    shiftId?: StringNullableFilter<"Employee"> | string | null
    salary?: FloatNullableFilter<"Employee"> | number | null
    hourlyRate?: FloatNullableFilter<"Employee"> | number | null
    cardNumber?: StringNullableFilter<"Employee"> | string | null
    faceEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintTemplate?: StringNullableFilter<"Employee"> | string | null
    fingerprintTemplateDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    userId?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    AttendanceLog?: AttendanceLogListRelationFilter
    BiometricData?: BiometricDataListRelationFilter
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    other_Employee?: EmployeeListRelationFilter
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    LeaveBalance?: LeaveBalanceListRelationFilter
    LeaveRequest?: LeaveRequestListRelationFilter
    Notification?: NotificationListRelationFilter
    ShiftAssignment?: ShiftAssignmentListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
    EmployeeRate?: XOR<EmployeeRateNullableRelationFilter, EmployeeRateWhereInput> | null
    EmployeeDeductions?: PayrollDeductionListRelationFilter
    EmployeeInfractions?: InfractionListRelationFilter
  }

  export type EmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    status?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    faceEnrolled?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintTemplate?: SortOrderInput | SortOrder
    fingerprintTemplateDate?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AttendanceLog?: AttendanceLogOrderByRelationAggregateInput
    BiometricData?: BiometricDataOrderByRelationAggregateInput
    department?: DepartmentOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
    other_Employee?: EmployeeOrderByRelationAggregateInput
    shift?: ShiftOrderByWithRelationInput
    User?: UserOrderByWithRelationInput
    LeaveBalance?: LeaveBalanceOrderByRelationAggregateInput
    LeaveRequest?: LeaveRequestOrderByRelationAggregateInput
    Notification?: NotificationOrderByRelationAggregateInput
    ShiftAssignment?: ShiftAssignmentOrderByRelationAggregateInput
    TimeEntry?: TimeEntryOrderByRelationAggregateInput
    EmployeeRate?: EmployeeRateOrderByWithRelationInput
    EmployeeDeductions?: PayrollDeductionOrderByRelationAggregateInput
    EmployeeInfractions?: InfractionOrderByRelationAggregateInput
  }

  export type EmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    userId?: string
    AND?: EmployeeWhereInput | EmployeeWhereInput[]
    OR?: EmployeeWhereInput[]
    NOT?: EmployeeWhereInput | EmployeeWhereInput[]
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    photo?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designation?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeFilter<"Employee"> | Date | string
    employmentType?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    shiftId?: StringNullableFilter<"Employee"> | string | null
    salary?: FloatNullableFilter<"Employee"> | number | null
    hourlyRate?: FloatNullableFilter<"Employee"> | number | null
    cardNumber?: StringNullableFilter<"Employee"> | string | null
    faceEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintTemplate?: StringNullableFilter<"Employee"> | string | null
    fingerprintTemplateDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
    AttendanceLog?: AttendanceLogListRelationFilter
    BiometricData?: BiometricDataListRelationFilter
    department?: XOR<DepartmentNullableRelationFilter, DepartmentWhereInput> | null
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
    other_Employee?: EmployeeListRelationFilter
    shift?: XOR<ShiftNullableRelationFilter, ShiftWhereInput> | null
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    LeaveBalance?: LeaveBalanceListRelationFilter
    LeaveRequest?: LeaveRequestListRelationFilter
    Notification?: NotificationListRelationFilter
    ShiftAssignment?: ShiftAssignmentListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
    EmployeeRate?: XOR<EmployeeRateNullableRelationFilter, EmployeeRateWhereInput> | null
    EmployeeDeductions?: PayrollDeductionListRelationFilter
    EmployeeInfractions?: InfractionListRelationFilter
  }, "id" | "employeeId" | "userId">

  export type EmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrderInput | SortOrder
    phone?: SortOrderInput | SortOrder
    photo?: SortOrderInput | SortOrder
    departmentId?: SortOrderInput | SortOrder
    designation?: SortOrderInput | SortOrder
    managerId?: SortOrderInput | SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    status?: SortOrder
    shiftId?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    hourlyRate?: SortOrderInput | SortOrder
    cardNumber?: SortOrderInput | SortOrder
    faceEnrolled?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintTemplate?: SortOrderInput | SortOrder
    fingerprintTemplateDate?: SortOrderInput | SortOrder
    userId?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeCountOrderByAggregateInput
    _avg?: EmployeeAvgOrderByAggregateInput
    _max?: EmployeeMaxOrderByAggregateInput
    _min?: EmployeeMinOrderByAggregateInput
    _sum?: EmployeeSumOrderByAggregateInput
  }

  export type EmployeeScalarWhereWithAggregatesInput = {
    AND?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    OR?: EmployeeScalarWhereWithAggregatesInput[]
    NOT?: EmployeeScalarWhereWithAggregatesInput | EmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Employee"> | string
    employeeId?: StringWithAggregatesFilter<"Employee"> | string
    firstName?: StringWithAggregatesFilter<"Employee"> | string
    lastName?: StringWithAggregatesFilter<"Employee"> | string
    email?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    phone?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    photo?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    departmentId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    designation?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    managerId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    joinDate?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    employmentType?: StringWithAggregatesFilter<"Employee"> | string
    status?: StringWithAggregatesFilter<"Employee"> | string
    shiftId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    salary?: FloatNullableWithAggregatesFilter<"Employee"> | number | null
    hourlyRate?: FloatNullableWithAggregatesFilter<"Employee"> | number | null
    cardNumber?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    faceEnrolled?: BoolWithAggregatesFilter<"Employee"> | boolean
    fingerprintEnrolled?: BoolWithAggregatesFilter<"Employee"> | boolean
    fingerprintTemplate?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    fingerprintTemplateDate?: DateTimeNullableWithAggregatesFilter<"Employee"> | Date | string | null
    userId?: StringNullableWithAggregatesFilter<"Employee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Employee"> | Date | string
  }

  export type InactiveEmployeeWhereInput = {
    AND?: InactiveEmployeeWhereInput | InactiveEmployeeWhereInput[]
    OR?: InactiveEmployeeWhereInput[]
    NOT?: InactiveEmployeeWhereInput | InactiveEmployeeWhereInput[]
    id?: StringFilter<"InactiveEmployee"> | string
    employeeId?: StringFilter<"InactiveEmployee"> | string
    employeeName?: StringFilter<"InactiveEmployee"> | string
    departmentId?: StringNullableFilter<"InactiveEmployee"> | string | null
    inactiveReason?: StringFilter<"InactiveEmployee"> | string
    details?: StringNullableFilter<"InactiveEmployee"> | string | null
    suspendedBy?: StringNullableFilter<"InactiveEmployee"> | string | null
    suspendedAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
    reactivatedAt?: DateTimeNullableFilter<"InactiveEmployee"> | Date | string | null
    reactivatedBy?: StringNullableFilter<"InactiveEmployee"> | string | null
    notes?: StringNullableFilter<"InactiveEmployee"> | string | null
    createdAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
  }

  export type InactiveEmployeeOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    inactiveReason?: SortOrder
    details?: SortOrderInput | SortOrder
    suspendedBy?: SortOrderInput | SortOrder
    suspendedAt?: SortOrder
    reactivatedAt?: SortOrderInput | SortOrder
    reactivatedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InactiveEmployeeWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    AND?: InactiveEmployeeWhereInput | InactiveEmployeeWhereInput[]
    OR?: InactiveEmployeeWhereInput[]
    NOT?: InactiveEmployeeWhereInput | InactiveEmployeeWhereInput[]
    employeeName?: StringFilter<"InactiveEmployee"> | string
    departmentId?: StringNullableFilter<"InactiveEmployee"> | string | null
    inactiveReason?: StringFilter<"InactiveEmployee"> | string
    details?: StringNullableFilter<"InactiveEmployee"> | string | null
    suspendedBy?: StringNullableFilter<"InactiveEmployee"> | string | null
    suspendedAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
    reactivatedAt?: DateTimeNullableFilter<"InactiveEmployee"> | Date | string | null
    reactivatedBy?: StringNullableFilter<"InactiveEmployee"> | string | null
    notes?: StringNullableFilter<"InactiveEmployee"> | string | null
    createdAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
    updatedAt?: DateTimeFilter<"InactiveEmployee"> | Date | string
  }, "id" | "employeeId">

  export type InactiveEmployeeOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    departmentId?: SortOrderInput | SortOrder
    inactiveReason?: SortOrder
    details?: SortOrderInput | SortOrder
    suspendedBy?: SortOrderInput | SortOrder
    suspendedAt?: SortOrder
    reactivatedAt?: SortOrderInput | SortOrder
    reactivatedBy?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InactiveEmployeeCountOrderByAggregateInput
    _max?: InactiveEmployeeMaxOrderByAggregateInput
    _min?: InactiveEmployeeMinOrderByAggregateInput
  }

  export type InactiveEmployeeScalarWhereWithAggregatesInput = {
    AND?: InactiveEmployeeScalarWhereWithAggregatesInput | InactiveEmployeeScalarWhereWithAggregatesInput[]
    OR?: InactiveEmployeeScalarWhereWithAggregatesInput[]
    NOT?: InactiveEmployeeScalarWhereWithAggregatesInput | InactiveEmployeeScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"InactiveEmployee"> | string
    employeeId?: StringWithAggregatesFilter<"InactiveEmployee"> | string
    employeeName?: StringWithAggregatesFilter<"InactiveEmployee"> | string
    departmentId?: StringNullableWithAggregatesFilter<"InactiveEmployee"> | string | null
    inactiveReason?: StringWithAggregatesFilter<"InactiveEmployee"> | string
    details?: StringNullableWithAggregatesFilter<"InactiveEmployee"> | string | null
    suspendedBy?: StringNullableWithAggregatesFilter<"InactiveEmployee"> | string | null
    suspendedAt?: DateTimeWithAggregatesFilter<"InactiveEmployee"> | Date | string
    reactivatedAt?: DateTimeNullableWithAggregatesFilter<"InactiveEmployee"> | Date | string | null
    reactivatedBy?: StringNullableWithAggregatesFilter<"InactiveEmployee"> | string | null
    notes?: StringNullableWithAggregatesFilter<"InactiveEmployee"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"InactiveEmployee"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"InactiveEmployee"> | Date | string
  }

  export type AuditLogWhereInput = {
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type AuditLogOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    User?: UserOrderByWithRelationInput
  }

  export type AuditLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AuditLogWhereInput | AuditLogWhereInput[]
    OR?: AuditLogWhereInput[]
    NOT?: AuditLogWhereInput | AuditLogWhereInput[]
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type AuditLogOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrderInput | SortOrder
    oldValue?: SortOrderInput | SortOrder
    newValue?: SortOrderInput | SortOrder
    ipAddress?: SortOrderInput | SortOrder
    userAgent?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AuditLogCountOrderByAggregateInput
    _max?: AuditLogMaxOrderByAggregateInput
    _min?: AuditLogMinOrderByAggregateInput
  }

  export type AuditLogScalarWhereWithAggregatesInput = {
    AND?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    OR?: AuditLogScalarWhereWithAggregatesInput[]
    NOT?: AuditLogScalarWhereWithAggregatesInput | AuditLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AuditLog"> | string
    userId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    action?: StringWithAggregatesFilter<"AuditLog"> | string
    entityType?: StringWithAggregatesFilter<"AuditLog"> | string
    entityId?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    oldValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    newValue?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    userAgent?: StringNullableWithAggregatesFilter<"AuditLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AuditLog"> | Date | string
  }

  export type AttendanceLogWhereInput = {
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    id?: StringFilter<"AttendanceLog"> | string
    employeeId?: StringFilter<"AttendanceLog"> | string
    eventType?: StringFilter<"AttendanceLog"> | string
    timestamp?: DateTimeFilter<"AttendanceLog"> | Date | string
    terminalId?: StringNullableFilter<"AttendanceLog"> | string | null
    verifyMethod?: StringNullableFilter<"AttendanceLog"> | string | null
    snapshot?: StringNullableFilter<"AttendanceLog"> | string | null
    temperature?: FloatNullableFilter<"AttendanceLog"> | number | null
    maskDetected?: BoolNullableFilter<"AttendanceLog"> | boolean | null
    processed?: BoolFilter<"AttendanceLog"> | boolean
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Terminal?: XOR<TerminalNullableRelationFilter, TerminalWhereInput> | null
  }

  export type AttendanceLogOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    verifyMethod?: SortOrderInput | SortOrder
    snapshot?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    maskDetected?: SortOrderInput | SortOrder
    processed?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    Terminal?: TerminalOrderByWithRelationInput
  }

  export type AttendanceLogWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    OR?: AttendanceLogWhereInput[]
    NOT?: AttendanceLogWhereInput | AttendanceLogWhereInput[]
    employeeId?: StringFilter<"AttendanceLog"> | string
    eventType?: StringFilter<"AttendanceLog"> | string
    timestamp?: DateTimeFilter<"AttendanceLog"> | Date | string
    terminalId?: StringNullableFilter<"AttendanceLog"> | string | null
    verifyMethod?: StringNullableFilter<"AttendanceLog"> | string | null
    snapshot?: StringNullableFilter<"AttendanceLog"> | string | null
    temperature?: FloatNullableFilter<"AttendanceLog"> | number | null
    maskDetected?: BoolNullableFilter<"AttendanceLog"> | boolean | null
    processed?: BoolFilter<"AttendanceLog"> | boolean
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Terminal?: XOR<TerminalNullableRelationFilter, TerminalWhereInput> | null
  }, "id">

  export type AttendanceLogOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    terminalId?: SortOrderInput | SortOrder
    verifyMethod?: SortOrderInput | SortOrder
    snapshot?: SortOrderInput | SortOrder
    temperature?: SortOrderInput | SortOrder
    maskDetected?: SortOrderInput | SortOrder
    processed?: SortOrder
    rawData?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: AttendanceLogCountOrderByAggregateInput
    _avg?: AttendanceLogAvgOrderByAggregateInput
    _max?: AttendanceLogMaxOrderByAggregateInput
    _min?: AttendanceLogMinOrderByAggregateInput
    _sum?: AttendanceLogSumOrderByAggregateInput
  }

  export type AttendanceLogScalarWhereWithAggregatesInput = {
    AND?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    OR?: AttendanceLogScalarWhereWithAggregatesInput[]
    NOT?: AttendanceLogScalarWhereWithAggregatesInput | AttendanceLogScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"AttendanceLog"> | string
    employeeId?: StringWithAggregatesFilter<"AttendanceLog"> | string
    eventType?: StringWithAggregatesFilter<"AttendanceLog"> | string
    timestamp?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
    terminalId?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    verifyMethod?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    snapshot?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    temperature?: FloatNullableWithAggregatesFilter<"AttendanceLog"> | number | null
    maskDetected?: BoolNullableWithAggregatesFilter<"AttendanceLog"> | boolean | null
    processed?: BoolWithAggregatesFilter<"AttendanceLog"> | boolean
    rawData?: StringNullableWithAggregatesFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"AttendanceLog"> | Date | string
  }

  export type BiometricDataWhereInput = {
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    id?: StringFilter<"BiometricData"> | string
    employeeId?: StringFilter<"BiometricData"> | string
    type?: StringFilter<"BiometricData"> | string
    data?: StringNullableFilter<"BiometricData"> | string | null
    fingerNo?: IntNullableFilter<"BiometricData"> | number | null
    enrolledAt?: DateTimeFilter<"BiometricData"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type BiometricDataOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    fingerNo?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type BiometricDataWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: BiometricDataWhereInput | BiometricDataWhereInput[]
    OR?: BiometricDataWhereInput[]
    NOT?: BiometricDataWhereInput | BiometricDataWhereInput[]
    employeeId?: StringFilter<"BiometricData"> | string
    type?: StringFilter<"BiometricData"> | string
    data?: StringNullableFilter<"BiometricData"> | string | null
    fingerNo?: IntNullableFilter<"BiometricData"> | number | null
    enrolledAt?: DateTimeFilter<"BiometricData"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type BiometricDataOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    data?: SortOrderInput | SortOrder
    fingerNo?: SortOrderInput | SortOrder
    enrolledAt?: SortOrder
    _count?: BiometricDataCountOrderByAggregateInput
    _avg?: BiometricDataAvgOrderByAggregateInput
    _max?: BiometricDataMaxOrderByAggregateInput
    _min?: BiometricDataMinOrderByAggregateInput
    _sum?: BiometricDataSumOrderByAggregateInput
  }

  export type BiometricDataScalarWhereWithAggregatesInput = {
    AND?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    OR?: BiometricDataScalarWhereWithAggregatesInput[]
    NOT?: BiometricDataScalarWhereWithAggregatesInput | BiometricDataScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"BiometricData"> | string
    employeeId?: StringWithAggregatesFilter<"BiometricData"> | string
    type?: StringWithAggregatesFilter<"BiometricData"> | string
    data?: StringNullableWithAggregatesFilter<"BiometricData"> | string | null
    fingerNo?: IntNullableWithAggregatesFilter<"BiometricData"> | number | null
    enrolledAt?: DateTimeWithAggregatesFilter<"BiometricData"> | Date | string
  }

  export type LeaveBalanceWhereInput = {
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveType?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    remainingDays?: IntFilter<"LeaveBalance"> | number
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type LeaveBalanceOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveBalanceWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId_leaveType_year?: LeaveBalanceEmployeeIdLeaveTypeYearCompoundUniqueInput
    AND?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    OR?: LeaveBalanceWhereInput[]
    NOT?: LeaveBalanceWhereInput | LeaveBalanceWhereInput[]
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveType?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    remainingDays?: IntFilter<"LeaveBalance"> | number
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId_leaveType_year">

  export type LeaveBalanceOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
    _count?: LeaveBalanceCountOrderByAggregateInput
    _avg?: LeaveBalanceAvgOrderByAggregateInput
    _max?: LeaveBalanceMaxOrderByAggregateInput
    _min?: LeaveBalanceMinOrderByAggregateInput
    _sum?: LeaveBalanceSumOrderByAggregateInput
  }

  export type LeaveBalanceScalarWhereWithAggregatesInput = {
    AND?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    OR?: LeaveBalanceScalarWhereWithAggregatesInput[]
    NOT?: LeaveBalanceScalarWhereWithAggregatesInput | LeaveBalanceScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveBalance"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveBalance"> | string
    leaveType?: StringWithAggregatesFilter<"LeaveBalance"> | string
    year?: IntWithAggregatesFilter<"LeaveBalance"> | number
    totalDays?: IntWithAggregatesFilter<"LeaveBalance"> | number
    usedDays?: IntWithAggregatesFilter<"LeaveBalance"> | number
    remainingDays?: IntWithAggregatesFilter<"LeaveBalance"> | number
  }

  export type LeaveRequestWhereInput = {
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveType?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: IntFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type LeaveRequestOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type LeaveRequestWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    OR?: LeaveRequestWhereInput[]
    NOT?: LeaveRequestWhereInput | LeaveRequestWhereInput[]
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveType?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: IntFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id">

  export type LeaveRequestOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    rejectionReason?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: LeaveRequestCountOrderByAggregateInput
    _avg?: LeaveRequestAvgOrderByAggregateInput
    _max?: LeaveRequestMaxOrderByAggregateInput
    _min?: LeaveRequestMinOrderByAggregateInput
    _sum?: LeaveRequestSumOrderByAggregateInput
  }

  export type LeaveRequestScalarWhereWithAggregatesInput = {
    AND?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    OR?: LeaveRequestScalarWhereWithAggregatesInput[]
    NOT?: LeaveRequestScalarWhereWithAggregatesInput | LeaveRequestScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"LeaveRequest"> | string
    employeeId?: StringWithAggregatesFilter<"LeaveRequest"> | string
    leaveType?: StringWithAggregatesFilter<"LeaveRequest"> | string
    startDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    totalDays?: IntWithAggregatesFilter<"LeaveRequest"> | number
    reason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    status?: StringWithAggregatesFilter<"LeaveRequest"> | string
    approvedById?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"LeaveRequest"> | Date | string | null
    rejectionReason?: StringNullableWithAggregatesFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"LeaveRequest"> | Date | string
  }

  export type NotificationWhereInput = {
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    employeeId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }

  export type NotificationOrderByWithRelationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type NotificationWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: NotificationWhereInput | NotificationWhereInput[]
    OR?: NotificationWhereInput[]
    NOT?: NotificationWhereInput | NotificationWhereInput[]
    userId?: StringNullableFilter<"Notification"> | string | null
    employeeId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
    Employee?: XOR<EmployeeNullableRelationFilter, EmployeeWhereInput> | null
  }, "id">

  export type NotificationOrderByWithAggregationInput = {
    id?: SortOrder
    userId?: SortOrderInput | SortOrder
    employeeId?: SortOrderInput | SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: NotificationCountOrderByAggregateInput
    _max?: NotificationMaxOrderByAggregateInput
    _min?: NotificationMinOrderByAggregateInput
  }

  export type NotificationScalarWhereWithAggregatesInput = {
    AND?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    OR?: NotificationScalarWhereWithAggregatesInput[]
    NOT?: NotificationScalarWhereWithAggregatesInput | NotificationScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Notification"> | string
    userId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    employeeId?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    type?: StringWithAggregatesFilter<"Notification"> | string
    title?: StringWithAggregatesFilter<"Notification"> | string
    message?: StringWithAggregatesFilter<"Notification"> | string
    isRead?: BoolWithAggregatesFilter<"Notification"> | boolean
    data?: StringNullableWithAggregatesFilter<"Notification"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Notification"> | Date | string
  }

  export type SettingWhereInput = {
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    id?: StringFilter<"Setting"> | string
    key?: StringFilter<"Setting"> | string
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    category?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }

  export type SettingOrderByWithRelationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    key?: string
    AND?: SettingWhereInput | SettingWhereInput[]
    OR?: SettingWhereInput[]
    NOT?: SettingWhereInput | SettingWhereInput[]
    value?: StringFilter<"Setting"> | string
    description?: StringNullableFilter<"Setting"> | string | null
    category?: StringFilter<"Setting"> | string
    createdAt?: DateTimeFilter<"Setting"> | Date | string
    updatedAt?: DateTimeFilter<"Setting"> | Date | string
  }, "id" | "key">

  export type SettingOrderByWithAggregationInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrderInput | SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: SettingCountOrderByAggregateInput
    _max?: SettingMaxOrderByAggregateInput
    _min?: SettingMinOrderByAggregateInput
  }

  export type SettingScalarWhereWithAggregatesInput = {
    AND?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    OR?: SettingScalarWhereWithAggregatesInput[]
    NOT?: SettingScalarWhereWithAggregatesInput | SettingScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Setting"> | string
    key?: StringWithAggregatesFilter<"Setting"> | string
    value?: StringWithAggregatesFilter<"Setting"> | string
    description?: StringNullableWithAggregatesFilter<"Setting"> | string | null
    category?: StringWithAggregatesFilter<"Setting"> | string
    createdAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Setting"> | Date | string
  }

  export type ShiftAssignmentWhereInput = {
    AND?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    OR?: ShiftAssignmentWhereInput[]
    NOT?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    id?: StringFilter<"ShiftAssignment"> | string
    employeeId?: StringFilter<"ShiftAssignment"> | string
    shiftId?: StringFilter<"ShiftAssignment"> | string
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    assignedById?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Shift?: XOR<ShiftRelationFilter, ShiftWhereInput>
    AssignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type ShiftAssignmentOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    Shift?: ShiftOrderByWithRelationInput
    AssignedBy?: UserOrderByWithRelationInput
  }

  export type ShiftAssignmentWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    OR?: ShiftAssignmentWhereInput[]
    NOT?: ShiftAssignmentWhereInput | ShiftAssignmentWhereInput[]
    employeeId?: StringFilter<"ShiftAssignment"> | string
    shiftId?: StringFilter<"ShiftAssignment"> | string
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    assignedById?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Shift?: XOR<ShiftRelationFilter, ShiftWhereInput>
    AssignedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type ShiftAssignmentOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrderInput | SortOrder
    isActive?: SortOrder
    assignedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    _count?: ShiftAssignmentCountOrderByAggregateInput
    _max?: ShiftAssignmentMaxOrderByAggregateInput
    _min?: ShiftAssignmentMinOrderByAggregateInput
  }

  export type ShiftAssignmentScalarWhereWithAggregatesInput = {
    AND?: ShiftAssignmentScalarWhereWithAggregatesInput | ShiftAssignmentScalarWhereWithAggregatesInput[]
    OR?: ShiftAssignmentScalarWhereWithAggregatesInput[]
    NOT?: ShiftAssignmentScalarWhereWithAggregatesInput | ShiftAssignmentScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"ShiftAssignment"> | string
    employeeId?: StringWithAggregatesFilter<"ShiftAssignment"> | string
    shiftId?: StringWithAggregatesFilter<"ShiftAssignment"> | string
    startDate?: DateTimeWithAggregatesFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableWithAggregatesFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"ShiftAssignment"> | boolean
    assignedById?: StringNullableWithAggregatesFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"ShiftAssignment"> | Date | string
  }

  export type TerminalWhereInput = {
    AND?: TerminalWhereInput | TerminalWhereInput[]
    OR?: TerminalWhereInput[]
    NOT?: TerminalWhereInput | TerminalWhereInput[]
    id?: StringFilter<"Terminal"> | string
    name?: StringFilter<"Terminal"> | string
    ipAddress?: StringFilter<"Terminal"> | string
    port?: IntFilter<"Terminal"> | number
    username?: StringFilter<"Terminal"> | string
    password?: StringFilter<"Terminal"> | string
    deviceType?: StringNullableFilter<"Terminal"> | string | null
    serialNumber?: StringNullableFilter<"Terminal"> | string | null
    firmwareVersion?: StringNullableFilter<"Terminal"> | string | null
    location?: StringNullableFilter<"Terminal"> | string | null
    isOnline?: BoolFilter<"Terminal"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    isActive?: BoolFilter<"Terminal"> | boolean
    createdAt?: DateTimeFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeFilter<"Terminal"> | Date | string
    AttendanceLog?: AttendanceLogListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
  }

  export type TerminalOrderByWithRelationInput = {
    id?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    firmwareVersion?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    AttendanceLog?: AttendanceLogOrderByRelationAggregateInput
    TimeEntry?: TimeEntryOrderByRelationAggregateInput
  }

  export type TerminalWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TerminalWhereInput | TerminalWhereInput[]
    OR?: TerminalWhereInput[]
    NOT?: TerminalWhereInput | TerminalWhereInput[]
    name?: StringFilter<"Terminal"> | string
    ipAddress?: StringFilter<"Terminal"> | string
    port?: IntFilter<"Terminal"> | number
    username?: StringFilter<"Terminal"> | string
    password?: StringFilter<"Terminal"> | string
    deviceType?: StringNullableFilter<"Terminal"> | string | null
    serialNumber?: StringNullableFilter<"Terminal"> | string | null
    firmwareVersion?: StringNullableFilter<"Terminal"> | string | null
    location?: StringNullableFilter<"Terminal"> | string | null
    isOnline?: BoolFilter<"Terminal"> | boolean
    lastSyncAt?: DateTimeNullableFilter<"Terminal"> | Date | string | null
    isActive?: BoolFilter<"Terminal"> | boolean
    createdAt?: DateTimeFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeFilter<"Terminal"> | Date | string
    AttendanceLog?: AttendanceLogListRelationFilter
    TimeEntry?: TimeEntryListRelationFilter
  }, "id">

  export type TerminalOrderByWithAggregationInput = {
    id?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deviceType?: SortOrderInput | SortOrder
    serialNumber?: SortOrderInput | SortOrder
    firmwareVersion?: SortOrderInput | SortOrder
    location?: SortOrderInput | SortOrder
    isOnline?: SortOrder
    lastSyncAt?: SortOrderInput | SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TerminalCountOrderByAggregateInput
    _avg?: TerminalAvgOrderByAggregateInput
    _max?: TerminalMaxOrderByAggregateInput
    _min?: TerminalMinOrderByAggregateInput
    _sum?: TerminalSumOrderByAggregateInput
  }

  export type TerminalScalarWhereWithAggregatesInput = {
    AND?: TerminalScalarWhereWithAggregatesInput | TerminalScalarWhereWithAggregatesInput[]
    OR?: TerminalScalarWhereWithAggregatesInput[]
    NOT?: TerminalScalarWhereWithAggregatesInput | TerminalScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Terminal"> | string
    name?: StringWithAggregatesFilter<"Terminal"> | string
    ipAddress?: StringWithAggregatesFilter<"Terminal"> | string
    port?: IntWithAggregatesFilter<"Terminal"> | number
    username?: StringWithAggregatesFilter<"Terminal"> | string
    password?: StringWithAggregatesFilter<"Terminal"> | string
    deviceType?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    serialNumber?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    firmwareVersion?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    location?: StringNullableWithAggregatesFilter<"Terminal"> | string | null
    isOnline?: BoolWithAggregatesFilter<"Terminal"> | boolean
    lastSyncAt?: DateTimeNullableWithAggregatesFilter<"Terminal"> | Date | string | null
    isActive?: BoolWithAggregatesFilter<"Terminal"> | boolean
    createdAt?: DateTimeWithAggregatesFilter<"Terminal"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Terminal"> | Date | string
  }

  export type TimeEntryWhereInput = {
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    employeeId?: StringFilter<"TimeEntry"> | string
    clockIn?: DateTimeFilter<"TimeEntry"> | Date | string
    clockOut?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakStart?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakEnd?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    totalHours?: FloatNullableFilter<"TimeEntry"> | number | null
    regularHours?: FloatNullableFilter<"TimeEntry"> | number | null
    overtimeHours?: FloatNullableFilter<"TimeEntry"> | number | null
    breakMinutes?: IntNullableFilter<"TimeEntry"> | number | null
    status?: StringFilter<"TimeEntry"> | string
    location?: StringNullableFilter<"TimeEntry"> | string | null
    terminalId?: StringNullableFilter<"TimeEntry"> | string | null
    verifyMethod?: StringNullableFilter<"TimeEntry"> | string | null
    clockInPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    clockOutPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    isManualEntry?: BoolFilter<"TimeEntry"> | boolean
    approvedById?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Terminal?: XOR<TerminalNullableRelationFilter, TerminalWhereInput> | null
  }

  export type TimeEntryOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrderInput | SortOrder
    breakStart?: SortOrderInput | SortOrder
    breakEnd?: SortOrderInput | SortOrder
    totalHours?: SortOrderInput | SortOrder
    regularHours?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    breakMinutes?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    terminalId?: SortOrderInput | SortOrder
    verifyMethod?: SortOrderInput | SortOrder
    clockInPhoto?: SortOrderInput | SortOrder
    clockOutPhoto?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isManualEntry?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    User?: UserOrderByWithRelationInput
    Employee?: EmployeeOrderByWithRelationInput
    Terminal?: TerminalOrderByWithRelationInput
  }

  export type TimeEntryWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: TimeEntryWhereInput | TimeEntryWhereInput[]
    OR?: TimeEntryWhereInput[]
    NOT?: TimeEntryWhereInput | TimeEntryWhereInput[]
    employeeId?: StringFilter<"TimeEntry"> | string
    clockIn?: DateTimeFilter<"TimeEntry"> | Date | string
    clockOut?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakStart?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakEnd?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    totalHours?: FloatNullableFilter<"TimeEntry"> | number | null
    regularHours?: FloatNullableFilter<"TimeEntry"> | number | null
    overtimeHours?: FloatNullableFilter<"TimeEntry"> | number | null
    breakMinutes?: IntNullableFilter<"TimeEntry"> | number | null
    status?: StringFilter<"TimeEntry"> | string
    location?: StringNullableFilter<"TimeEntry"> | string | null
    terminalId?: StringNullableFilter<"TimeEntry"> | string | null
    verifyMethod?: StringNullableFilter<"TimeEntry"> | string | null
    clockInPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    clockOutPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    isManualEntry?: BoolFilter<"TimeEntry"> | boolean
    approvedById?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
    User?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    Terminal?: XOR<TerminalNullableRelationFilter, TerminalWhereInput> | null
  }, "id">

  export type TimeEntryOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrderInput | SortOrder
    breakStart?: SortOrderInput | SortOrder
    breakEnd?: SortOrderInput | SortOrder
    totalHours?: SortOrderInput | SortOrder
    regularHours?: SortOrderInput | SortOrder
    overtimeHours?: SortOrderInput | SortOrder
    breakMinutes?: SortOrderInput | SortOrder
    status?: SortOrder
    location?: SortOrderInput | SortOrder
    terminalId?: SortOrderInput | SortOrder
    verifyMethod?: SortOrderInput | SortOrder
    clockInPhoto?: SortOrderInput | SortOrder
    clockOutPhoto?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    isManualEntry?: SortOrder
    approvedById?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: TimeEntryCountOrderByAggregateInput
    _avg?: TimeEntryAvgOrderByAggregateInput
    _max?: TimeEntryMaxOrderByAggregateInput
    _min?: TimeEntryMinOrderByAggregateInput
    _sum?: TimeEntrySumOrderByAggregateInput
  }

  export type TimeEntryScalarWhereWithAggregatesInput = {
    AND?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    OR?: TimeEntryScalarWhereWithAggregatesInput[]
    NOT?: TimeEntryScalarWhereWithAggregatesInput | TimeEntryScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"TimeEntry"> | string
    employeeId?: StringWithAggregatesFilter<"TimeEntry"> | string
    clockIn?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    clockOut?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    breakStart?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    breakEnd?: DateTimeNullableWithAggregatesFilter<"TimeEntry"> | Date | string | null
    totalHours?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    regularHours?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    overtimeHours?: FloatNullableWithAggregatesFilter<"TimeEntry"> | number | null
    breakMinutes?: IntNullableWithAggregatesFilter<"TimeEntry"> | number | null
    status?: StringWithAggregatesFilter<"TimeEntry"> | string
    location?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    terminalId?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    verifyMethod?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    clockInPhoto?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    clockOutPhoto?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    notes?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    isManualEntry?: BoolWithAggregatesFilter<"TimeEntry"> | boolean
    approvedById?: StringNullableWithAggregatesFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"TimeEntry"> | Date | string
  }

  export type EmployeeRateWhereInput = {
    AND?: EmployeeRateWhereInput | EmployeeRateWhereInput[]
    OR?: EmployeeRateWhereInput[]
    NOT?: EmployeeRateWhereInput | EmployeeRateWhereInput[]
    id?: StringFilter<"EmployeeRate"> | string
    employeeId?: StringFilter<"EmployeeRate"> | string
    hourlyRate?: FloatFilter<"EmployeeRate"> | number
    dailyRate?: FloatNullableFilter<"EmployeeRate"> | number | null
    salary?: FloatNullableFilter<"EmployeeRate"> | number | null
    overtimeRate?: FloatNullableFilter<"EmployeeRate"> | number | null
    effectiveFrom?: DateTimeFilter<"EmployeeRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"EmployeeRate"> | Date | string | null
    currency?: StringFilter<"EmployeeRate"> | string
    rateType?: StringFilter<"EmployeeRate"> | string
    notes?: StringNullableFilter<"EmployeeRate"> | string | null
    createdAt?: DateTimeFilter<"EmployeeRate"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeRate"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }

  export type EmployeeRateOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hourlyRate?: SortOrder
    dailyRate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    overtimeRate?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    currency?: SortOrder
    rateType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
  }

  export type EmployeeRateWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    employeeId?: string
    AND?: EmployeeRateWhereInput | EmployeeRateWhereInput[]
    OR?: EmployeeRateWhereInput[]
    NOT?: EmployeeRateWhereInput | EmployeeRateWhereInput[]
    hourlyRate?: FloatFilter<"EmployeeRate"> | number
    dailyRate?: FloatNullableFilter<"EmployeeRate"> | number | null
    salary?: FloatNullableFilter<"EmployeeRate"> | number | null
    overtimeRate?: FloatNullableFilter<"EmployeeRate"> | number | null
    effectiveFrom?: DateTimeFilter<"EmployeeRate"> | Date | string
    effectiveTo?: DateTimeNullableFilter<"EmployeeRate"> | Date | string | null
    currency?: StringFilter<"EmployeeRate"> | string
    rateType?: StringFilter<"EmployeeRate"> | string
    notes?: StringNullableFilter<"EmployeeRate"> | string | null
    createdAt?: DateTimeFilter<"EmployeeRate"> | Date | string
    updatedAt?: DateTimeFilter<"EmployeeRate"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
  }, "id" | "employeeId">

  export type EmployeeRateOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hourlyRate?: SortOrder
    dailyRate?: SortOrderInput | SortOrder
    salary?: SortOrderInput | SortOrder
    overtimeRate?: SortOrderInput | SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrderInput | SortOrder
    currency?: SortOrder
    rateType?: SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: EmployeeRateCountOrderByAggregateInput
    _avg?: EmployeeRateAvgOrderByAggregateInput
    _max?: EmployeeRateMaxOrderByAggregateInput
    _min?: EmployeeRateMinOrderByAggregateInput
    _sum?: EmployeeRateSumOrderByAggregateInput
  }

  export type EmployeeRateScalarWhereWithAggregatesInput = {
    AND?: EmployeeRateScalarWhereWithAggregatesInput | EmployeeRateScalarWhereWithAggregatesInput[]
    OR?: EmployeeRateScalarWhereWithAggregatesInput[]
    NOT?: EmployeeRateScalarWhereWithAggregatesInput | EmployeeRateScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"EmployeeRate"> | string
    employeeId?: StringWithAggregatesFilter<"EmployeeRate"> | string
    hourlyRate?: FloatWithAggregatesFilter<"EmployeeRate"> | number
    dailyRate?: FloatNullableWithAggregatesFilter<"EmployeeRate"> | number | null
    salary?: FloatNullableWithAggregatesFilter<"EmployeeRate"> | number | null
    overtimeRate?: FloatNullableWithAggregatesFilter<"EmployeeRate"> | number | null
    effectiveFrom?: DateTimeWithAggregatesFilter<"EmployeeRate"> | Date | string
    effectiveTo?: DateTimeNullableWithAggregatesFilter<"EmployeeRate"> | Date | string | null
    currency?: StringWithAggregatesFilter<"EmployeeRate"> | string
    rateType?: StringWithAggregatesFilter<"EmployeeRate"> | string
    notes?: StringNullableWithAggregatesFilter<"EmployeeRate"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"EmployeeRate"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"EmployeeRate"> | Date | string
  }

  export type PayrollDeductionWhereInput = {
    AND?: PayrollDeductionWhereInput | PayrollDeductionWhereInput[]
    OR?: PayrollDeductionWhereInput[]
    NOT?: PayrollDeductionWhereInput | PayrollDeductionWhereInput[]
    id?: StringFilter<"PayrollDeduction"> | string
    employeeId?: StringFilter<"PayrollDeduction"> | string
    deductionType?: StringFilter<"PayrollDeduction"> | string
    amount?: FloatFilter<"PayrollDeduction"> | number
    reason?: StringNullableFilter<"PayrollDeduction"> | string | null
    description?: StringNullableFilter<"PayrollDeduction"> | string | null
    month?: DateTimeFilter<"PayrollDeduction"> | Date | string
    status?: StringFilter<"PayrollDeduction"> | string
    approvedBy?: StringNullableFilter<"PayrollDeduction"> | string | null
    approvedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    notes?: StringNullableFilter<"PayrollDeduction"> | string | null
    createdAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    ApprovedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type PayrollDeductionOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    deductionType?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    month?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    ApprovedBy?: UserOrderByWithRelationInput
  }

  export type PayrollDeductionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: PayrollDeductionWhereInput | PayrollDeductionWhereInput[]
    OR?: PayrollDeductionWhereInput[]
    NOT?: PayrollDeductionWhereInput | PayrollDeductionWhereInput[]
    employeeId?: StringFilter<"PayrollDeduction"> | string
    deductionType?: StringFilter<"PayrollDeduction"> | string
    amount?: FloatFilter<"PayrollDeduction"> | number
    reason?: StringNullableFilter<"PayrollDeduction"> | string | null
    description?: StringNullableFilter<"PayrollDeduction"> | string | null
    month?: DateTimeFilter<"PayrollDeduction"> | Date | string
    status?: StringFilter<"PayrollDeduction"> | string
    approvedBy?: StringNullableFilter<"PayrollDeduction"> | string | null
    approvedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    notes?: StringNullableFilter<"PayrollDeduction"> | string | null
    createdAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    ApprovedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type PayrollDeductionOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    deductionType?: SortOrder
    amount?: SortOrder
    reason?: SortOrderInput | SortOrder
    description?: SortOrderInput | SortOrder
    month?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    appliedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: PayrollDeductionCountOrderByAggregateInput
    _avg?: PayrollDeductionAvgOrderByAggregateInput
    _max?: PayrollDeductionMaxOrderByAggregateInput
    _min?: PayrollDeductionMinOrderByAggregateInput
    _sum?: PayrollDeductionSumOrderByAggregateInput
  }

  export type PayrollDeductionScalarWhereWithAggregatesInput = {
    AND?: PayrollDeductionScalarWhereWithAggregatesInput | PayrollDeductionScalarWhereWithAggregatesInput[]
    OR?: PayrollDeductionScalarWhereWithAggregatesInput[]
    NOT?: PayrollDeductionScalarWhereWithAggregatesInput | PayrollDeductionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"PayrollDeduction"> | string
    employeeId?: StringWithAggregatesFilter<"PayrollDeduction"> | string
    deductionType?: StringWithAggregatesFilter<"PayrollDeduction"> | string
    amount?: FloatWithAggregatesFilter<"PayrollDeduction"> | number
    reason?: StringNullableWithAggregatesFilter<"PayrollDeduction"> | string | null
    description?: StringNullableWithAggregatesFilter<"PayrollDeduction"> | string | null
    month?: DateTimeWithAggregatesFilter<"PayrollDeduction"> | Date | string
    status?: StringWithAggregatesFilter<"PayrollDeduction"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"PayrollDeduction"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"PayrollDeduction"> | Date | string | null
    appliedAt?: DateTimeNullableWithAggregatesFilter<"PayrollDeduction"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"PayrollDeduction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"PayrollDeduction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"PayrollDeduction"> | Date | string
  }

  export type InfractionWhereInput = {
    AND?: InfractionWhereInput | InfractionWhereInput[]
    OR?: InfractionWhereInput[]
    NOT?: InfractionWhereInput | InfractionWhereInput[]
    id?: StringFilter<"Infraction"> | string
    employeeId?: StringFilter<"Infraction"> | string
    type?: StringFilter<"Infraction"> | string
    severity?: StringFilter<"Infraction"> | string
    amount?: FloatNullableFilter<"Infraction"> | number | null
    description?: StringFilter<"Infraction"> | string
    date?: DateTimeFilter<"Infraction"> | Date | string
    reportedBy?: StringNullableFilter<"Infraction"> | string | null
    status?: StringFilter<"Infraction"> | string
    approvedBy?: StringNullableFilter<"Infraction"> | string | null
    approvedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    notes?: StringNullableFilter<"Infraction"> | string | null
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    updatedAt?: DateTimeFilter<"Infraction"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    ReportedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ApprovedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }

  export type InfractionOrderByWithRelationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrder
    date?: SortOrder
    reportedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    Employee?: EmployeeOrderByWithRelationInput
    ReportedBy?: UserOrderByWithRelationInput
    ApprovedBy?: UserOrderByWithRelationInput
  }

  export type InfractionWhereUniqueInput = Prisma.AtLeast<{
    id?: string
    AND?: InfractionWhereInput | InfractionWhereInput[]
    OR?: InfractionWhereInput[]
    NOT?: InfractionWhereInput | InfractionWhereInput[]
    employeeId?: StringFilter<"Infraction"> | string
    type?: StringFilter<"Infraction"> | string
    severity?: StringFilter<"Infraction"> | string
    amount?: FloatNullableFilter<"Infraction"> | number | null
    description?: StringFilter<"Infraction"> | string
    date?: DateTimeFilter<"Infraction"> | Date | string
    reportedBy?: StringNullableFilter<"Infraction"> | string | null
    status?: StringFilter<"Infraction"> | string
    approvedBy?: StringNullableFilter<"Infraction"> | string | null
    approvedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    notes?: StringNullableFilter<"Infraction"> | string | null
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    updatedAt?: DateTimeFilter<"Infraction"> | Date | string
    Employee?: XOR<EmployeeRelationFilter, EmployeeWhereInput>
    ReportedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
    ApprovedBy?: XOR<UserNullableRelationFilter, UserWhereInput> | null
  }, "id">

  export type InfractionOrderByWithAggregationInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    amount?: SortOrderInput | SortOrder
    description?: SortOrder
    date?: SortOrder
    reportedBy?: SortOrderInput | SortOrder
    status?: SortOrder
    approvedBy?: SortOrderInput | SortOrder
    approvedAt?: SortOrderInput | SortOrder
    notes?: SortOrderInput | SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
    _count?: InfractionCountOrderByAggregateInput
    _avg?: InfractionAvgOrderByAggregateInput
    _max?: InfractionMaxOrderByAggregateInput
    _min?: InfractionMinOrderByAggregateInput
    _sum?: InfractionSumOrderByAggregateInput
  }

  export type InfractionScalarWhereWithAggregatesInput = {
    AND?: InfractionScalarWhereWithAggregatesInput | InfractionScalarWhereWithAggregatesInput[]
    OR?: InfractionScalarWhereWithAggregatesInput[]
    NOT?: InfractionScalarWhereWithAggregatesInput | InfractionScalarWhereWithAggregatesInput[]
    id?: StringWithAggregatesFilter<"Infraction"> | string
    employeeId?: StringWithAggregatesFilter<"Infraction"> | string
    type?: StringWithAggregatesFilter<"Infraction"> | string
    severity?: StringWithAggregatesFilter<"Infraction"> | string
    amount?: FloatNullableWithAggregatesFilter<"Infraction"> | number | null
    description?: StringWithAggregatesFilter<"Infraction"> | string
    date?: DateTimeWithAggregatesFilter<"Infraction"> | Date | string
    reportedBy?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    status?: StringWithAggregatesFilter<"Infraction"> | string
    approvedBy?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    approvedAt?: DateTimeNullableWithAggregatesFilter<"Infraction"> | Date | string | null
    notes?: StringNullableWithAggregatesFilter<"Infraction"> | string | null
    createdAt?: DateTimeWithAggregatesFilter<"Infraction"> | Date | string
    updatedAt?: DateTimeWithAggregatesFilter<"Infraction"> | Date | string
  }

  export type UserCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserCreateManyInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type UserUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type UserUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentCreateInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: UserCreateNestedOneWithoutDepartmentsCreatedInput
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneWithoutDepartmentsCreatedNestedInput
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: UserCreateNestedOneWithoutShiftsCreatedInput
    employees?: EmployeeCreateNestedManyWithoutShiftInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneWithoutShiftsCreatedNestedInput
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftCreateManyInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateManyInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InactiveEmployeeCreateInput = {
    id?: string
    employeeId: string
    employeeName: string
    departmentId?: string | null
    inactiveReason: string
    details?: string | null
    suspendedBy?: string | null
    suspendedAt?: Date | string
    reactivatedAt?: Date | string | null
    reactivatedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InactiveEmployeeUncheckedCreateInput = {
    id?: string
    employeeId: string
    employeeName: string
    departmentId?: string | null
    inactiveReason: string
    details?: string | null
    suspendedBy?: string | null
    suspendedAt?: Date | string
    reactivatedAt?: Date | string | null
    reactivatedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InactiveEmployeeUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    employeeName?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    inactiveReason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InactiveEmployeeUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    employeeName?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    inactiveReason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InactiveEmployeeCreateManyInput = {
    id?: string
    employeeId: string
    employeeName: string
    departmentId?: string | null
    inactiveReason: string
    details?: string | null
    suspendedBy?: string | null
    suspendedAt?: Date | string
    reactivatedAt?: Date | string | null
    reactivatedBy?: string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InactiveEmployeeUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    employeeName?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    inactiveReason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InactiveEmployeeUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    employeeName?: StringFieldUpdateOperationsInput | string
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    inactiveReason?: StringFieldUpdateOperationsInput | string
    details?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedBy?: NullableStringFieldUpdateOperationsInput | string | null
    suspendedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    reactivatedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    reactivatedBy?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
    User?: UserCreateNestedOneWithoutAuditLogInput
  }

  export type AuditLogUncheckedCreateInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutAuditLogNestedInput
  }

  export type AuditLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogCreateManyInput = {
    id?: string
    userId?: string | null
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateInput = {
    id: string
    eventType: string
    timestamp: Date | string
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutAttendanceLogInput
    Terminal?: TerminalCreateNestedOneWithoutAttendanceLogInput
  }

  export type AttendanceLogUncheckedCreateInput = {
    id: string
    employeeId: string
    eventType: string
    timestamp: Date | string
    terminalId?: string | null
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type AttendanceLogUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutAttendanceLogNestedInput
    Terminal?: TerminalUpdateOneWithoutAttendanceLogNestedInput
  }

  export type AttendanceLogUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyInput = {
    id: string
    employeeId: string
    eventType: string
    timestamp: Date | string
    terminalId?: string | null
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type AttendanceLogUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateInput = {
    id: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutBiometricDataInput
  }

  export type BiometricDataUncheckedCreateInput = {
    id: string
    employeeId: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
  }

  export type BiometricDataUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutBiometricDataNestedInput
  }

  export type BiometricDataUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataCreateManyInput = {
    id: string
    employeeId: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
  }

  export type BiometricDataUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceCreateInput = {
    id: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
    Employee: EmployeeCreateNestedOneWithoutLeaveBalanceInput
  }

  export type LeaveBalanceUncheckedCreateInput = {
    id: string
    employeeId: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
  }

  export type LeaveBalanceUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
    Employee?: EmployeeUpdateOneRequiredWithoutLeaveBalanceNestedInput
  }

  export type LeaveBalanceUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveBalanceCreateManyInput = {
    id: string
    employeeId: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
  }

  export type LeaveBalanceUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveBalanceUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveRequestCreateInput = {
    id: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutLeaveRequestInput
    Employee: EmployeeCreateNestedOneWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateInput = {
    id: string
    employeeId: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LeaveRequestUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutLeaveRequestNestedInput
    Employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestCreateManyInput = {
    id: string
    employeeId: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LeaveRequestUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateInput = {
    id: string
    userId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
    Employee?: EmployeeCreateNestedOneWithoutNotificationInput
  }

  export type NotificationUncheckedCreateInput = {
    id: string
    userId?: string | null
    employeeId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneWithoutNotificationNestedInput
  }

  export type NotificationUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationCreateManyInput = {
    id: string
    userId?: string | null
    employeeId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
  }

  export type NotificationUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    employeeId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateInput = {
    id: string
    key: string
    value: string
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SettingUncheckedCreateInput = {
    id: string
    key: string
    value: string
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SettingUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingCreateManyInput = {
    id: string
    key: string
    value: string
    description?: string | null
    category?: string
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type SettingUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type SettingUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    key?: StringFieldUpdateOperationsInput | string
    value?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    category?: StringFieldUpdateOperationsInput | string
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentCreateInput = {
    id: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutShiftAssignmentInput
    Shift: ShiftCreateNestedOneWithoutShiftAssignmentInput
    AssignedBy?: UserCreateNestedOneWithoutShiftAssignmentsCreatedInput
  }

  export type ShiftAssignmentUncheckedCreateInput = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type ShiftAssignmentUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutShiftAssignmentNestedInput
    Shift?: ShiftUpdateOneRequiredWithoutShiftAssignmentNestedInput
    AssignedBy?: UserUpdateOneWithoutShiftAssignmentsCreatedNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentCreateManyInput = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type ShiftAssignmentUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalCreateInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutTerminalInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutTerminalInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutTerminalNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutTerminalNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalCreateManyInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TerminalUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TerminalUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutTimeEntryInput
    Employee: EmployeeCreateNestedOneWithoutTimeEntryInput
    Terminal?: TerminalCreateNestedOneWithoutTimeEntryInput
  }

  export type TimeEntryUncheckedCreateInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutTimeEntryNestedInput
    Employee?: EmployeeUpdateOneRequiredWithoutTimeEntryNestedInput
    Terminal?: TerminalUpdateOneWithoutTimeEntryNestedInput
  }

  export type TimeEntryUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryCreateManyInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeRateCreateInput = {
    id?: string
    hourlyRate: number
    dailyRate?: number | null
    salary?: number | null
    overtimeRate?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    currency?: string
    rateType?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeRateInput
  }

  export type EmployeeRateUncheckedCreateInput = {
    id?: string
    employeeId: string
    hourlyRate: number
    dailyRate?: number | null
    salary?: number | null
    overtimeRate?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    currency?: string
    rateType?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeRateUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeRateNestedInput
  }

  export type EmployeeRateUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeRateCreateManyInput = {
    id?: string
    employeeId: string
    hourlyRate: number
    dailyRate?: number | null
    salary?: number | null
    overtimeRate?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    currency?: string
    rateType?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeRateUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeRateUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionCreateInput = {
    id?: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeDeductionsInput
    ApprovedBy?: UserCreateNestedOneWithoutDeductionApprovalsInput
  }

  export type PayrollDeductionUncheckedCreateInput = {
    id?: string
    employeeId: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollDeductionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeDeductionsNestedInput
    ApprovedBy?: UserUpdateOneWithoutDeductionApprovalsNestedInput
  }

  export type PayrollDeductionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionCreateManyInput = {
    id?: string
    employeeId: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollDeductionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionCreateInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeInfractionsInput
    ReportedBy?: UserCreateNestedOneWithoutInfractionReportsInput
    ApprovedBy?: UserCreateNestedOneWithoutInfractionApprovalsInput
  }

  export type InfractionUncheckedCreateInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeInfractionsNestedInput
    ReportedBy?: UserUpdateOneWithoutInfractionReportsNestedInput
    ApprovedBy?: UserUpdateOneWithoutInfractionApprovalsNestedInput
  }

  export type InfractionUncheckedUpdateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionCreateManyInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionUpdateManyMutationInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUncheckedUpdateManyInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type StringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type BoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type DateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type AuditLogListRelationFilter = {
    every?: AuditLogWhereInput
    some?: AuditLogWhereInput
    none?: AuditLogWhereInput
  }

  export type EmployeeNullableRelationFilter = {
    is?: EmployeeWhereInput | null
    isNot?: EmployeeWhereInput | null
  }

  export type LeaveRequestListRelationFilter = {
    every?: LeaveRequestWhereInput
    some?: LeaveRequestWhereInput
    none?: LeaveRequestWhereInput
  }

  export type TimeEntryListRelationFilter = {
    every?: TimeEntryWhereInput
    some?: TimeEntryWhereInput
    none?: TimeEntryWhereInput
  }

  export type DepartmentListRelationFilter = {
    every?: DepartmentWhereInput
    some?: DepartmentWhereInput
    none?: DepartmentWhereInput
  }

  export type ShiftListRelationFilter = {
    every?: ShiftWhereInput
    some?: ShiftWhereInput
    none?: ShiftWhereInput
  }

  export type ShiftAssignmentListRelationFilter = {
    every?: ShiftAssignmentWhereInput
    some?: ShiftAssignmentWhereInput
    none?: ShiftAssignmentWhereInput
  }

  export type PayrollDeductionListRelationFilter = {
    every?: PayrollDeductionWhereInput
    some?: PayrollDeductionWhereInput
    none?: PayrollDeductionWhereInput
  }

  export type InfractionListRelationFilter = {
    every?: InfractionWhereInput
    some?: InfractionWhereInput
    none?: InfractionWhereInput
  }

  export type AuditLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveRequestOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type TimeEntryOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type ShiftAssignmentOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type PayrollDeductionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type InfractionOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type UserCountOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMaxOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type UserMinOrderByAggregateInput = {
    id?: SortOrder
    email?: SortOrder
    password?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    role?: SortOrder
    permissions?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type StringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type BoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type DateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type StringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type FloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type UserNullableRelationFilter = {
    is?: UserWhereInput | null
    isNot?: UserWhereInput | null
  }

  export type EmployeeListRelationFilter = {
    every?: EmployeeWhereInput
    some?: EmployeeWhereInput
    none?: EmployeeWhereInput
  }

  export type SortOrderInput = {
    sort: SortOrder
    nulls?: NullsOrder
  }

  export type EmployeeOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type DepartmentCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    color?: SortOrder
    budget?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentAvgOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type DepartmentMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    color?: SortOrder
    budget?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    managerId?: SortOrder
    color?: SortOrder
    budget?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type DepartmentSumOrderByAggregateInput = {
    budget?: SortOrder
  }

  export type StringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    mode?: QueryMode
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type FloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type IntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type FloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type ShiftCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
    workingDays?: SortOrder
    color?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftAvgOrderByAggregateInput = {
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
  }

  export type ShiftMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
    workingDays?: SortOrder
    color?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    description?: SortOrder
    startTime?: SortOrder
    endTime?: SortOrder
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
    workingDays?: SortOrder
    color?: SortOrder
    isNightShift?: SortOrder
    isActive?: SortOrder
    createdById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftSumOrderByAggregateInput = {
    breakDuration?: SortOrder
    graceMinutes?: SortOrder
    overtimeAfter?: SortOrder
  }

  export type IntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type FloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type DateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type AttendanceLogListRelationFilter = {
    every?: AttendanceLogWhereInput
    some?: AttendanceLogWhereInput
    none?: AttendanceLogWhereInput
  }

  export type BiometricDataListRelationFilter = {
    every?: BiometricDataWhereInput
    some?: BiometricDataWhereInput
    none?: BiometricDataWhereInput
  }

  export type DepartmentNullableRelationFilter = {
    is?: DepartmentWhereInput | null
    isNot?: DepartmentWhereInput | null
  }

  export type ShiftNullableRelationFilter = {
    is?: ShiftWhereInput | null
    isNot?: ShiftWhereInput | null
  }

  export type LeaveBalanceListRelationFilter = {
    every?: LeaveBalanceWhereInput
    some?: LeaveBalanceWhereInput
    none?: LeaveBalanceWhereInput
  }

  export type NotificationListRelationFilter = {
    every?: NotificationWhereInput
    some?: NotificationWhereInput
    none?: NotificationWhereInput
  }

  export type EmployeeRateNullableRelationFilter = {
    is?: EmployeeRateWhereInput | null
    isNot?: EmployeeRateWhereInput | null
  }

  export type AttendanceLogOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type BiometricDataOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type LeaveBalanceOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type NotificationOrderByRelationAggregateInput = {
    _count?: SortOrder
  }

  export type EmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    departmentId?: SortOrder
    designation?: SortOrder
    managerId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    status?: SortOrder
    shiftId?: SortOrder
    salary?: SortOrder
    hourlyRate?: SortOrder
    cardNumber?: SortOrder
    faceEnrolled?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintTemplate?: SortOrder
    fingerprintTemplateDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeAvgOrderByAggregateInput = {
    salary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type EmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    departmentId?: SortOrder
    designation?: SortOrder
    managerId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    status?: SortOrder
    shiftId?: SortOrder
    salary?: SortOrder
    hourlyRate?: SortOrder
    cardNumber?: SortOrder
    faceEnrolled?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintTemplate?: SortOrder
    fingerprintTemplateDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    firstName?: SortOrder
    lastName?: SortOrder
    email?: SortOrder
    phone?: SortOrder
    photo?: SortOrder
    departmentId?: SortOrder
    designation?: SortOrder
    managerId?: SortOrder
    joinDate?: SortOrder
    employmentType?: SortOrder
    status?: SortOrder
    shiftId?: SortOrder
    salary?: SortOrder
    hourlyRate?: SortOrder
    cardNumber?: SortOrder
    faceEnrolled?: SortOrder
    fingerprintEnrolled?: SortOrder
    fingerprintTemplate?: SortOrder
    fingerprintTemplateDate?: SortOrder
    userId?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeSumOrderByAggregateInput = {
    salary?: SortOrder
    hourlyRate?: SortOrder
  }

  export type DateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type InactiveEmployeeCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    departmentId?: SortOrder
    inactiveReason?: SortOrder
    details?: SortOrder
    suspendedBy?: SortOrder
    suspendedAt?: SortOrder
    reactivatedAt?: SortOrder
    reactivatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InactiveEmployeeMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    departmentId?: SortOrder
    inactiveReason?: SortOrder
    details?: SortOrder
    suspendedBy?: SortOrder
    suspendedAt?: SortOrder
    reactivatedAt?: SortOrder
    reactivatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InactiveEmployeeMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    employeeName?: SortOrder
    departmentId?: SortOrder
    inactiveReason?: SortOrder
    details?: SortOrder
    suspendedBy?: SortOrder
    suspendedAt?: SortOrder
    reactivatedAt?: SortOrder
    reactivatedBy?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type AuditLogCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type AuditLogMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    action?: SortOrder
    entityType?: SortOrder
    entityId?: SortOrder
    oldValue?: SortOrder
    newValue?: SortOrder
    ipAddress?: SortOrder
    userAgent?: SortOrder
    createdAt?: SortOrder
  }

  export type BoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type EmployeeRelationFilter = {
    is?: EmployeeWhereInput
    isNot?: EmployeeWhereInput
  }

  export type TerminalNullableRelationFilter = {
    is?: TerminalWhereInput | null
    isNot?: TerminalWhereInput | null
  }

  export type AttendanceLogCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    snapshot?: SortOrder
    temperature?: SortOrder
    maskDetected?: SortOrder
    processed?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogAvgOrderByAggregateInput = {
    temperature?: SortOrder
  }

  export type AttendanceLogMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    snapshot?: SortOrder
    temperature?: SortOrder
    maskDetected?: SortOrder
    processed?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    eventType?: SortOrder
    timestamp?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    snapshot?: SortOrder
    temperature?: SortOrder
    maskDetected?: SortOrder
    processed?: SortOrder
    rawData?: SortOrder
    createdAt?: SortOrder
  }

  export type AttendanceLogSumOrderByAggregateInput = {
    temperature?: SortOrder
  }

  export type BoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type IntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type BiometricDataCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    fingerNo?: SortOrder
    enrolledAt?: SortOrder
  }

  export type BiometricDataAvgOrderByAggregateInput = {
    fingerNo?: SortOrder
  }

  export type BiometricDataMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    fingerNo?: SortOrder
    enrolledAt?: SortOrder
  }

  export type BiometricDataMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    data?: SortOrder
    fingerNo?: SortOrder
    enrolledAt?: SortOrder
  }

  export type BiometricDataSumOrderByAggregateInput = {
    fingerNo?: SortOrder
  }

  export type IntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type LeaveBalanceEmployeeIdLeaveTypeYearCompoundUniqueInput = {
    employeeId: string
    leaveType: string
    year: number
  }

  export type LeaveBalanceCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
  }

  export type LeaveBalanceAvgOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
  }

  export type LeaveBalanceMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
  }

  export type LeaveBalanceMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
  }

  export type LeaveBalanceSumOrderByAggregateInput = {
    year?: SortOrder
    totalDays?: SortOrder
    usedDays?: SortOrder
    remainingDays?: SortOrder
  }

  export type LeaveRequestCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestAvgOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type LeaveRequestMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    leaveType?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    totalDays?: SortOrder
    reason?: SortOrder
    status?: SortOrder
    approvedById?: SortOrder
    approvedAt?: SortOrder
    rejectionReason?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type LeaveRequestSumOrderByAggregateInput = {
    totalDays?: SortOrder
  }

  export type NotificationCountOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMaxOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type NotificationMinOrderByAggregateInput = {
    id?: SortOrder
    userId?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    title?: SortOrder
    message?: SortOrder
    isRead?: SortOrder
    data?: SortOrder
    createdAt?: SortOrder
  }

  export type SettingCountOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMaxOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type SettingMinOrderByAggregateInput = {
    id?: SortOrder
    key?: SortOrder
    value?: SortOrder
    description?: SortOrder
    category?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type ShiftRelationFilter = {
    is?: ShiftWhereInput
    isNot?: ShiftWhereInput
  }

  export type ShiftAssignmentCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftAssignmentMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
  }

  export type ShiftAssignmentMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    shiftId?: SortOrder
    startDate?: SortOrder
    endDate?: SortOrder
    isActive?: SortOrder
    assignedById?: SortOrder
    createdAt?: SortOrder
  }

  export type TerminalCountOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    firmwareVersion?: SortOrder
    location?: SortOrder
    isOnline?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalAvgOrderByAggregateInput = {
    port?: SortOrder
  }

  export type TerminalMaxOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    firmwareVersion?: SortOrder
    location?: SortOrder
    isOnline?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalMinOrderByAggregateInput = {
    id?: SortOrder
    name?: SortOrder
    ipAddress?: SortOrder
    port?: SortOrder
    username?: SortOrder
    password?: SortOrder
    deviceType?: SortOrder
    serialNumber?: SortOrder
    firmwareVersion?: SortOrder
    location?: SortOrder
    isOnline?: SortOrder
    lastSyncAt?: SortOrder
    isActive?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TerminalSumOrderByAggregateInput = {
    port?: SortOrder
  }

  export type TimeEntryCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    breakStart?: SortOrder
    breakEnd?: SortOrder
    totalHours?: SortOrder
    regularHours?: SortOrder
    overtimeHours?: SortOrder
    breakMinutes?: SortOrder
    status?: SortOrder
    location?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    clockInPhoto?: SortOrder
    clockOutPhoto?: SortOrder
    notes?: SortOrder
    isManualEntry?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryAvgOrderByAggregateInput = {
    totalHours?: SortOrder
    regularHours?: SortOrder
    overtimeHours?: SortOrder
    breakMinutes?: SortOrder
  }

  export type TimeEntryMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    breakStart?: SortOrder
    breakEnd?: SortOrder
    totalHours?: SortOrder
    regularHours?: SortOrder
    overtimeHours?: SortOrder
    breakMinutes?: SortOrder
    status?: SortOrder
    location?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    clockInPhoto?: SortOrder
    clockOutPhoto?: SortOrder
    notes?: SortOrder
    isManualEntry?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntryMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    clockIn?: SortOrder
    clockOut?: SortOrder
    breakStart?: SortOrder
    breakEnd?: SortOrder
    totalHours?: SortOrder
    regularHours?: SortOrder
    overtimeHours?: SortOrder
    breakMinutes?: SortOrder
    status?: SortOrder
    location?: SortOrder
    terminalId?: SortOrder
    verifyMethod?: SortOrder
    clockInPhoto?: SortOrder
    clockOutPhoto?: SortOrder
    notes?: SortOrder
    isManualEntry?: SortOrder
    approvedById?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type TimeEntrySumOrderByAggregateInput = {
    totalHours?: SortOrder
    regularHours?: SortOrder
    overtimeHours?: SortOrder
    breakMinutes?: SortOrder
  }

  export type EmployeeRateCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hourlyRate?: SortOrder
    dailyRate?: SortOrder
    salary?: SortOrder
    overtimeRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    currency?: SortOrder
    rateType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeRateAvgOrderByAggregateInput = {
    hourlyRate?: SortOrder
    dailyRate?: SortOrder
    salary?: SortOrder
    overtimeRate?: SortOrder
  }

  export type EmployeeRateMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hourlyRate?: SortOrder
    dailyRate?: SortOrder
    salary?: SortOrder
    overtimeRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    currency?: SortOrder
    rateType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeRateMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    hourlyRate?: SortOrder
    dailyRate?: SortOrder
    salary?: SortOrder
    overtimeRate?: SortOrder
    effectiveFrom?: SortOrder
    effectiveTo?: SortOrder
    currency?: SortOrder
    rateType?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type EmployeeRateSumOrderByAggregateInput = {
    hourlyRate?: SortOrder
    dailyRate?: SortOrder
    salary?: SortOrder
    overtimeRate?: SortOrder
  }

  export type PayrollDeductionCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    deductionType?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    month?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    appliedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollDeductionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type PayrollDeductionMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    deductionType?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    month?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    appliedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollDeductionMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    deductionType?: SortOrder
    amount?: SortOrder
    reason?: SortOrder
    description?: SortOrder
    month?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    appliedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type PayrollDeductionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InfractionCountOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    reportedBy?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfractionAvgOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type InfractionMaxOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    reportedBy?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfractionMinOrderByAggregateInput = {
    id?: SortOrder
    employeeId?: SortOrder
    type?: SortOrder
    severity?: SortOrder
    amount?: SortOrder
    description?: SortOrder
    date?: SortOrder
    reportedBy?: SortOrder
    status?: SortOrder
    approvedBy?: SortOrder
    approvedAt?: SortOrder
    notes?: SortOrder
    createdAt?: SortOrder
    updatedAt?: SortOrder
  }

  export type InfractionSumOrderByAggregateInput = {
    amount?: SortOrder
  }

  export type AuditLogCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EmployeeCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveRequestCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type DepartmentCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput> | DepartmentCreateWithoutCreatedByInput[] | DepartmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCreatedByInput | DepartmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: DepartmentCreateManyCreatedByInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ShiftCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput> | ShiftCreateWithoutCreatedByInput[] | ShiftUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutCreatedByInput | ShiftCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShiftCreateManyCreatedByInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ShiftAssignmentCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput> | ShiftAssignmentCreateWithoutAssignedByInput[] | ShiftAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutAssignedByInput | ShiftAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ShiftAssignmentCreateManyAssignedByInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type PayrollDeductionCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput> | PayrollDeductionCreateWithoutApprovedByInput[] | PayrollDeductionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutApprovedByInput | PayrollDeductionCreateOrConnectWithoutApprovedByInput[]
    createMany?: PayrollDeductionCreateManyApprovedByInputEnvelope
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
  }

  export type InfractionCreateNestedManyWithoutReportedByInput = {
    create?: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput> | InfractionCreateWithoutReportedByInput[] | InfractionUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutReportedByInput | InfractionCreateOrConnectWithoutReportedByInput[]
    createMany?: InfractionCreateManyReportedByInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type InfractionCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput> | InfractionCreateWithoutApprovedByInput[] | InfractionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutApprovedByInput | InfractionCreateOrConnectWithoutApprovedByInput[]
    createMany?: InfractionCreateManyApprovedByInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type AuditLogUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedOneWithoutUserInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    connect?: EmployeeWhereUniqueInput
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutUserInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type DepartmentUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput> | DepartmentCreateWithoutCreatedByInput[] | DepartmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCreatedByInput | DepartmentCreateOrConnectWithoutCreatedByInput[]
    createMany?: DepartmentCreateManyCreatedByInputEnvelope
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
  }

  export type ShiftUncheckedCreateNestedManyWithoutCreatedByInput = {
    create?: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput> | ShiftCreateWithoutCreatedByInput[] | ShiftUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutCreatedByInput | ShiftCreateOrConnectWithoutCreatedByInput[]
    createMany?: ShiftCreateManyCreatedByInputEnvelope
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput = {
    create?: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput> | ShiftAssignmentCreateWithoutAssignedByInput[] | ShiftAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutAssignedByInput | ShiftAssignmentCreateOrConnectWithoutAssignedByInput[]
    createMany?: ShiftAssignmentCreateManyAssignedByInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput> | PayrollDeductionCreateWithoutApprovedByInput[] | PayrollDeductionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutApprovedByInput | PayrollDeductionCreateOrConnectWithoutApprovedByInput[]
    createMany?: PayrollDeductionCreateManyApprovedByInputEnvelope
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
  }

  export type InfractionUncheckedCreateNestedManyWithoutReportedByInput = {
    create?: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput> | InfractionCreateWithoutReportedByInput[] | InfractionUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutReportedByInput | InfractionCreateOrConnectWithoutReportedByInput[]
    createMany?: InfractionCreateManyReportedByInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type InfractionUncheckedCreateNestedManyWithoutApprovedByInput = {
    create?: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput> | InfractionCreateWithoutApprovedByInput[] | InfractionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutApprovedByInput | InfractionCreateOrConnectWithoutApprovedByInput[]
    createMany?: InfractionCreateManyApprovedByInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type StringFieldUpdateOperationsInput = {
    set?: string
  }

  export type BoolFieldUpdateOperationsInput = {
    set?: boolean
  }

  export type DateTimeFieldUpdateOperationsInput = {
    set?: Date | string
  }

  export type AuditLogUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EmployeeUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type DepartmentUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput> | DepartmentCreateWithoutCreatedByInput[] | DepartmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCreatedByInput | DepartmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCreatedByInput | DepartmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DepartmentCreateManyCreatedByInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCreatedByInput | DepartmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCreatedByInput | DepartmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ShiftUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput> | ShiftCreateWithoutCreatedByInput[] | ShiftUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutCreatedByInput | ShiftCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutCreatedByInput | ShiftUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShiftCreateManyCreatedByInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutCreatedByInput | ShiftUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutCreatedByInput | ShiftUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput> | ShiftAssignmentCreateWithoutAssignedByInput[] | ShiftAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutAssignedByInput | ShiftAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ShiftAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ShiftAssignmentCreateManyAssignedByInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ShiftAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutAssignedByInput | ShiftAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type PayrollDeductionUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput> | PayrollDeductionCreateWithoutApprovedByInput[] | PayrollDeductionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutApprovedByInput | PayrollDeductionCreateOrConnectWithoutApprovedByInput[]
    upsert?: PayrollDeductionUpsertWithWhereUniqueWithoutApprovedByInput | PayrollDeductionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: PayrollDeductionCreateManyApprovedByInputEnvelope
    set?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    disconnect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    delete?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    update?: PayrollDeductionUpdateWithWhereUniqueWithoutApprovedByInput | PayrollDeductionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: PayrollDeductionUpdateManyWithWhereWithoutApprovedByInput | PayrollDeductionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
  }

  export type InfractionUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput> | InfractionCreateWithoutReportedByInput[] | InfractionUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutReportedByInput | InfractionCreateOrConnectWithoutReportedByInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutReportedByInput | InfractionUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: InfractionCreateManyReportedByInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutReportedByInput | InfractionUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutReportedByInput | InfractionUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type InfractionUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput> | InfractionCreateWithoutApprovedByInput[] | InfractionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutApprovedByInput | InfractionCreateOrConnectWithoutApprovedByInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutApprovedByInput | InfractionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: InfractionCreateManyApprovedByInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutApprovedByInput | InfractionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutApprovedByInput | InfractionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type AuditLogUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput> | AuditLogCreateWithoutUserInput[] | AuditLogUncheckedCreateWithoutUserInput[]
    connectOrCreate?: AuditLogCreateOrConnectWithoutUserInput | AuditLogCreateOrConnectWithoutUserInput[]
    upsert?: AuditLogUpsertWithWhereUniqueWithoutUserInput | AuditLogUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: AuditLogCreateManyUserInputEnvelope
    set?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    disconnect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    delete?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    connect?: AuditLogWhereUniqueInput | AuditLogWhereUniqueInput[]
    update?: AuditLogUpdateWithWhereUniqueWithoutUserInput | AuditLogUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: AuditLogUpdateManyWithWhereWithoutUserInput | AuditLogUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateOneWithoutUserNestedInput = {
    create?: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutUserInput
    upsert?: EmployeeUpsertWithoutUserInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutUserInput, EmployeeUpdateWithoutUserInput>, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput> | LeaveRequestCreateWithoutUserInput[] | LeaveRequestUncheckedCreateWithoutUserInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutUserInput | LeaveRequestCreateOrConnectWithoutUserInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutUserInput | LeaveRequestUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: LeaveRequestCreateManyUserInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutUserInput | LeaveRequestUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutUserInput | LeaveRequestUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserNestedInput = {
    create?: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput> | TimeEntryCreateWithoutUserInput[] | TimeEntryUncheckedCreateWithoutUserInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutUserInput | TimeEntryCreateOrConnectWithoutUserInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutUserInput | TimeEntryUpsertWithWhereUniqueWithoutUserInput[]
    createMany?: TimeEntryCreateManyUserInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutUserInput | TimeEntryUpdateWithWhereUniqueWithoutUserInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutUserInput | TimeEntryUpdateManyWithWhereWithoutUserInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput> | DepartmentCreateWithoutCreatedByInput[] | DepartmentUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: DepartmentCreateOrConnectWithoutCreatedByInput | DepartmentCreateOrConnectWithoutCreatedByInput[]
    upsert?: DepartmentUpsertWithWhereUniqueWithoutCreatedByInput | DepartmentUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: DepartmentCreateManyCreatedByInputEnvelope
    set?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    disconnect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    delete?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    connect?: DepartmentWhereUniqueInput | DepartmentWhereUniqueInput[]
    update?: DepartmentUpdateWithWhereUniqueWithoutCreatedByInput | DepartmentUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: DepartmentUpdateManyWithWhereWithoutCreatedByInput | DepartmentUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
  }

  export type ShiftUncheckedUpdateManyWithoutCreatedByNestedInput = {
    create?: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput> | ShiftCreateWithoutCreatedByInput[] | ShiftUncheckedCreateWithoutCreatedByInput[]
    connectOrCreate?: ShiftCreateOrConnectWithoutCreatedByInput | ShiftCreateOrConnectWithoutCreatedByInput[]
    upsert?: ShiftUpsertWithWhereUniqueWithoutCreatedByInput | ShiftUpsertWithWhereUniqueWithoutCreatedByInput[]
    createMany?: ShiftCreateManyCreatedByInputEnvelope
    set?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    disconnect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    delete?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    connect?: ShiftWhereUniqueInput | ShiftWhereUniqueInput[]
    update?: ShiftUpdateWithWhereUniqueWithoutCreatedByInput | ShiftUpdateWithWhereUniqueWithoutCreatedByInput[]
    updateMany?: ShiftUpdateManyWithWhereWithoutCreatedByInput | ShiftUpdateManyWithWhereWithoutCreatedByInput[]
    deleteMany?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput> | ShiftAssignmentCreateWithoutAssignedByInput[] | ShiftAssignmentUncheckedCreateWithoutAssignedByInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutAssignedByInput | ShiftAssignmentCreateOrConnectWithoutAssignedByInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutAssignedByInput | ShiftAssignmentUpsertWithWhereUniqueWithoutAssignedByInput[]
    createMany?: ShiftAssignmentCreateManyAssignedByInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutAssignedByInput | ShiftAssignmentUpdateWithWhereUniqueWithoutAssignedByInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutAssignedByInput | ShiftAssignmentUpdateManyWithWhereWithoutAssignedByInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput> | PayrollDeductionCreateWithoutApprovedByInput[] | PayrollDeductionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutApprovedByInput | PayrollDeductionCreateOrConnectWithoutApprovedByInput[]
    upsert?: PayrollDeductionUpsertWithWhereUniqueWithoutApprovedByInput | PayrollDeductionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: PayrollDeductionCreateManyApprovedByInputEnvelope
    set?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    disconnect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    delete?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    update?: PayrollDeductionUpdateWithWhereUniqueWithoutApprovedByInput | PayrollDeductionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: PayrollDeductionUpdateManyWithWhereWithoutApprovedByInput | PayrollDeductionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
  }

  export type InfractionUncheckedUpdateManyWithoutReportedByNestedInput = {
    create?: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput> | InfractionCreateWithoutReportedByInput[] | InfractionUncheckedCreateWithoutReportedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutReportedByInput | InfractionCreateOrConnectWithoutReportedByInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutReportedByInput | InfractionUpsertWithWhereUniqueWithoutReportedByInput[]
    createMany?: InfractionCreateManyReportedByInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutReportedByInput | InfractionUpdateWithWhereUniqueWithoutReportedByInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutReportedByInput | InfractionUpdateManyWithWhereWithoutReportedByInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type InfractionUncheckedUpdateManyWithoutApprovedByNestedInput = {
    create?: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput> | InfractionCreateWithoutApprovedByInput[] | InfractionUncheckedCreateWithoutApprovedByInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutApprovedByInput | InfractionCreateOrConnectWithoutApprovedByInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutApprovedByInput | InfractionUpsertWithWhereUniqueWithoutApprovedByInput[]
    createMany?: InfractionCreateManyApprovedByInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutApprovedByInput | InfractionUpdateWithWhereUniqueWithoutApprovedByInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutApprovedByInput | InfractionUpdateManyWithWhereWithoutApprovedByInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutDepartmentsCreatedInput = {
    create?: XOR<UserCreateWithoutDepartmentsCreatedInput, UserUncheckedCreateWithoutDepartmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutDepartmentInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type NullableStringFieldUpdateOperationsInput = {
    set?: string | null
  }

  export type NullableFloatFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutDepartmentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutDepartmentsCreatedInput, UserUncheckedCreateWithoutDepartmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutDepartmentsCreatedInput
    upsert?: UserUpsertWithoutDepartmentsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDepartmentsCreatedInput, UserUpdateWithoutDepartmentsCreatedInput>, UserUncheckedUpdateWithoutDepartmentsCreatedInput>
  }

  export type EmployeeUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput> | EmployeeCreateWithoutDepartmentInput[] | EmployeeUncheckedCreateWithoutDepartmentInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutDepartmentInput | EmployeeCreateOrConnectWithoutDepartmentInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutDepartmentInput | EmployeeUpsertWithWhereUniqueWithoutDepartmentInput[]
    createMany?: EmployeeCreateManyDepartmentInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutDepartmentInput | EmployeeUpdateWithWhereUniqueWithoutDepartmentInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutDepartmentInput | EmployeeUpdateManyWithWhereWithoutDepartmentInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutShiftsCreatedInput = {
    create?: XOR<UserCreateWithoutShiftsCreatedInput, UserUncheckedCreateWithoutShiftsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShiftAssignmentCreateNestedManyWithoutShiftInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput> | ShiftAssignmentCreateWithoutShiftInput[] | ShiftAssignmentUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftInput | ShiftAssignmentCreateOrConnectWithoutShiftInput[]
    createMany?: ShiftAssignmentCreateManyShiftInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutShiftInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput> | ShiftAssignmentCreateWithoutShiftInput[] | ShiftAssignmentUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftInput | ShiftAssignmentCreateOrConnectWithoutShiftInput[]
    createMany?: ShiftAssignmentCreateManyShiftInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type IntFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type FloatFieldUpdateOperationsInput = {
    set?: number
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type UserUpdateOneWithoutShiftsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutShiftsCreatedInput, UserUncheckedCreateWithoutShiftsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftsCreatedInput
    upsert?: UserUpsertWithoutShiftsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftsCreatedInput, UserUpdateWithoutShiftsCreatedInput>, UserUncheckedUpdateWithoutShiftsCreatedInput>
  }

  export type EmployeeUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutShiftNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput> | ShiftAssignmentCreateWithoutShiftInput[] | ShiftAssignmentUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftInput | ShiftAssignmentCreateOrConnectWithoutShiftInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutShiftInput | ShiftAssignmentUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: ShiftAssignmentCreateManyShiftInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutShiftInput | ShiftAssignmentUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutShiftInput | ShiftAssignmentUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput> | EmployeeCreateWithoutShiftInput[] | EmployeeUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftInput | EmployeeCreateOrConnectWithoutShiftInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutShiftInput | EmployeeUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: EmployeeCreateManyShiftInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutShiftInput | EmployeeUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutShiftInput | EmployeeUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutShiftNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput> | ShiftAssignmentCreateWithoutShiftInput[] | ShiftAssignmentUncheckedCreateWithoutShiftInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutShiftInput | ShiftAssignmentCreateOrConnectWithoutShiftInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutShiftInput | ShiftAssignmentUpsertWithWhereUniqueWithoutShiftInput[]
    createMany?: ShiftAssignmentCreateManyShiftInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutShiftInput | ShiftAssignmentUpdateWithWhereUniqueWithoutShiftInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutShiftInput | ShiftAssignmentUpdateManyWithWhereWithoutShiftInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type AttendanceLogCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type BiometricDataCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput> | BiometricDataCreateWithoutEmployeeInput[] | BiometricDataUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutEmployeeInput | BiometricDataCreateOrConnectWithoutEmployeeInput[]
    createMany?: BiometricDataCreateManyEmployeeInputEnvelope
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
  }

  export type DepartmentCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    connect?: DepartmentWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutOther_EmployeeInput = {
    create?: XOR<EmployeeCreateWithoutOther_EmployeeInput, EmployeeUncheckedCreateWithoutOther_EmployeeInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOther_EmployeeInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput> | EmployeeCreateWithoutEmployeeInput[] | EmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInput | EmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeCreateManyEmployeeInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type ShiftCreateNestedOneWithoutEmployeesInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    connect?: ShiftWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    connect?: UserWhereUniqueInput
  }

  export type LeaveBalanceCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type NotificationCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput> | NotificationCreateWithoutEmployeeInput[] | NotificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmployeeInput | NotificationCreateOrConnectWithoutEmployeeInput[]
    createMany?: NotificationCreateManyEmployeeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ShiftAssignmentCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput> | ShiftAssignmentCreateWithoutEmployeeInput[] | ShiftAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutEmployeeInput | ShiftAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftAssignmentCreateManyEmployeeInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput> | TimeEntryCreateWithoutEmployeeInput[] | TimeEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutEmployeeInput | TimeEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: TimeEntryCreateManyEmployeeInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type EmployeeRateCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeRateCreateOrConnectWithoutEmployeeInput
    connect?: EmployeeRateWhereUniqueInput
  }

  export type PayrollDeductionCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput> | PayrollDeductionCreateWithoutEmployeeInput[] | PayrollDeductionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutEmployeeInput | PayrollDeductionCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollDeductionCreateManyEmployeeInputEnvelope
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
  }

  export type InfractionCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput> | InfractionCreateWithoutEmployeeInput[] | InfractionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutEmployeeInput | InfractionCreateOrConnectWithoutEmployeeInput[]
    createMany?: InfractionCreateManyEmployeeInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput> | BiometricDataCreateWithoutEmployeeInput[] | BiometricDataUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutEmployeeInput | BiometricDataCreateOrConnectWithoutEmployeeInput[]
    createMany?: BiometricDataCreateManyEmployeeInputEnvelope
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
  }

  export type EmployeeUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput> | EmployeeCreateWithoutEmployeeInput[] | EmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInput | EmployeeCreateOrConnectWithoutEmployeeInput[]
    createMany?: EmployeeCreateManyEmployeeInputEnvelope
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
  }

  export type LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
  }

  export type LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
  }

  export type NotificationUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput> | NotificationCreateWithoutEmployeeInput[] | NotificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmployeeInput | NotificationCreateOrConnectWithoutEmployeeInput[]
    createMany?: NotificationCreateManyEmployeeInputEnvelope
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
  }

  export type ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput> | ShiftAssignmentCreateWithoutEmployeeInput[] | ShiftAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutEmployeeInput | ShiftAssignmentCreateOrConnectWithoutEmployeeInput[]
    createMany?: ShiftAssignmentCreateManyEmployeeInputEnvelope
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput> | TimeEntryCreateWithoutEmployeeInput[] | TimeEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutEmployeeInput | TimeEntryCreateOrConnectWithoutEmployeeInput[]
    createMany?: TimeEntryCreateManyEmployeeInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput = {
    create?: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeRateCreateOrConnectWithoutEmployeeInput
    connect?: EmployeeRateWhereUniqueInput
  }

  export type PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput> | PayrollDeductionCreateWithoutEmployeeInput[] | PayrollDeductionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutEmployeeInput | PayrollDeductionCreateOrConnectWithoutEmployeeInput[]
    createMany?: PayrollDeductionCreateManyEmployeeInputEnvelope
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
  }

  export type InfractionUncheckedCreateNestedManyWithoutEmployeeInput = {
    create?: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput> | InfractionCreateWithoutEmployeeInput[] | InfractionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutEmployeeInput | InfractionCreateOrConnectWithoutEmployeeInput[]
    createMany?: InfractionCreateManyEmployeeInputEnvelope
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
  }

  export type NullableDateTimeFieldUpdateOperationsInput = {
    set?: Date | string | null
  }

  export type AttendanceLogUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type BiometricDataUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput> | BiometricDataCreateWithoutEmployeeInput[] | BiometricDataUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutEmployeeInput | BiometricDataCreateOrConnectWithoutEmployeeInput[]
    upsert?: BiometricDataUpsertWithWhereUniqueWithoutEmployeeInput | BiometricDataUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BiometricDataCreateManyEmployeeInputEnvelope
    set?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    disconnect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    delete?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    update?: BiometricDataUpdateWithWhereUniqueWithoutEmployeeInput | BiometricDataUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BiometricDataUpdateManyWithWhereWithoutEmployeeInput | BiometricDataUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
  }

  export type DepartmentUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: DepartmentCreateOrConnectWithoutEmployeesInput
    upsert?: DepartmentUpsertWithoutEmployeesInput
    disconnect?: DepartmentWhereInput | boolean
    delete?: DepartmentWhereInput | boolean
    connect?: DepartmentWhereUniqueInput
    update?: XOR<XOR<DepartmentUpdateToOneWithWhereWithoutEmployeesInput, DepartmentUpdateWithoutEmployeesInput>, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type EmployeeUpdateOneWithoutOther_EmployeeNestedInput = {
    create?: XOR<EmployeeCreateWithoutOther_EmployeeInput, EmployeeUncheckedCreateWithoutOther_EmployeeInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutOther_EmployeeInput
    upsert?: EmployeeUpsertWithoutOther_EmployeeInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutOther_EmployeeInput, EmployeeUpdateWithoutOther_EmployeeInput>, EmployeeUncheckedUpdateWithoutOther_EmployeeInput>
  }

  export type EmployeeUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput> | EmployeeCreateWithoutEmployeeInput[] | EmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInput | EmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeCreateManyEmployeeInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmployeeInput | EmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type ShiftUpdateOneWithoutEmployeesNestedInput = {
    create?: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutEmployeesInput
    upsert?: ShiftUpsertWithoutEmployeesInput
    disconnect?: ShiftWhereInput | boolean
    delete?: ShiftWhereInput | boolean
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutEmployeesInput, ShiftUpdateWithoutEmployeesInput>, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type UserUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: UserCreateOrConnectWithoutEmployeeInput
    upsert?: UserUpsertWithoutEmployeeInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutEmployeeInput, UserUpdateWithoutEmployeeInput>, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveBalanceUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput | LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type NotificationUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput> | NotificationCreateWithoutEmployeeInput[] | NotificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmployeeInput | NotificationCreateOrConnectWithoutEmployeeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEmployeeInput | NotificationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: NotificationCreateManyEmployeeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEmployeeInput | NotificationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEmployeeInput | NotificationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShiftAssignmentUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput> | ShiftAssignmentCreateWithoutEmployeeInput[] | ShiftAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutEmployeeInput | ShiftAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | ShiftAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftAssignmentCreateManyEmployeeInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | ShiftAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutEmployeeInput | ShiftAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput> | TimeEntryCreateWithoutEmployeeInput[] | TimeEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutEmployeeInput | TimeEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutEmployeeInput | TimeEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TimeEntryCreateManyEmployeeInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutEmployeeInput | TimeEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutEmployeeInput | TimeEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type EmployeeRateUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeRateCreateOrConnectWithoutEmployeeInput
    upsert?: EmployeeRateUpsertWithoutEmployeeInput
    disconnect?: EmployeeRateWhereInput | boolean
    delete?: EmployeeRateWhereInput | boolean
    connect?: EmployeeRateWhereUniqueInput
    update?: XOR<XOR<EmployeeRateUpdateToOneWithWhereWithoutEmployeeInput, EmployeeRateUpdateWithoutEmployeeInput>, EmployeeRateUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollDeductionUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput> | PayrollDeductionCreateWithoutEmployeeInput[] | PayrollDeductionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutEmployeeInput | PayrollDeductionCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollDeductionUpsertWithWhereUniqueWithoutEmployeeInput | PayrollDeductionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollDeductionCreateManyEmployeeInputEnvelope
    set?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    disconnect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    delete?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    update?: PayrollDeductionUpdateWithWhereUniqueWithoutEmployeeInput | PayrollDeductionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollDeductionUpdateManyWithWhereWithoutEmployeeInput | PayrollDeductionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
  }

  export type InfractionUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput> | InfractionCreateWithoutEmployeeInput[] | InfractionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutEmployeeInput | InfractionCreateOrConnectWithoutEmployeeInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutEmployeeInput | InfractionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: InfractionCreateManyEmployeeInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutEmployeeInput | InfractionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutEmployeeInput | InfractionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput> | AttendanceLogCreateWithoutEmployeeInput[] | AttendanceLogUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutEmployeeInput | AttendanceLogCreateOrConnectWithoutEmployeeInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: AttendanceLogCreateManyEmployeeInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput | AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutEmployeeInput | AttendanceLogUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput> | BiometricDataCreateWithoutEmployeeInput[] | BiometricDataUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: BiometricDataCreateOrConnectWithoutEmployeeInput | BiometricDataCreateOrConnectWithoutEmployeeInput[]
    upsert?: BiometricDataUpsertWithWhereUniqueWithoutEmployeeInput | BiometricDataUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: BiometricDataCreateManyEmployeeInputEnvelope
    set?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    disconnect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    delete?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    connect?: BiometricDataWhereUniqueInput | BiometricDataWhereUniqueInput[]
    update?: BiometricDataUpdateWithWhereUniqueWithoutEmployeeInput | BiometricDataUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: BiometricDataUpdateManyWithWhereWithoutEmployeeInput | BiometricDataUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput> | EmployeeCreateWithoutEmployeeInput[] | EmployeeUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInput | EmployeeCreateOrConnectWithoutEmployeeInput[]
    upsert?: EmployeeUpsertWithWhereUniqueWithoutEmployeeInput | EmployeeUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: EmployeeCreateManyEmployeeInputEnvelope
    set?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    disconnect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    delete?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    connect?: EmployeeWhereUniqueInput | EmployeeWhereUniqueInput[]
    update?: EmployeeUpdateWithWhereUniqueWithoutEmployeeInput | EmployeeUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: EmployeeUpdateManyWithWhereWithoutEmployeeInput | EmployeeUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput> | LeaveBalanceCreateWithoutEmployeeInput[] | LeaveBalanceUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveBalanceCreateOrConnectWithoutEmployeeInput | LeaveBalanceCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveBalanceCreateManyEmployeeInputEnvelope
    set?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    disconnect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    delete?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    connect?: LeaveBalanceWhereUniqueInput | LeaveBalanceWhereUniqueInput[]
    update?: LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput | LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput | LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput> | LeaveRequestCreateWithoutEmployeeInput[] | LeaveRequestUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: LeaveRequestCreateOrConnectWithoutEmployeeInput | LeaveRequestCreateOrConnectWithoutEmployeeInput[]
    upsert?: LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: LeaveRequestCreateManyEmployeeInputEnvelope
    set?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    disconnect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    delete?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    connect?: LeaveRequestWhereUniqueInput | LeaveRequestWhereUniqueInput[]
    update?: LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput | LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: LeaveRequestUpdateManyWithWhereWithoutEmployeeInput | LeaveRequestUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
  }

  export type NotificationUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput> | NotificationCreateWithoutEmployeeInput[] | NotificationUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: NotificationCreateOrConnectWithoutEmployeeInput | NotificationCreateOrConnectWithoutEmployeeInput[]
    upsert?: NotificationUpsertWithWhereUniqueWithoutEmployeeInput | NotificationUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: NotificationCreateManyEmployeeInputEnvelope
    set?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    disconnect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    delete?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    connect?: NotificationWhereUniqueInput | NotificationWhereUniqueInput[]
    update?: NotificationUpdateWithWhereUniqueWithoutEmployeeInput | NotificationUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: NotificationUpdateManyWithWhereWithoutEmployeeInput | NotificationUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput> | ShiftAssignmentCreateWithoutEmployeeInput[] | ShiftAssignmentUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: ShiftAssignmentCreateOrConnectWithoutEmployeeInput | ShiftAssignmentCreateOrConnectWithoutEmployeeInput[]
    upsert?: ShiftAssignmentUpsertWithWhereUniqueWithoutEmployeeInput | ShiftAssignmentUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: ShiftAssignmentCreateManyEmployeeInputEnvelope
    set?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    disconnect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    delete?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    connect?: ShiftAssignmentWhereUniqueInput | ShiftAssignmentWhereUniqueInput[]
    update?: ShiftAssignmentUpdateWithWhereUniqueWithoutEmployeeInput | ShiftAssignmentUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: ShiftAssignmentUpdateManyWithWhereWithoutEmployeeInput | ShiftAssignmentUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput> | TimeEntryCreateWithoutEmployeeInput[] | TimeEntryUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutEmployeeInput | TimeEntryCreateOrConnectWithoutEmployeeInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutEmployeeInput | TimeEntryUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: TimeEntryCreateManyEmployeeInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutEmployeeInput | TimeEntryUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutEmployeeInput | TimeEntryUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput = {
    create?: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
    connectOrCreate?: EmployeeRateCreateOrConnectWithoutEmployeeInput
    upsert?: EmployeeRateUpsertWithoutEmployeeInput
    disconnect?: EmployeeRateWhereInput | boolean
    delete?: EmployeeRateWhereInput | boolean
    connect?: EmployeeRateWhereUniqueInput
    update?: XOR<XOR<EmployeeRateUpdateToOneWithWhereWithoutEmployeeInput, EmployeeRateUpdateWithoutEmployeeInput>, EmployeeRateUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput> | PayrollDeductionCreateWithoutEmployeeInput[] | PayrollDeductionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: PayrollDeductionCreateOrConnectWithoutEmployeeInput | PayrollDeductionCreateOrConnectWithoutEmployeeInput[]
    upsert?: PayrollDeductionUpsertWithWhereUniqueWithoutEmployeeInput | PayrollDeductionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: PayrollDeductionCreateManyEmployeeInputEnvelope
    set?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    disconnect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    delete?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    connect?: PayrollDeductionWhereUniqueInput | PayrollDeductionWhereUniqueInput[]
    update?: PayrollDeductionUpdateWithWhereUniqueWithoutEmployeeInput | PayrollDeductionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: PayrollDeductionUpdateManyWithWhereWithoutEmployeeInput | PayrollDeductionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
  }

  export type InfractionUncheckedUpdateManyWithoutEmployeeNestedInput = {
    create?: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput> | InfractionCreateWithoutEmployeeInput[] | InfractionUncheckedCreateWithoutEmployeeInput[]
    connectOrCreate?: InfractionCreateOrConnectWithoutEmployeeInput | InfractionCreateOrConnectWithoutEmployeeInput[]
    upsert?: InfractionUpsertWithWhereUniqueWithoutEmployeeInput | InfractionUpsertWithWhereUniqueWithoutEmployeeInput[]
    createMany?: InfractionCreateManyEmployeeInputEnvelope
    set?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    disconnect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    delete?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    connect?: InfractionWhereUniqueInput | InfractionWhereUniqueInput[]
    update?: InfractionUpdateWithWhereUniqueWithoutEmployeeInput | InfractionUpdateWithWhereUniqueWithoutEmployeeInput[]
    updateMany?: InfractionUpdateManyWithWhereWithoutEmployeeInput | InfractionUpdateManyWithWhereWithoutEmployeeInput[]
    deleteMany?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutAuditLogInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    connect?: UserWhereUniqueInput
  }

  export type UserUpdateOneWithoutAuditLogNestedInput = {
    create?: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    connectOrCreate?: UserCreateOrConnectWithoutAuditLogInput
    upsert?: UserUpsertWithoutAuditLogInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutAuditLogInput, UserUpdateWithoutAuditLogInput>, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type EmployeeCreateNestedOneWithoutAttendanceLogInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogInput, EmployeeUncheckedCreateWithoutAttendanceLogInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogInput
    connect?: EmployeeWhereUniqueInput
  }

  export type TerminalCreateNestedOneWithoutAttendanceLogInput = {
    create?: XOR<TerminalCreateWithoutAttendanceLogInput, TerminalUncheckedCreateWithoutAttendanceLogInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutAttendanceLogInput
    connect?: TerminalWhereUniqueInput
  }

  export type NullableBoolFieldUpdateOperationsInput = {
    set?: boolean | null
  }

  export type EmployeeUpdateOneRequiredWithoutAttendanceLogNestedInput = {
    create?: XOR<EmployeeCreateWithoutAttendanceLogInput, EmployeeUncheckedCreateWithoutAttendanceLogInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutAttendanceLogInput
    upsert?: EmployeeUpsertWithoutAttendanceLogInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutAttendanceLogInput, EmployeeUpdateWithoutAttendanceLogInput>, EmployeeUncheckedUpdateWithoutAttendanceLogInput>
  }

  export type TerminalUpdateOneWithoutAttendanceLogNestedInput = {
    create?: XOR<TerminalCreateWithoutAttendanceLogInput, TerminalUncheckedCreateWithoutAttendanceLogInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutAttendanceLogInput
    upsert?: TerminalUpsertWithoutAttendanceLogInput
    disconnect?: TerminalWhereInput | boolean
    delete?: TerminalWhereInput | boolean
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutAttendanceLogInput, TerminalUpdateWithoutAttendanceLogInput>, TerminalUncheckedUpdateWithoutAttendanceLogInput>
  }

  export type EmployeeCreateNestedOneWithoutBiometricDataInput = {
    create?: XOR<EmployeeCreateWithoutBiometricDataInput, EmployeeUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBiometricDataInput
    connect?: EmployeeWhereUniqueInput
  }

  export type NullableIntFieldUpdateOperationsInput = {
    set?: number | null
    increment?: number
    decrement?: number
    multiply?: number
    divide?: number
  }

  export type EmployeeUpdateOneRequiredWithoutBiometricDataNestedInput = {
    create?: XOR<EmployeeCreateWithoutBiometricDataInput, EmployeeUncheckedCreateWithoutBiometricDataInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutBiometricDataInput
    upsert?: EmployeeUpsertWithoutBiometricDataInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutBiometricDataInput, EmployeeUpdateWithoutBiometricDataInput>, EmployeeUncheckedUpdateWithoutBiometricDataInput>
  }

  export type EmployeeCreateNestedOneWithoutLeaveBalanceInput = {
    create?: XOR<EmployeeCreateWithoutLeaveBalanceInput, EmployeeUncheckedCreateWithoutLeaveBalanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveBalanceInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveBalanceNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveBalanceInput, EmployeeUncheckedCreateWithoutLeaveBalanceInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveBalanceInput
    upsert?: EmployeeUpsertWithoutLeaveBalanceInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveBalanceInput, EmployeeUpdateWithoutLeaveBalanceInput>, EmployeeUncheckedUpdateWithoutLeaveBalanceInput>
  }

  export type UserCreateNestedOneWithoutLeaveRequestInput = {
    create?: XOR<UserCreateWithoutLeaveRequestInput, UserUncheckedCreateWithoutLeaveRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutLeaveRequestInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestInput, EmployeeUncheckedCreateWithoutLeaveRequestInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserUpdateOneWithoutLeaveRequestNestedInput = {
    create?: XOR<UserCreateWithoutLeaveRequestInput, UserUncheckedCreateWithoutLeaveRequestInput>
    connectOrCreate?: UserCreateOrConnectWithoutLeaveRequestInput
    upsert?: UserUpsertWithoutLeaveRequestInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutLeaveRequestInput, UserUpdateWithoutLeaveRequestInput>, UserUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type EmployeeUpdateOneRequiredWithoutLeaveRequestNestedInput = {
    create?: XOR<EmployeeCreateWithoutLeaveRequestInput, EmployeeUncheckedCreateWithoutLeaveRequestInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutLeaveRequestInput
    upsert?: EmployeeUpsertWithoutLeaveRequestInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutLeaveRequestInput, EmployeeUpdateWithoutLeaveRequestInput>, EmployeeUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type EmployeeCreateNestedOneWithoutNotificationInput = {
    create?: XOR<EmployeeCreateWithoutNotificationInput, EmployeeUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutNotificationInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneWithoutNotificationNestedInput = {
    create?: XOR<EmployeeCreateWithoutNotificationInput, EmployeeUncheckedCreateWithoutNotificationInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutNotificationInput
    upsert?: EmployeeUpsertWithoutNotificationInput
    disconnect?: EmployeeWhereInput | boolean
    delete?: EmployeeWhereInput | boolean
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutNotificationInput, EmployeeUpdateWithoutNotificationInput>, EmployeeUncheckedUpdateWithoutNotificationInput>
  }

  export type EmployeeCreateNestedOneWithoutShiftAssignmentInput = {
    create?: XOR<EmployeeCreateWithoutShiftAssignmentInput, EmployeeUncheckedCreateWithoutShiftAssignmentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftAssignmentInput
    connect?: EmployeeWhereUniqueInput
  }

  export type ShiftCreateNestedOneWithoutShiftAssignmentInput = {
    create?: XOR<ShiftCreateWithoutShiftAssignmentInput, ShiftUncheckedCreateWithoutShiftAssignmentInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutShiftAssignmentInput
    connect?: ShiftWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutShiftAssignmentsCreatedInput = {
    create?: XOR<UserCreateWithoutShiftAssignmentsCreatedInput, UserUncheckedCreateWithoutShiftAssignmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftAssignmentsCreatedInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutShiftAssignmentNestedInput = {
    create?: XOR<EmployeeCreateWithoutShiftAssignmentInput, EmployeeUncheckedCreateWithoutShiftAssignmentInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutShiftAssignmentInput
    upsert?: EmployeeUpsertWithoutShiftAssignmentInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutShiftAssignmentInput, EmployeeUpdateWithoutShiftAssignmentInput>, EmployeeUncheckedUpdateWithoutShiftAssignmentInput>
  }

  export type ShiftUpdateOneRequiredWithoutShiftAssignmentNestedInput = {
    create?: XOR<ShiftCreateWithoutShiftAssignmentInput, ShiftUncheckedCreateWithoutShiftAssignmentInput>
    connectOrCreate?: ShiftCreateOrConnectWithoutShiftAssignmentInput
    upsert?: ShiftUpsertWithoutShiftAssignmentInput
    connect?: ShiftWhereUniqueInput
    update?: XOR<XOR<ShiftUpdateToOneWithWhereWithoutShiftAssignmentInput, ShiftUpdateWithoutShiftAssignmentInput>, ShiftUncheckedUpdateWithoutShiftAssignmentInput>
  }

  export type UserUpdateOneWithoutShiftAssignmentsCreatedNestedInput = {
    create?: XOR<UserCreateWithoutShiftAssignmentsCreatedInput, UserUncheckedCreateWithoutShiftAssignmentsCreatedInput>
    connectOrCreate?: UserCreateOrConnectWithoutShiftAssignmentsCreatedInput
    upsert?: UserUpsertWithoutShiftAssignmentsCreatedInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutShiftAssignmentsCreatedInput, UserUpdateWithoutShiftAssignmentsCreatedInput>, UserUncheckedUpdateWithoutShiftAssignmentsCreatedInput>
  }

  export type AttendanceLogCreateNestedManyWithoutTerminalInput = {
    create?: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput> | AttendanceLogCreateWithoutTerminalInput[] | AttendanceLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutTerminalInput | AttendanceLogCreateOrConnectWithoutTerminalInput[]
    createMany?: AttendanceLogCreateManyTerminalInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type TimeEntryCreateNestedManyWithoutTerminalInput = {
    create?: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput> | TimeEntryCreateWithoutTerminalInput[] | TimeEntryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTerminalInput | TimeEntryCreateOrConnectWithoutTerminalInput[]
    createMany?: TimeEntryCreateManyTerminalInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type AttendanceLogUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput> | AttendanceLogCreateWithoutTerminalInput[] | AttendanceLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutTerminalInput | AttendanceLogCreateOrConnectWithoutTerminalInput[]
    createMany?: AttendanceLogCreateManyTerminalInputEnvelope
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
  }

  export type TimeEntryUncheckedCreateNestedManyWithoutTerminalInput = {
    create?: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput> | TimeEntryCreateWithoutTerminalInput[] | TimeEntryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTerminalInput | TimeEntryCreateOrConnectWithoutTerminalInput[]
    createMany?: TimeEntryCreateManyTerminalInputEnvelope
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
  }

  export type AttendanceLogUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput> | AttendanceLogCreateWithoutTerminalInput[] | AttendanceLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutTerminalInput | AttendanceLogCreateOrConnectWithoutTerminalInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutTerminalInput | AttendanceLogUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: AttendanceLogCreateManyTerminalInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutTerminalInput | AttendanceLogUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutTerminalInput | AttendanceLogUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type TimeEntryUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput> | TimeEntryCreateWithoutTerminalInput[] | TimeEntryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTerminalInput | TimeEntryCreateOrConnectWithoutTerminalInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutTerminalInput | TimeEntryUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: TimeEntryCreateManyTerminalInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutTerminalInput | TimeEntryUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutTerminalInput | TimeEntryUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type AttendanceLogUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput> | AttendanceLogCreateWithoutTerminalInput[] | AttendanceLogUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: AttendanceLogCreateOrConnectWithoutTerminalInput | AttendanceLogCreateOrConnectWithoutTerminalInput[]
    upsert?: AttendanceLogUpsertWithWhereUniqueWithoutTerminalInput | AttendanceLogUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: AttendanceLogCreateManyTerminalInputEnvelope
    set?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    disconnect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    delete?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    connect?: AttendanceLogWhereUniqueInput | AttendanceLogWhereUniqueInput[]
    update?: AttendanceLogUpdateWithWhereUniqueWithoutTerminalInput | AttendanceLogUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: AttendanceLogUpdateManyWithWhereWithoutTerminalInput | AttendanceLogUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
  }

  export type TimeEntryUncheckedUpdateManyWithoutTerminalNestedInput = {
    create?: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput> | TimeEntryCreateWithoutTerminalInput[] | TimeEntryUncheckedCreateWithoutTerminalInput[]
    connectOrCreate?: TimeEntryCreateOrConnectWithoutTerminalInput | TimeEntryCreateOrConnectWithoutTerminalInput[]
    upsert?: TimeEntryUpsertWithWhereUniqueWithoutTerminalInput | TimeEntryUpsertWithWhereUniqueWithoutTerminalInput[]
    createMany?: TimeEntryCreateManyTerminalInputEnvelope
    set?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    disconnect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    delete?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    connect?: TimeEntryWhereUniqueInput | TimeEntryWhereUniqueInput[]
    update?: TimeEntryUpdateWithWhereUniqueWithoutTerminalInput | TimeEntryUpdateWithWhereUniqueWithoutTerminalInput[]
    updateMany?: TimeEntryUpdateManyWithWhereWithoutTerminalInput | TimeEntryUpdateManyWithWhereWithoutTerminalInput[]
    deleteMany?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
  }

  export type UserCreateNestedOneWithoutTimeEntryInput = {
    create?: XOR<UserCreateWithoutTimeEntryInput, UserUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntryInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeCreateNestedOneWithoutTimeEntryInput = {
    create?: XOR<EmployeeCreateWithoutTimeEntryInput, EmployeeUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTimeEntryInput
    connect?: EmployeeWhereUniqueInput
  }

  export type TerminalCreateNestedOneWithoutTimeEntryInput = {
    create?: XOR<TerminalCreateWithoutTimeEntryInput, TerminalUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutTimeEntryInput
    connect?: TerminalWhereUniqueInput
  }

  export type UserUpdateOneWithoutTimeEntryNestedInput = {
    create?: XOR<UserCreateWithoutTimeEntryInput, UserUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: UserCreateOrConnectWithoutTimeEntryInput
    upsert?: UserUpsertWithoutTimeEntryInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutTimeEntryInput, UserUpdateWithoutTimeEntryInput>, UserUncheckedUpdateWithoutTimeEntryInput>
  }

  export type EmployeeUpdateOneRequiredWithoutTimeEntryNestedInput = {
    create?: XOR<EmployeeCreateWithoutTimeEntryInput, EmployeeUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutTimeEntryInput
    upsert?: EmployeeUpsertWithoutTimeEntryInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutTimeEntryInput, EmployeeUpdateWithoutTimeEntryInput>, EmployeeUncheckedUpdateWithoutTimeEntryInput>
  }

  export type TerminalUpdateOneWithoutTimeEntryNestedInput = {
    create?: XOR<TerminalCreateWithoutTimeEntryInput, TerminalUncheckedCreateWithoutTimeEntryInput>
    connectOrCreate?: TerminalCreateOrConnectWithoutTimeEntryInput
    upsert?: TerminalUpsertWithoutTimeEntryInput
    disconnect?: TerminalWhereInput | boolean
    delete?: TerminalWhereInput | boolean
    connect?: TerminalWhereUniqueInput
    update?: XOR<XOR<TerminalUpdateToOneWithWhereWithoutTimeEntryInput, TerminalUpdateWithoutTimeEntryInput>, TerminalUncheckedUpdateWithoutTimeEntryInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeeRateInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeRateInput, EmployeeUncheckedCreateWithoutEmployeeRateInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeRateInput
    connect?: EmployeeWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeRateNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeRateInput, EmployeeUncheckedCreateWithoutEmployeeRateInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeRateInput
    upsert?: EmployeeUpsertWithoutEmployeeRateInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeRateInput, EmployeeUpdateWithoutEmployeeRateInput>, EmployeeUncheckedUpdateWithoutEmployeeRateInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeeDeductionsInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeDeductionsInput, EmployeeUncheckedCreateWithoutEmployeeDeductionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeDeductionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutDeductionApprovalsInput = {
    create?: XOR<UserCreateWithoutDeductionApprovalsInput, UserUncheckedCreateWithoutDeductionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeductionApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeDeductionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeDeductionsInput, EmployeeUncheckedCreateWithoutEmployeeDeductionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeDeductionsInput
    upsert?: EmployeeUpsertWithoutEmployeeDeductionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeDeductionsInput, EmployeeUpdateWithoutEmployeeDeductionsInput>, EmployeeUncheckedUpdateWithoutEmployeeDeductionsInput>
  }

  export type UserUpdateOneWithoutDeductionApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutDeductionApprovalsInput, UserUncheckedCreateWithoutDeductionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutDeductionApprovalsInput
    upsert?: UserUpsertWithoutDeductionApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutDeductionApprovalsInput, UserUpdateWithoutDeductionApprovalsInput>, UserUncheckedUpdateWithoutDeductionApprovalsInput>
  }

  export type EmployeeCreateNestedOneWithoutEmployeeInfractionsInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInfractionsInput, EmployeeUncheckedCreateWithoutEmployeeInfractionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInfractionsInput
    connect?: EmployeeWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInfractionReportsInput = {
    create?: XOR<UserCreateWithoutInfractionReportsInput, UserUncheckedCreateWithoutInfractionReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfractionReportsInput
    connect?: UserWhereUniqueInput
  }

  export type UserCreateNestedOneWithoutInfractionApprovalsInput = {
    create?: XOR<UserCreateWithoutInfractionApprovalsInput, UserUncheckedCreateWithoutInfractionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfractionApprovalsInput
    connect?: UserWhereUniqueInput
  }

  export type EmployeeUpdateOneRequiredWithoutEmployeeInfractionsNestedInput = {
    create?: XOR<EmployeeCreateWithoutEmployeeInfractionsInput, EmployeeUncheckedCreateWithoutEmployeeInfractionsInput>
    connectOrCreate?: EmployeeCreateOrConnectWithoutEmployeeInfractionsInput
    upsert?: EmployeeUpsertWithoutEmployeeInfractionsInput
    connect?: EmployeeWhereUniqueInput
    update?: XOR<XOR<EmployeeUpdateToOneWithWhereWithoutEmployeeInfractionsInput, EmployeeUpdateWithoutEmployeeInfractionsInput>, EmployeeUncheckedUpdateWithoutEmployeeInfractionsInput>
  }

  export type UserUpdateOneWithoutInfractionReportsNestedInput = {
    create?: XOR<UserCreateWithoutInfractionReportsInput, UserUncheckedCreateWithoutInfractionReportsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfractionReportsInput
    upsert?: UserUpsertWithoutInfractionReportsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInfractionReportsInput, UserUpdateWithoutInfractionReportsInput>, UserUncheckedUpdateWithoutInfractionReportsInput>
  }

  export type UserUpdateOneWithoutInfractionApprovalsNestedInput = {
    create?: XOR<UserCreateWithoutInfractionApprovalsInput, UserUncheckedCreateWithoutInfractionApprovalsInput>
    connectOrCreate?: UserCreateOrConnectWithoutInfractionApprovalsInput
    upsert?: UserUpsertWithoutInfractionApprovalsInput
    disconnect?: UserWhereInput | boolean
    delete?: UserWhereInput | boolean
    connect?: UserWhereUniqueInput
    update?: XOR<XOR<UserUpdateToOneWithWhereWithoutInfractionApprovalsInput, UserUpdateWithoutInfractionApprovalsInput>, UserUncheckedUpdateWithoutInfractionApprovalsInput>
  }

  export type NestedStringFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringFilter<$PrismaModel> | string
  }

  export type NestedBoolFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolFilter<$PrismaModel> | boolean
  }

  export type NestedDateTimeFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeFilter<$PrismaModel> | Date | string
  }

  export type NestedStringWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel>
    in?: string[] | ListStringFieldRefInput<$PrismaModel>
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel>
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringWithAggregatesFilter<$PrismaModel> | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedStringFilter<$PrismaModel>
    _max?: NestedStringFilter<$PrismaModel>
  }

  export type NestedIntFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntFilter<$PrismaModel> | number
  }

  export type NestedBoolWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel>
    not?: NestedBoolWithAggregatesFilter<$PrismaModel> | boolean
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedBoolFilter<$PrismaModel>
    _max?: NestedBoolFilter<$PrismaModel>
  }

  export type NestedDateTimeWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel>
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeWithAggregatesFilter<$PrismaModel> | Date | string
    _count?: NestedIntFilter<$PrismaModel>
    _min?: NestedDateTimeFilter<$PrismaModel>
    _max?: NestedDateTimeFilter<$PrismaModel>
  }

  export type NestedStringNullableFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableFilter<$PrismaModel> | string | null
  }

  export type NestedFloatNullableFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableFilter<$PrismaModel> | number | null
  }

  export type NestedStringNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: string | StringFieldRefInput<$PrismaModel> | null
    in?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    notIn?: string[] | ListStringFieldRefInput<$PrismaModel> | null
    lt?: string | StringFieldRefInput<$PrismaModel>
    lte?: string | StringFieldRefInput<$PrismaModel>
    gt?: string | StringFieldRefInput<$PrismaModel>
    gte?: string | StringFieldRefInput<$PrismaModel>
    contains?: string | StringFieldRefInput<$PrismaModel>
    startsWith?: string | StringFieldRefInput<$PrismaModel>
    endsWith?: string | StringFieldRefInput<$PrismaModel>
    not?: NestedStringNullableWithAggregatesFilter<$PrismaModel> | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedStringNullableFilter<$PrismaModel>
    _max?: NestedStringNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableFilter<$PrismaModel> | number | null
  }

  export type NestedFloatNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel> | null
    in?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel> | null
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedFloatNullableFilter<$PrismaModel>
    _min?: NestedFloatNullableFilter<$PrismaModel>
    _max?: NestedFloatNullableFilter<$PrismaModel>
  }

  export type NestedFloatFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatFilter<$PrismaModel> | number
  }

  export type NestedIntWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel>
    in?: number[] | ListIntFieldRefInput<$PrismaModel>
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel>
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedIntFilter<$PrismaModel>
    _min?: NestedIntFilter<$PrismaModel>
    _max?: NestedIntFilter<$PrismaModel>
  }

  export type NestedFloatWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | FloatFieldRefInput<$PrismaModel>
    in?: number[] | ListFloatFieldRefInput<$PrismaModel>
    notIn?: number[] | ListFloatFieldRefInput<$PrismaModel>
    lt?: number | FloatFieldRefInput<$PrismaModel>
    lte?: number | FloatFieldRefInput<$PrismaModel>
    gt?: number | FloatFieldRefInput<$PrismaModel>
    gte?: number | FloatFieldRefInput<$PrismaModel>
    not?: NestedFloatWithAggregatesFilter<$PrismaModel> | number
    _count?: NestedIntFilter<$PrismaModel>
    _avg?: NestedFloatFilter<$PrismaModel>
    _sum?: NestedFloatFilter<$PrismaModel>
    _min?: NestedFloatFilter<$PrismaModel>
    _max?: NestedFloatFilter<$PrismaModel>
  }

  export type NestedDateTimeNullableFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableFilter<$PrismaModel> | Date | string | null
  }

  export type NestedDateTimeNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: Date | string | DateTimeFieldRefInput<$PrismaModel> | null
    in?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    notIn?: Date[] | string[] | ListDateTimeFieldRefInput<$PrismaModel> | null
    lt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    lte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gt?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    gte?: Date | string | DateTimeFieldRefInput<$PrismaModel>
    not?: NestedDateTimeNullableWithAggregatesFilter<$PrismaModel> | Date | string | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedDateTimeNullableFilter<$PrismaModel>
    _max?: NestedDateTimeNullableFilter<$PrismaModel>
  }

  export type NestedBoolNullableFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableFilter<$PrismaModel> | boolean | null
  }

  export type NestedBoolNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: boolean | BooleanFieldRefInput<$PrismaModel> | null
    not?: NestedBoolNullableWithAggregatesFilter<$PrismaModel> | boolean | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedBoolNullableFilter<$PrismaModel>
    _max?: NestedBoolNullableFilter<$PrismaModel>
  }

  export type NestedIntNullableWithAggregatesFilter<$PrismaModel = never> = {
    equals?: number | IntFieldRefInput<$PrismaModel> | null
    in?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    notIn?: number[] | ListIntFieldRefInput<$PrismaModel> | null
    lt?: number | IntFieldRefInput<$PrismaModel>
    lte?: number | IntFieldRefInput<$PrismaModel>
    gt?: number | IntFieldRefInput<$PrismaModel>
    gte?: number | IntFieldRefInput<$PrismaModel>
    not?: NestedIntNullableWithAggregatesFilter<$PrismaModel> | number | null
    _count?: NestedIntNullableFilter<$PrismaModel>
    _avg?: NestedFloatNullableFilter<$PrismaModel>
    _sum?: NestedIntNullableFilter<$PrismaModel>
    _min?: NestedIntNullableFilter<$PrismaModel>
    _max?: NestedIntNullableFilter<$PrismaModel>
  }

  export type AuditLogCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogUncheckedCreateWithoutUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type AuditLogCreateOrConnectWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogCreateManyUserInputEnvelope = {
    data: AuditLogCreateManyUserInput | AuditLogCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeCreateWithoutUserInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutUserInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutUserInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestCreateWithoutUserInput = {
    id: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    Employee: EmployeeCreateNestedOneWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutUserInput = {
    id: string
    employeeId: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestCreateManyUserInputEnvelope = {
    data: LeaveRequestCreateManyUserInput | LeaveRequestCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutUserInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    Employee: EmployeeCreateNestedOneWithoutTimeEntryInput
    Terminal?: TerminalCreateNestedOneWithoutTimeEntryInput
  }

  export type TimeEntryUncheckedCreateWithoutUserInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryCreateManyUserInputEnvelope = {
    data: TimeEntryCreateManyUserInput | TimeEntryCreateManyUserInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutDepartmentInput
  }

  export type DepartmentCreateOrConnectWithoutCreatedByInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput>
  }

  export type DepartmentCreateManyCreatedByInputEnvelope = {
    data: DepartmentCreateManyCreatedByInput | DepartmentCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeCreateNestedManyWithoutShiftInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutCreatedByInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput>
  }

  export type ShiftCreateManyCreatedByInputEnvelope = {
    data: ShiftCreateManyCreatedByInput | ShiftCreateManyCreatedByInput[]
    skipDuplicates?: boolean
  }

  export type ShiftAssignmentCreateWithoutAssignedByInput = {
    id: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutShiftAssignmentInput
    Shift: ShiftCreateNestedOneWithoutShiftAssignmentInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutAssignedByInput = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutAssignedByInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ShiftAssignmentCreateManyAssignedByInputEnvelope = {
    data: ShiftAssignmentCreateManyAssignedByInput | ShiftAssignmentCreateManyAssignedByInput[]
    skipDuplicates?: boolean
  }

  export type PayrollDeductionCreateWithoutApprovedByInput = {
    id?: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeDeductionsInput
  }

  export type PayrollDeductionUncheckedCreateWithoutApprovedByInput = {
    id?: string
    employeeId: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollDeductionCreateOrConnectWithoutApprovedByInput = {
    where: PayrollDeductionWhereUniqueInput
    create: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput>
  }

  export type PayrollDeductionCreateManyApprovedByInputEnvelope = {
    data: PayrollDeductionCreateManyApprovedByInput | PayrollDeductionCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type InfractionCreateWithoutReportedByInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeInfractionsInput
    ApprovedBy?: UserCreateNestedOneWithoutInfractionApprovalsInput
  }

  export type InfractionUncheckedCreateWithoutReportedByInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateOrConnectWithoutReportedByInput = {
    where: InfractionWhereUniqueInput
    create: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput>
  }

  export type InfractionCreateManyReportedByInputEnvelope = {
    data: InfractionCreateManyReportedByInput | InfractionCreateManyReportedByInput[]
    skipDuplicates?: boolean
  }

  export type InfractionCreateWithoutApprovedByInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutEmployeeInfractionsInput
    ReportedBy?: UserCreateNestedOneWithoutInfractionReportsInput
  }

  export type InfractionUncheckedCreateWithoutApprovedByInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateOrConnectWithoutApprovedByInput = {
    where: InfractionWhereUniqueInput
    create: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput>
  }

  export type InfractionCreateManyApprovedByInputEnvelope = {
    data: InfractionCreateManyApprovedByInput | InfractionCreateManyApprovedByInput[]
    skipDuplicates?: boolean
  }

  export type AuditLogUpsertWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    update: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
    create: XOR<AuditLogCreateWithoutUserInput, AuditLogUncheckedCreateWithoutUserInput>
  }

  export type AuditLogUpdateWithWhereUniqueWithoutUserInput = {
    where: AuditLogWhereUniqueInput
    data: XOR<AuditLogUpdateWithoutUserInput, AuditLogUncheckedUpdateWithoutUserInput>
  }

  export type AuditLogUpdateManyWithWhereWithoutUserInput = {
    where: AuditLogScalarWhereInput
    data: XOR<AuditLogUpdateManyMutationInput, AuditLogUncheckedUpdateManyWithoutUserInput>
  }

  export type AuditLogScalarWhereInput = {
    AND?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    OR?: AuditLogScalarWhereInput[]
    NOT?: AuditLogScalarWhereInput | AuditLogScalarWhereInput[]
    id?: StringFilter<"AuditLog"> | string
    userId?: StringNullableFilter<"AuditLog"> | string | null
    action?: StringFilter<"AuditLog"> | string
    entityType?: StringFilter<"AuditLog"> | string
    entityId?: StringNullableFilter<"AuditLog"> | string | null
    oldValue?: StringNullableFilter<"AuditLog"> | string | null
    newValue?: StringNullableFilter<"AuditLog"> | string | null
    ipAddress?: StringNullableFilter<"AuditLog"> | string | null
    userAgent?: StringNullableFilter<"AuditLog"> | string | null
    createdAt?: DateTimeFilter<"AuditLog"> | Date | string
  }

  export type EmployeeUpsertWithoutUserInput = {
    update: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
    create: XOR<EmployeeCreateWithoutUserInput, EmployeeUncheckedCreateWithoutUserInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutUserInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutUserInput, EmployeeUncheckedUpdateWithoutUserInput>
  }

  export type EmployeeUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
    create: XOR<LeaveRequestCreateWithoutUserInput, LeaveRequestUncheckedCreateWithoutUserInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutUserInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutUserInput, LeaveRequestUncheckedUpdateWithoutUserInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutUserInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutUserInput>
  }

  export type LeaveRequestScalarWhereInput = {
    AND?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    OR?: LeaveRequestScalarWhereInput[]
    NOT?: LeaveRequestScalarWhereInput | LeaveRequestScalarWhereInput[]
    id?: StringFilter<"LeaveRequest"> | string
    employeeId?: StringFilter<"LeaveRequest"> | string
    leaveType?: StringFilter<"LeaveRequest"> | string
    startDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    endDate?: DateTimeFilter<"LeaveRequest"> | Date | string
    totalDays?: IntFilter<"LeaveRequest"> | number
    reason?: StringNullableFilter<"LeaveRequest"> | string | null
    status?: StringFilter<"LeaveRequest"> | string
    approvedById?: StringNullableFilter<"LeaveRequest"> | string | null
    approvedAt?: DateTimeNullableFilter<"LeaveRequest"> | Date | string | null
    rejectionReason?: StringNullableFilter<"LeaveRequest"> | string | null
    createdAt?: DateTimeFilter<"LeaveRequest"> | Date | string
    updatedAt?: DateTimeFilter<"LeaveRequest"> | Date | string
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
    create: XOR<TimeEntryCreateWithoutUserInput, TimeEntryUncheckedCreateWithoutUserInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutUserInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutUserInput, TimeEntryUncheckedUpdateWithoutUserInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutUserInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutUserInput>
  }

  export type TimeEntryScalarWhereInput = {
    AND?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    OR?: TimeEntryScalarWhereInput[]
    NOT?: TimeEntryScalarWhereInput | TimeEntryScalarWhereInput[]
    id?: StringFilter<"TimeEntry"> | string
    employeeId?: StringFilter<"TimeEntry"> | string
    clockIn?: DateTimeFilter<"TimeEntry"> | Date | string
    clockOut?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakStart?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    breakEnd?: DateTimeNullableFilter<"TimeEntry"> | Date | string | null
    totalHours?: FloatNullableFilter<"TimeEntry"> | number | null
    regularHours?: FloatNullableFilter<"TimeEntry"> | number | null
    overtimeHours?: FloatNullableFilter<"TimeEntry"> | number | null
    breakMinutes?: IntNullableFilter<"TimeEntry"> | number | null
    status?: StringFilter<"TimeEntry"> | string
    location?: StringNullableFilter<"TimeEntry"> | string | null
    terminalId?: StringNullableFilter<"TimeEntry"> | string | null
    verifyMethod?: StringNullableFilter<"TimeEntry"> | string | null
    clockInPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    clockOutPhoto?: StringNullableFilter<"TimeEntry"> | string | null
    notes?: StringNullableFilter<"TimeEntry"> | string | null
    isManualEntry?: BoolFilter<"TimeEntry"> | boolean
    approvedById?: StringNullableFilter<"TimeEntry"> | string | null
    createdAt?: DateTimeFilter<"TimeEntry"> | Date | string
    updatedAt?: DateTimeFilter<"TimeEntry"> | Date | string
  }

  export type DepartmentUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: DepartmentWhereUniqueInput
    update: XOR<DepartmentUpdateWithoutCreatedByInput, DepartmentUncheckedUpdateWithoutCreatedByInput>
    create: XOR<DepartmentCreateWithoutCreatedByInput, DepartmentUncheckedCreateWithoutCreatedByInput>
  }

  export type DepartmentUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: DepartmentWhereUniqueInput
    data: XOR<DepartmentUpdateWithoutCreatedByInput, DepartmentUncheckedUpdateWithoutCreatedByInput>
  }

  export type DepartmentUpdateManyWithWhereWithoutCreatedByInput = {
    where: DepartmentScalarWhereInput
    data: XOR<DepartmentUpdateManyMutationInput, DepartmentUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type DepartmentScalarWhereInput = {
    AND?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    OR?: DepartmentScalarWhereInput[]
    NOT?: DepartmentScalarWhereInput | DepartmentScalarWhereInput[]
    id?: StringFilter<"Department"> | string
    name?: StringFilter<"Department"> | string
    description?: StringNullableFilter<"Department"> | string | null
    managerId?: StringNullableFilter<"Department"> | string | null
    color?: StringNullableFilter<"Department"> | string | null
    budget?: FloatNullableFilter<"Department"> | number | null
    isActive?: BoolFilter<"Department"> | boolean
    createdById?: StringNullableFilter<"Department"> | string | null
    createdAt?: DateTimeFilter<"Department"> | Date | string
    updatedAt?: DateTimeFilter<"Department"> | Date | string
  }

  export type ShiftUpsertWithWhereUniqueWithoutCreatedByInput = {
    where: ShiftWhereUniqueInput
    update: XOR<ShiftUpdateWithoutCreatedByInput, ShiftUncheckedUpdateWithoutCreatedByInput>
    create: XOR<ShiftCreateWithoutCreatedByInput, ShiftUncheckedCreateWithoutCreatedByInput>
  }

  export type ShiftUpdateWithWhereUniqueWithoutCreatedByInput = {
    where: ShiftWhereUniqueInput
    data: XOR<ShiftUpdateWithoutCreatedByInput, ShiftUncheckedUpdateWithoutCreatedByInput>
  }

  export type ShiftUpdateManyWithWhereWithoutCreatedByInput = {
    where: ShiftScalarWhereInput
    data: XOR<ShiftUpdateManyMutationInput, ShiftUncheckedUpdateManyWithoutCreatedByInput>
  }

  export type ShiftScalarWhereInput = {
    AND?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    OR?: ShiftScalarWhereInput[]
    NOT?: ShiftScalarWhereInput | ShiftScalarWhereInput[]
    id?: StringFilter<"Shift"> | string
    name?: StringFilter<"Shift"> | string
    description?: StringNullableFilter<"Shift"> | string | null
    startTime?: StringFilter<"Shift"> | string
    endTime?: StringFilter<"Shift"> | string
    breakDuration?: IntFilter<"Shift"> | number
    graceMinutes?: IntFilter<"Shift"> | number
    overtimeAfter?: FloatFilter<"Shift"> | number
    workingDays?: StringFilter<"Shift"> | string
    color?: StringNullableFilter<"Shift"> | string | null
    isNightShift?: BoolFilter<"Shift"> | boolean
    isActive?: BoolFilter<"Shift"> | boolean
    createdById?: StringNullableFilter<"Shift"> | string | null
    createdAt?: DateTimeFilter<"Shift"> | Date | string
    updatedAt?: DateTimeFilter<"Shift"> | Date | string
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutAssignedByInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutAssignedByInput, ShiftAssignmentUncheckedUpdateWithoutAssignedByInput>
    create: XOR<ShiftAssignmentCreateWithoutAssignedByInput, ShiftAssignmentUncheckedCreateWithoutAssignedByInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutAssignedByInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutAssignedByInput, ShiftAssignmentUncheckedUpdateWithoutAssignedByInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutAssignedByInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutAssignedByInput>
  }

  export type ShiftAssignmentScalarWhereInput = {
    AND?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
    OR?: ShiftAssignmentScalarWhereInput[]
    NOT?: ShiftAssignmentScalarWhereInput | ShiftAssignmentScalarWhereInput[]
    id?: StringFilter<"ShiftAssignment"> | string
    employeeId?: StringFilter<"ShiftAssignment"> | string
    shiftId?: StringFilter<"ShiftAssignment"> | string
    startDate?: DateTimeFilter<"ShiftAssignment"> | Date | string
    endDate?: DateTimeNullableFilter<"ShiftAssignment"> | Date | string | null
    isActive?: BoolFilter<"ShiftAssignment"> | boolean
    assignedById?: StringNullableFilter<"ShiftAssignment"> | string | null
    createdAt?: DateTimeFilter<"ShiftAssignment"> | Date | string
  }

  export type PayrollDeductionUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: PayrollDeductionWhereUniqueInput
    update: XOR<PayrollDeductionUpdateWithoutApprovedByInput, PayrollDeductionUncheckedUpdateWithoutApprovedByInput>
    create: XOR<PayrollDeductionCreateWithoutApprovedByInput, PayrollDeductionUncheckedCreateWithoutApprovedByInput>
  }

  export type PayrollDeductionUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: PayrollDeductionWhereUniqueInput
    data: XOR<PayrollDeductionUpdateWithoutApprovedByInput, PayrollDeductionUncheckedUpdateWithoutApprovedByInput>
  }

  export type PayrollDeductionUpdateManyWithWhereWithoutApprovedByInput = {
    where: PayrollDeductionScalarWhereInput
    data: XOR<PayrollDeductionUpdateManyMutationInput, PayrollDeductionUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type PayrollDeductionScalarWhereInput = {
    AND?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
    OR?: PayrollDeductionScalarWhereInput[]
    NOT?: PayrollDeductionScalarWhereInput | PayrollDeductionScalarWhereInput[]
    id?: StringFilter<"PayrollDeduction"> | string
    employeeId?: StringFilter<"PayrollDeduction"> | string
    deductionType?: StringFilter<"PayrollDeduction"> | string
    amount?: FloatFilter<"PayrollDeduction"> | number
    reason?: StringNullableFilter<"PayrollDeduction"> | string | null
    description?: StringNullableFilter<"PayrollDeduction"> | string | null
    month?: DateTimeFilter<"PayrollDeduction"> | Date | string
    status?: StringFilter<"PayrollDeduction"> | string
    approvedBy?: StringNullableFilter<"PayrollDeduction"> | string | null
    approvedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    appliedAt?: DateTimeNullableFilter<"PayrollDeduction"> | Date | string | null
    notes?: StringNullableFilter<"PayrollDeduction"> | string | null
    createdAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
    updatedAt?: DateTimeFilter<"PayrollDeduction"> | Date | string
  }

  export type InfractionUpsertWithWhereUniqueWithoutReportedByInput = {
    where: InfractionWhereUniqueInput
    update: XOR<InfractionUpdateWithoutReportedByInput, InfractionUncheckedUpdateWithoutReportedByInput>
    create: XOR<InfractionCreateWithoutReportedByInput, InfractionUncheckedCreateWithoutReportedByInput>
  }

  export type InfractionUpdateWithWhereUniqueWithoutReportedByInput = {
    where: InfractionWhereUniqueInput
    data: XOR<InfractionUpdateWithoutReportedByInput, InfractionUncheckedUpdateWithoutReportedByInput>
  }

  export type InfractionUpdateManyWithWhereWithoutReportedByInput = {
    where: InfractionScalarWhereInput
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyWithoutReportedByInput>
  }

  export type InfractionScalarWhereInput = {
    AND?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
    OR?: InfractionScalarWhereInput[]
    NOT?: InfractionScalarWhereInput | InfractionScalarWhereInput[]
    id?: StringFilter<"Infraction"> | string
    employeeId?: StringFilter<"Infraction"> | string
    type?: StringFilter<"Infraction"> | string
    severity?: StringFilter<"Infraction"> | string
    amount?: FloatNullableFilter<"Infraction"> | number | null
    description?: StringFilter<"Infraction"> | string
    date?: DateTimeFilter<"Infraction"> | Date | string
    reportedBy?: StringNullableFilter<"Infraction"> | string | null
    status?: StringFilter<"Infraction"> | string
    approvedBy?: StringNullableFilter<"Infraction"> | string | null
    approvedAt?: DateTimeNullableFilter<"Infraction"> | Date | string | null
    notes?: StringNullableFilter<"Infraction"> | string | null
    createdAt?: DateTimeFilter<"Infraction"> | Date | string
    updatedAt?: DateTimeFilter<"Infraction"> | Date | string
  }

  export type InfractionUpsertWithWhereUniqueWithoutApprovedByInput = {
    where: InfractionWhereUniqueInput
    update: XOR<InfractionUpdateWithoutApprovedByInput, InfractionUncheckedUpdateWithoutApprovedByInput>
    create: XOR<InfractionCreateWithoutApprovedByInput, InfractionUncheckedCreateWithoutApprovedByInput>
  }

  export type InfractionUpdateWithWhereUniqueWithoutApprovedByInput = {
    where: InfractionWhereUniqueInput
    data: XOR<InfractionUpdateWithoutApprovedByInput, InfractionUncheckedUpdateWithoutApprovedByInput>
  }

  export type InfractionUpdateManyWithWhereWithoutApprovedByInput = {
    where: InfractionScalarWhereInput
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyWithoutApprovedByInput>
  }

  export type UserCreateWithoutDepartmentsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutDepartmentsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutDepartmentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDepartmentsCreatedInput, UserUncheckedCreateWithoutDepartmentsCreatedInput>
  }

  export type EmployeeCreateWithoutDepartmentInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutDepartmentInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeCreateManyDepartmentInputEnvelope = {
    data: EmployeeCreateManyDepartmentInput | EmployeeCreateManyDepartmentInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutDepartmentsCreatedInput = {
    update: XOR<UserUpdateWithoutDepartmentsCreatedInput, UserUncheckedUpdateWithoutDepartmentsCreatedInput>
    create: XOR<UserCreateWithoutDepartmentsCreatedInput, UserUncheckedCreateWithoutDepartmentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDepartmentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDepartmentsCreatedInput, UserUncheckedUpdateWithoutDepartmentsCreatedInput>
  }

  export type UserUpdateWithoutDepartmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDepartmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
    create: XOR<EmployeeCreateWithoutDepartmentInput, EmployeeUncheckedCreateWithoutDepartmentInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutDepartmentInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutDepartmentInput, EmployeeUncheckedUpdateWithoutDepartmentInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutDepartmentInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutDepartmentInput>
  }

  export type EmployeeScalarWhereInput = {
    AND?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    OR?: EmployeeScalarWhereInput[]
    NOT?: EmployeeScalarWhereInput | EmployeeScalarWhereInput[]
    id?: StringFilter<"Employee"> | string
    employeeId?: StringFilter<"Employee"> | string
    firstName?: StringFilter<"Employee"> | string
    lastName?: StringFilter<"Employee"> | string
    email?: StringNullableFilter<"Employee"> | string | null
    phone?: StringNullableFilter<"Employee"> | string | null
    photo?: StringNullableFilter<"Employee"> | string | null
    departmentId?: StringNullableFilter<"Employee"> | string | null
    designation?: StringNullableFilter<"Employee"> | string | null
    managerId?: StringNullableFilter<"Employee"> | string | null
    joinDate?: DateTimeFilter<"Employee"> | Date | string
    employmentType?: StringFilter<"Employee"> | string
    status?: StringFilter<"Employee"> | string
    shiftId?: StringNullableFilter<"Employee"> | string | null
    salary?: FloatNullableFilter<"Employee"> | number | null
    hourlyRate?: FloatNullableFilter<"Employee"> | number | null
    cardNumber?: StringNullableFilter<"Employee"> | string | null
    faceEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintEnrolled?: BoolFilter<"Employee"> | boolean
    fingerprintTemplate?: StringNullableFilter<"Employee"> | string | null
    fingerprintTemplateDate?: DateTimeNullableFilter<"Employee"> | Date | string | null
    userId?: StringNullableFilter<"Employee"> | string | null
    createdAt?: DateTimeFilter<"Employee"> | Date | string
    updatedAt?: DateTimeFilter<"Employee"> | Date | string
  }

  export type UserCreateWithoutShiftsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutShiftsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutShiftsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftsCreatedInput, UserUncheckedCreateWithoutShiftsCreatedInput>
  }

  export type EmployeeCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShiftInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeCreateManyShiftInputEnvelope = {
    data: EmployeeCreateManyShiftInput | EmployeeCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type ShiftAssignmentCreateWithoutShiftInput = {
    id: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutShiftAssignmentInput
    AssignedBy?: UserCreateNestedOneWithoutShiftAssignmentsCreatedInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutShiftInput = {
    id: string
    employeeId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutShiftInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput>
  }

  export type ShiftAssignmentCreateManyShiftInputEnvelope = {
    data: ShiftAssignmentCreateManyShiftInput | ShiftAssignmentCreateManyShiftInput[]
    skipDuplicates?: boolean
  }

  export type UserUpsertWithoutShiftsCreatedInput = {
    update: XOR<UserUpdateWithoutShiftsCreatedInput, UserUncheckedUpdateWithoutShiftsCreatedInput>
    create: XOR<UserCreateWithoutShiftsCreatedInput, UserUncheckedCreateWithoutShiftsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftsCreatedInput, UserUncheckedUpdateWithoutShiftsCreatedInput>
  }

  export type UserUpdateWithoutShiftsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
    create: XOR<EmployeeCreateWithoutShiftInput, EmployeeUncheckedCreateWithoutShiftInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutShiftInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutShiftInput, EmployeeUncheckedUpdateWithoutShiftInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutShiftInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutShiftInput>
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutShiftInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutShiftInput, ShiftAssignmentUncheckedUpdateWithoutShiftInput>
    create: XOR<ShiftAssignmentCreateWithoutShiftInput, ShiftAssignmentUncheckedCreateWithoutShiftInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutShiftInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutShiftInput, ShiftAssignmentUncheckedUpdateWithoutShiftInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutShiftInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutShiftInput>
  }

  export type AttendanceLogCreateWithoutEmployeeInput = {
    id: string
    eventType: string
    timestamp: Date | string
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
    Terminal?: TerminalCreateNestedOneWithoutAttendanceLogInput
  }

  export type AttendanceLogUncheckedCreateWithoutEmployeeInput = {
    id: string
    eventType: string
    timestamp: Date | string
    terminalId?: string | null
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogCreateManyEmployeeInputEnvelope = {
    data: AttendanceLogCreateManyEmployeeInput | AttendanceLogCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type BiometricDataCreateWithoutEmployeeInput = {
    id: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
  }

  export type BiometricDataUncheckedCreateWithoutEmployeeInput = {
    id: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
  }

  export type BiometricDataCreateOrConnectWithoutEmployeeInput = {
    where: BiometricDataWhereUniqueInput
    create: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput>
  }

  export type BiometricDataCreateManyEmployeeInputEnvelope = {
    data: BiometricDataCreateManyEmployeeInput | BiometricDataCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type DepartmentCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: UserCreateNestedOneWithoutDepartmentsCreatedInput
  }

  export type DepartmentUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type DepartmentCreateOrConnectWithoutEmployeesInput = {
    where: DepartmentWhereUniqueInput
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
  }

  export type EmployeeCreateWithoutOther_EmployeeInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutOther_EmployeeInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutOther_EmployeeInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutOther_EmployeeInput, EmployeeUncheckedCreateWithoutOther_EmployeeInput>
  }

  export type EmployeeCreateWithoutEmployeeInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeCreateManyEmployeeInputEnvelope = {
    data: EmployeeCreateManyEmployeeInput | EmployeeCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ShiftCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: UserCreateNestedOneWithoutShiftsCreatedInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutEmployeesInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutEmployeesInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
  }

  export type UserCreateWithoutEmployeeInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutEmployeeInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutEmployeeInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveBalanceCreateWithoutEmployeeInput = {
    id: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
  }

  export type LeaveBalanceUncheckedCreateWithoutEmployeeInput = {
    id: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
  }

  export type LeaveBalanceCreateOrConnectWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    create: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveBalanceCreateManyEmployeeInputEnvelope = {
    data: LeaveBalanceCreateManyEmployeeInput | LeaveBalanceCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type LeaveRequestCreateWithoutEmployeeInput = {
    id: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutLeaveRequestInput
  }

  export type LeaveRequestUncheckedCreateWithoutEmployeeInput = {
    id: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type LeaveRequestCreateOrConnectWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestCreateManyEmployeeInputEnvelope = {
    data: LeaveRequestCreateManyEmployeeInput | LeaveRequestCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type NotificationCreateWithoutEmployeeInput = {
    id: string
    userId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
  }

  export type NotificationUncheckedCreateWithoutEmployeeInput = {
    id: string
    userId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
  }

  export type NotificationCreateOrConnectWithoutEmployeeInput = {
    where: NotificationWhereUniqueInput
    create: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput>
  }

  export type NotificationCreateManyEmployeeInputEnvelope = {
    data: NotificationCreateManyEmployeeInput | NotificationCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type ShiftAssignmentCreateWithoutEmployeeInput = {
    id: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    Shift: ShiftCreateNestedOneWithoutShiftAssignmentInput
    AssignedBy?: UserCreateNestedOneWithoutShiftAssignmentsCreatedInput
  }

  export type ShiftAssignmentUncheckedCreateWithoutEmployeeInput = {
    id: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type ShiftAssignmentCreateOrConnectWithoutEmployeeInput = {
    where: ShiftAssignmentWhereUniqueInput
    create: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftAssignmentCreateManyEmployeeInputEnvelope = {
    data: ShiftAssignmentCreateManyEmployeeInput | ShiftAssignmentCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutEmployeeInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutTimeEntryInput
    Terminal?: TerminalCreateNestedOneWithoutTimeEntryInput
  }

  export type TimeEntryUncheckedCreateWithoutEmployeeInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutEmployeeInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type TimeEntryCreateManyEmployeeInputEnvelope = {
    data: TimeEntryCreateManyEmployeeInput | TimeEntryCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type EmployeeRateCreateWithoutEmployeeInput = {
    id?: string
    hourlyRate: number
    dailyRate?: number | null
    salary?: number | null
    overtimeRate?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    currency?: string
    rateType?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeRateUncheckedCreateWithoutEmployeeInput = {
    id?: string
    hourlyRate: number
    dailyRate?: number | null
    salary?: number | null
    overtimeRate?: number | null
    effectiveFrom?: Date | string
    effectiveTo?: Date | string | null
    currency?: string
    rateType?: string
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeRateCreateOrConnectWithoutEmployeeInput = {
    where: EmployeeRateWhereUniqueInput
    create: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollDeductionCreateWithoutEmployeeInput = {
    id?: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ApprovedBy?: UserCreateNestedOneWithoutDeductionApprovalsInput
  }

  export type PayrollDeductionUncheckedCreateWithoutEmployeeInput = {
    id?: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type PayrollDeductionCreateOrConnectWithoutEmployeeInput = {
    where: PayrollDeductionWhereUniqueInput
    create: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollDeductionCreateManyEmployeeInputEnvelope = {
    data: PayrollDeductionCreateManyEmployeeInput | PayrollDeductionCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type InfractionCreateWithoutEmployeeInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    ReportedBy?: UserCreateNestedOneWithoutInfractionReportsInput
    ApprovedBy?: UserCreateNestedOneWithoutInfractionApprovalsInput
  }

  export type InfractionUncheckedCreateWithoutEmployeeInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateOrConnectWithoutEmployeeInput = {
    where: InfractionWhereUniqueInput
    create: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput>
  }

  export type InfractionCreateManyEmployeeInputEnvelope = {
    data: InfractionCreateManyEmployeeInput | InfractionCreateManyEmployeeInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
    create: XOR<AttendanceLogCreateWithoutEmployeeInput, AttendanceLogUncheckedCreateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutEmployeeInput, AttendanceLogUncheckedUpdateWithoutEmployeeInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutEmployeeInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type AttendanceLogScalarWhereInput = {
    AND?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    OR?: AttendanceLogScalarWhereInput[]
    NOT?: AttendanceLogScalarWhereInput | AttendanceLogScalarWhereInput[]
    id?: StringFilter<"AttendanceLog"> | string
    employeeId?: StringFilter<"AttendanceLog"> | string
    eventType?: StringFilter<"AttendanceLog"> | string
    timestamp?: DateTimeFilter<"AttendanceLog"> | Date | string
    terminalId?: StringNullableFilter<"AttendanceLog"> | string | null
    verifyMethod?: StringNullableFilter<"AttendanceLog"> | string | null
    snapshot?: StringNullableFilter<"AttendanceLog"> | string | null
    temperature?: FloatNullableFilter<"AttendanceLog"> | number | null
    maskDetected?: BoolNullableFilter<"AttendanceLog"> | boolean | null
    processed?: BoolFilter<"AttendanceLog"> | boolean
    rawData?: StringNullableFilter<"AttendanceLog"> | string | null
    createdAt?: DateTimeFilter<"AttendanceLog"> | Date | string
  }

  export type BiometricDataUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: BiometricDataWhereUniqueInput
    update: XOR<BiometricDataUpdateWithoutEmployeeInput, BiometricDataUncheckedUpdateWithoutEmployeeInput>
    create: XOR<BiometricDataCreateWithoutEmployeeInput, BiometricDataUncheckedCreateWithoutEmployeeInput>
  }

  export type BiometricDataUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: BiometricDataWhereUniqueInput
    data: XOR<BiometricDataUpdateWithoutEmployeeInput, BiometricDataUncheckedUpdateWithoutEmployeeInput>
  }

  export type BiometricDataUpdateManyWithWhereWithoutEmployeeInput = {
    where: BiometricDataScalarWhereInput
    data: XOR<BiometricDataUpdateManyMutationInput, BiometricDataUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type BiometricDataScalarWhereInput = {
    AND?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
    OR?: BiometricDataScalarWhereInput[]
    NOT?: BiometricDataScalarWhereInput | BiometricDataScalarWhereInput[]
    id?: StringFilter<"BiometricData"> | string
    employeeId?: StringFilter<"BiometricData"> | string
    type?: StringFilter<"BiometricData"> | string
    data?: StringNullableFilter<"BiometricData"> | string | null
    fingerNo?: IntNullableFilter<"BiometricData"> | number | null
    enrolledAt?: DateTimeFilter<"BiometricData"> | Date | string
  }

  export type DepartmentUpsertWithoutEmployeesInput = {
    update: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
    create: XOR<DepartmentCreateWithoutEmployeesInput, DepartmentUncheckedCreateWithoutEmployeesInput>
    where?: DepartmentWhereInput
  }

  export type DepartmentUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: DepartmentWhereInput
    data: XOR<DepartmentUpdateWithoutEmployeesInput, DepartmentUncheckedUpdateWithoutEmployeesInput>
  }

  export type DepartmentUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneWithoutDepartmentsCreatedNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpsertWithoutOther_EmployeeInput = {
    update: XOR<EmployeeUpdateWithoutOther_EmployeeInput, EmployeeUncheckedUpdateWithoutOther_EmployeeInput>
    create: XOR<EmployeeCreateWithoutOther_EmployeeInput, EmployeeUncheckedCreateWithoutOther_EmployeeInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutOther_EmployeeInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutOther_EmployeeInput, EmployeeUncheckedUpdateWithoutOther_EmployeeInput>
  }

  export type EmployeeUpdateWithoutOther_EmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutOther_EmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeWhereUniqueInput
    update: XOR<EmployeeUpdateWithoutEmployeeInput, EmployeeUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeCreateWithoutEmployeeInput, EmployeeUncheckedCreateWithoutEmployeeInput>
  }

  export type EmployeeUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: EmployeeWhereUniqueInput
    data: XOR<EmployeeUpdateWithoutEmployeeInput, EmployeeUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeUpdateManyWithWhereWithoutEmployeeInput = {
    where: EmployeeScalarWhereInput
    data: XOR<EmployeeUpdateManyMutationInput, EmployeeUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type ShiftUpsertWithoutEmployeesInput = {
    update: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
    create: XOR<ShiftCreateWithoutEmployeesInput, ShiftUncheckedCreateWithoutEmployeesInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutEmployeesInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutEmployeesInput, ShiftUncheckedUpdateWithoutEmployeesInput>
  }

  export type ShiftUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneWithoutShiftsCreatedNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutEmployeesInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type UserUpsertWithoutEmployeeInput = {
    update: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
    create: XOR<UserCreateWithoutEmployeeInput, UserUncheckedCreateWithoutEmployeeInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutEmployeeInput, UserUncheckedUpdateWithoutEmployeeInput>
  }

  export type UserUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type LeaveBalanceUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    update: XOR<LeaveBalanceUpdateWithoutEmployeeInput, LeaveBalanceUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveBalanceCreateWithoutEmployeeInput, LeaveBalanceUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveBalanceUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveBalanceWhereUniqueInput
    data: XOR<LeaveBalanceUpdateWithoutEmployeeInput, LeaveBalanceUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveBalanceUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveBalanceScalarWhereInput
    data: XOR<LeaveBalanceUpdateManyMutationInput, LeaveBalanceUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type LeaveBalanceScalarWhereInput = {
    AND?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    OR?: LeaveBalanceScalarWhereInput[]
    NOT?: LeaveBalanceScalarWhereInput | LeaveBalanceScalarWhereInput[]
    id?: StringFilter<"LeaveBalance"> | string
    employeeId?: StringFilter<"LeaveBalance"> | string
    leaveType?: StringFilter<"LeaveBalance"> | string
    year?: IntFilter<"LeaveBalance"> | number
    totalDays?: IntFilter<"LeaveBalance"> | number
    usedDays?: IntFilter<"LeaveBalance"> | number
    remainingDays?: IntFilter<"LeaveBalance"> | number
  }

  export type LeaveRequestUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    update: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
    create: XOR<LeaveRequestCreateWithoutEmployeeInput, LeaveRequestUncheckedCreateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: LeaveRequestWhereUniqueInput
    data: XOR<LeaveRequestUpdateWithoutEmployeeInput, LeaveRequestUncheckedUpdateWithoutEmployeeInput>
  }

  export type LeaveRequestUpdateManyWithWhereWithoutEmployeeInput = {
    where: LeaveRequestScalarWhereInput
    data: XOR<LeaveRequestUpdateManyMutationInput, LeaveRequestUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type NotificationUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: NotificationWhereUniqueInput
    update: XOR<NotificationUpdateWithoutEmployeeInput, NotificationUncheckedUpdateWithoutEmployeeInput>
    create: XOR<NotificationCreateWithoutEmployeeInput, NotificationUncheckedCreateWithoutEmployeeInput>
  }

  export type NotificationUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: NotificationWhereUniqueInput
    data: XOR<NotificationUpdateWithoutEmployeeInput, NotificationUncheckedUpdateWithoutEmployeeInput>
  }

  export type NotificationUpdateManyWithWhereWithoutEmployeeInput = {
    where: NotificationScalarWhereInput
    data: XOR<NotificationUpdateManyMutationInput, NotificationUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type NotificationScalarWhereInput = {
    AND?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    OR?: NotificationScalarWhereInput[]
    NOT?: NotificationScalarWhereInput | NotificationScalarWhereInput[]
    id?: StringFilter<"Notification"> | string
    userId?: StringNullableFilter<"Notification"> | string | null
    employeeId?: StringNullableFilter<"Notification"> | string | null
    type?: StringFilter<"Notification"> | string
    title?: StringFilter<"Notification"> | string
    message?: StringFilter<"Notification"> | string
    isRead?: BoolFilter<"Notification"> | boolean
    data?: StringNullableFilter<"Notification"> | string | null
    createdAt?: DateTimeFilter<"Notification"> | Date | string
  }

  export type ShiftAssignmentUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftAssignmentWhereUniqueInput
    update: XOR<ShiftAssignmentUpdateWithoutEmployeeInput, ShiftAssignmentUncheckedUpdateWithoutEmployeeInput>
    create: XOR<ShiftAssignmentCreateWithoutEmployeeInput, ShiftAssignmentUncheckedCreateWithoutEmployeeInput>
  }

  export type ShiftAssignmentUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: ShiftAssignmentWhereUniqueInput
    data: XOR<ShiftAssignmentUpdateWithoutEmployeeInput, ShiftAssignmentUncheckedUpdateWithoutEmployeeInput>
  }

  export type ShiftAssignmentUpdateManyWithWhereWithoutEmployeeInput = {
    where: ShiftAssignmentScalarWhereInput
    data: XOR<ShiftAssignmentUpdateManyMutationInput, ShiftAssignmentUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutEmployeeInput, TimeEntryUncheckedUpdateWithoutEmployeeInput>
    create: XOR<TimeEntryCreateWithoutEmployeeInput, TimeEntryUncheckedCreateWithoutEmployeeInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutEmployeeInput, TimeEntryUncheckedUpdateWithoutEmployeeInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutEmployeeInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type EmployeeRateUpsertWithoutEmployeeInput = {
    update: XOR<EmployeeRateUpdateWithoutEmployeeInput, EmployeeRateUncheckedUpdateWithoutEmployeeInput>
    create: XOR<EmployeeRateCreateWithoutEmployeeInput, EmployeeRateUncheckedCreateWithoutEmployeeInput>
    where?: EmployeeRateWhereInput
  }

  export type EmployeeRateUpdateToOneWithWhereWithoutEmployeeInput = {
    where?: EmployeeRateWhereInput
    data: XOR<EmployeeRateUpdateWithoutEmployeeInput, EmployeeRateUncheckedUpdateWithoutEmployeeInput>
  }

  export type EmployeeRateUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeRateUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    hourlyRate?: FloatFieldUpdateOperationsInput | number
    dailyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeRate?: NullableFloatFieldUpdateOperationsInput | number | null
    effectiveFrom?: DateTimeFieldUpdateOperationsInput | Date | string
    effectiveTo?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    currency?: StringFieldUpdateOperationsInput | string
    rateType?: StringFieldUpdateOperationsInput | string
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollDeductionWhereUniqueInput
    update: XOR<PayrollDeductionUpdateWithoutEmployeeInput, PayrollDeductionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<PayrollDeductionCreateWithoutEmployeeInput, PayrollDeductionUncheckedCreateWithoutEmployeeInput>
  }

  export type PayrollDeductionUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: PayrollDeductionWhereUniqueInput
    data: XOR<PayrollDeductionUpdateWithoutEmployeeInput, PayrollDeductionUncheckedUpdateWithoutEmployeeInput>
  }

  export type PayrollDeductionUpdateManyWithWhereWithoutEmployeeInput = {
    where: PayrollDeductionScalarWhereInput
    data: XOR<PayrollDeductionUpdateManyMutationInput, PayrollDeductionUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type InfractionUpsertWithWhereUniqueWithoutEmployeeInput = {
    where: InfractionWhereUniqueInput
    update: XOR<InfractionUpdateWithoutEmployeeInput, InfractionUncheckedUpdateWithoutEmployeeInput>
    create: XOR<InfractionCreateWithoutEmployeeInput, InfractionUncheckedCreateWithoutEmployeeInput>
  }

  export type InfractionUpdateWithWhereUniqueWithoutEmployeeInput = {
    where: InfractionWhereUniqueInput
    data: XOR<InfractionUpdateWithoutEmployeeInput, InfractionUncheckedUpdateWithoutEmployeeInput>
  }

  export type InfractionUpdateManyWithWhereWithoutEmployeeInput = {
    where: InfractionScalarWhereInput
    data: XOR<InfractionUpdateManyMutationInput, InfractionUncheckedUpdateManyWithoutEmployeeInput>
  }

  export type UserCreateWithoutAuditLogInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutAuditLogInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutAuditLogInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
  }

  export type UserUpsertWithoutAuditLogInput = {
    update: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
    create: XOR<UserCreateWithoutAuditLogInput, UserUncheckedCreateWithoutAuditLogInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutAuditLogInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutAuditLogInput, UserUncheckedUpdateWithoutAuditLogInput>
  }

  export type UserUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutAuditLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeCreateWithoutAttendanceLogInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutAttendanceLogInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutAttendanceLogInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutAttendanceLogInput, EmployeeUncheckedCreateWithoutAttendanceLogInput>
  }

  export type TerminalCreateWithoutAttendanceLogInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    TimeEntry?: TimeEntryCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutAttendanceLogInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutAttendanceLogInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutAttendanceLogInput, TerminalUncheckedCreateWithoutAttendanceLogInput>
  }

  export type EmployeeUpsertWithoutAttendanceLogInput = {
    update: XOR<EmployeeUpdateWithoutAttendanceLogInput, EmployeeUncheckedUpdateWithoutAttendanceLogInput>
    create: XOR<EmployeeCreateWithoutAttendanceLogInput, EmployeeUncheckedCreateWithoutAttendanceLogInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutAttendanceLogInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutAttendanceLogInput, EmployeeUncheckedUpdateWithoutAttendanceLogInput>
  }

  export type EmployeeUpdateWithoutAttendanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutAttendanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TerminalUpsertWithoutAttendanceLogInput = {
    update: XOR<TerminalUpdateWithoutAttendanceLogInput, TerminalUncheckedUpdateWithoutAttendanceLogInput>
    create: XOR<TerminalCreateWithoutAttendanceLogInput, TerminalUncheckedCreateWithoutAttendanceLogInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutAttendanceLogInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutAttendanceLogInput, TerminalUncheckedUpdateWithoutAttendanceLogInput>
  }

  export type TerminalUpdateWithoutAttendanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeEntry?: TimeEntryUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutAttendanceLogInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type EmployeeCreateWithoutBiometricDataInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutBiometricDataInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutBiometricDataInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutBiometricDataInput, EmployeeUncheckedCreateWithoutBiometricDataInput>
  }

  export type EmployeeUpsertWithoutBiometricDataInput = {
    update: XOR<EmployeeUpdateWithoutBiometricDataInput, EmployeeUncheckedUpdateWithoutBiometricDataInput>
    create: XOR<EmployeeCreateWithoutBiometricDataInput, EmployeeUncheckedCreateWithoutBiometricDataInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutBiometricDataInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutBiometricDataInput, EmployeeUncheckedUpdateWithoutBiometricDataInput>
  }

  export type EmployeeUpdateWithoutBiometricDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutBiometricDataInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutLeaveBalanceInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveBalanceInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveBalanceInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveBalanceInput, EmployeeUncheckedCreateWithoutLeaveBalanceInput>
  }

  export type EmployeeUpsertWithoutLeaveBalanceInput = {
    update: XOR<EmployeeUpdateWithoutLeaveBalanceInput, EmployeeUncheckedUpdateWithoutLeaveBalanceInput>
    create: XOR<EmployeeCreateWithoutLeaveBalanceInput, EmployeeUncheckedCreateWithoutLeaveBalanceInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveBalanceInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveBalanceInput, EmployeeUncheckedUpdateWithoutLeaveBalanceInput>
  }

  export type EmployeeUpdateWithoutLeaveBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveBalanceInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserCreateWithoutLeaveRequestInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutLeaveRequestInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutLeaveRequestInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutLeaveRequestInput, UserUncheckedCreateWithoutLeaveRequestInput>
  }

  export type EmployeeCreateWithoutLeaveRequestInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutLeaveRequestInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutLeaveRequestInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutLeaveRequestInput, EmployeeUncheckedCreateWithoutLeaveRequestInput>
  }

  export type UserUpsertWithoutLeaveRequestInput = {
    update: XOR<UserUpdateWithoutLeaveRequestInput, UserUncheckedUpdateWithoutLeaveRequestInput>
    create: XOR<UserCreateWithoutLeaveRequestInput, UserUncheckedCreateWithoutLeaveRequestInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutLeaveRequestInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutLeaveRequestInput, UserUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type UserUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUpsertWithoutLeaveRequestInput = {
    update: XOR<EmployeeUpdateWithoutLeaveRequestInput, EmployeeUncheckedUpdateWithoutLeaveRequestInput>
    create: XOR<EmployeeCreateWithoutLeaveRequestInput, EmployeeUncheckedCreateWithoutLeaveRequestInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutLeaveRequestInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutLeaveRequestInput, EmployeeUncheckedUpdateWithoutLeaveRequestInput>
  }

  export type EmployeeUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutLeaveRequestInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutNotificationInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutNotificationInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutNotificationInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutNotificationInput, EmployeeUncheckedCreateWithoutNotificationInput>
  }

  export type EmployeeUpsertWithoutNotificationInput = {
    update: XOR<EmployeeUpdateWithoutNotificationInput, EmployeeUncheckedUpdateWithoutNotificationInput>
    create: XOR<EmployeeCreateWithoutNotificationInput, EmployeeUncheckedCreateWithoutNotificationInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutNotificationInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutNotificationInput, EmployeeUncheckedUpdateWithoutNotificationInput>
  }

  export type EmployeeUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutNotificationInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutShiftAssignmentInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutShiftAssignmentInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutShiftAssignmentInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutShiftAssignmentInput, EmployeeUncheckedCreateWithoutShiftAssignmentInput>
  }

  export type ShiftCreateWithoutShiftAssignmentInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    CreatedBy?: UserCreateNestedOneWithoutShiftsCreatedInput
    employees?: EmployeeCreateNestedManyWithoutShiftInput
  }

  export type ShiftUncheckedCreateWithoutShiftAssignmentInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdById?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    employees?: EmployeeUncheckedCreateNestedManyWithoutShiftInput
  }

  export type ShiftCreateOrConnectWithoutShiftAssignmentInput = {
    where: ShiftWhereUniqueInput
    create: XOR<ShiftCreateWithoutShiftAssignmentInput, ShiftUncheckedCreateWithoutShiftAssignmentInput>
  }

  export type UserCreateWithoutShiftAssignmentsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutShiftAssignmentsCreatedInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutShiftAssignmentsCreatedInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutShiftAssignmentsCreatedInput, UserUncheckedCreateWithoutShiftAssignmentsCreatedInput>
  }

  export type EmployeeUpsertWithoutShiftAssignmentInput = {
    update: XOR<EmployeeUpdateWithoutShiftAssignmentInput, EmployeeUncheckedUpdateWithoutShiftAssignmentInput>
    create: XOR<EmployeeCreateWithoutShiftAssignmentInput, EmployeeUncheckedCreateWithoutShiftAssignmentInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutShiftAssignmentInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutShiftAssignmentInput, EmployeeUncheckedUpdateWithoutShiftAssignmentInput>
  }

  export type EmployeeUpdateWithoutShiftAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type ShiftUpsertWithoutShiftAssignmentInput = {
    update: XOR<ShiftUpdateWithoutShiftAssignmentInput, ShiftUncheckedUpdateWithoutShiftAssignmentInput>
    create: XOR<ShiftCreateWithoutShiftAssignmentInput, ShiftUncheckedCreateWithoutShiftAssignmentInput>
    where?: ShiftWhereInput
  }

  export type ShiftUpdateToOneWithWhereWithoutShiftAssignmentInput = {
    where?: ShiftWhereInput
    data: XOR<ShiftUpdateWithoutShiftAssignmentInput, ShiftUncheckedUpdateWithoutShiftAssignmentInput>
  }

  export type ShiftUpdateWithoutShiftAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    CreatedBy?: UserUpdateOneWithoutShiftsCreatedNestedInput
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutShiftAssignmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type UserUpsertWithoutShiftAssignmentsCreatedInput = {
    update: XOR<UserUpdateWithoutShiftAssignmentsCreatedInput, UserUncheckedUpdateWithoutShiftAssignmentsCreatedInput>
    create: XOR<UserCreateWithoutShiftAssignmentsCreatedInput, UserUncheckedCreateWithoutShiftAssignmentsCreatedInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutShiftAssignmentsCreatedInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutShiftAssignmentsCreatedInput, UserUncheckedUpdateWithoutShiftAssignmentsCreatedInput>
  }

  export type UserUpdateWithoutShiftAssignmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutShiftAssignmentsCreatedInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type AttendanceLogCreateWithoutTerminalInput = {
    id: string
    eventType: string
    timestamp: Date | string
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
    Employee: EmployeeCreateNestedOneWithoutAttendanceLogInput
  }

  export type AttendanceLogUncheckedCreateWithoutTerminalInput = {
    id: string
    employeeId: string
    eventType: string
    timestamp: Date | string
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type AttendanceLogCreateOrConnectWithoutTerminalInput = {
    where: AttendanceLogWhereUniqueInput
    create: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput>
  }

  export type AttendanceLogCreateManyTerminalInputEnvelope = {
    data: AttendanceLogCreateManyTerminalInput | AttendanceLogCreateManyTerminalInput[]
    skipDuplicates?: boolean
  }

  export type TimeEntryCreateWithoutTerminalInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    User?: UserCreateNestedOneWithoutTimeEntryInput
    Employee: EmployeeCreateNestedOneWithoutTimeEntryInput
  }

  export type TimeEntryUncheckedCreateWithoutTerminalInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryCreateOrConnectWithoutTerminalInput = {
    where: TimeEntryWhereUniqueInput
    create: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput>
  }

  export type TimeEntryCreateManyTerminalInputEnvelope = {
    data: TimeEntryCreateManyTerminalInput | TimeEntryCreateManyTerminalInput[]
    skipDuplicates?: boolean
  }

  export type AttendanceLogUpsertWithWhereUniqueWithoutTerminalInput = {
    where: AttendanceLogWhereUniqueInput
    update: XOR<AttendanceLogUpdateWithoutTerminalInput, AttendanceLogUncheckedUpdateWithoutTerminalInput>
    create: XOR<AttendanceLogCreateWithoutTerminalInput, AttendanceLogUncheckedCreateWithoutTerminalInput>
  }

  export type AttendanceLogUpdateWithWhereUniqueWithoutTerminalInput = {
    where: AttendanceLogWhereUniqueInput
    data: XOR<AttendanceLogUpdateWithoutTerminalInput, AttendanceLogUncheckedUpdateWithoutTerminalInput>
  }

  export type AttendanceLogUpdateManyWithWhereWithoutTerminalInput = {
    where: AttendanceLogScalarWhereInput
    data: XOR<AttendanceLogUpdateManyMutationInput, AttendanceLogUncheckedUpdateManyWithoutTerminalInput>
  }

  export type TimeEntryUpsertWithWhereUniqueWithoutTerminalInput = {
    where: TimeEntryWhereUniqueInput
    update: XOR<TimeEntryUpdateWithoutTerminalInput, TimeEntryUncheckedUpdateWithoutTerminalInput>
    create: XOR<TimeEntryCreateWithoutTerminalInput, TimeEntryUncheckedCreateWithoutTerminalInput>
  }

  export type TimeEntryUpdateWithWhereUniqueWithoutTerminalInput = {
    where: TimeEntryWhereUniqueInput
    data: XOR<TimeEntryUpdateWithoutTerminalInput, TimeEntryUncheckedUpdateWithoutTerminalInput>
  }

  export type TimeEntryUpdateManyWithWhereWithoutTerminalInput = {
    where: TimeEntryScalarWhereInput
    data: XOR<TimeEntryUpdateManyMutationInput, TimeEntryUncheckedUpdateManyWithoutTerminalInput>
  }

  export type UserCreateWithoutTimeEntryInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutTimeEntryInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutTimeEntryInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutTimeEntryInput, UserUncheckedCreateWithoutTimeEntryInput>
  }

  export type EmployeeCreateWithoutTimeEntryInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutTimeEntryInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutTimeEntryInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutTimeEntryInput, EmployeeUncheckedCreateWithoutTimeEntryInput>
  }

  export type TerminalCreateWithoutTimeEntryInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutTerminalInput
  }

  export type TerminalUncheckedCreateWithoutTimeEntryInput = {
    id: string
    name: string
    ipAddress: string
    port?: number
    username?: string
    password: string
    deviceType?: string | null
    serialNumber?: string | null
    firmwareVersion?: string | null
    location?: string | null
    isOnline?: boolean
    lastSyncAt?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutTerminalInput
  }

  export type TerminalCreateOrConnectWithoutTimeEntryInput = {
    where: TerminalWhereUniqueInput
    create: XOR<TerminalCreateWithoutTimeEntryInput, TerminalUncheckedCreateWithoutTimeEntryInput>
  }

  export type UserUpsertWithoutTimeEntryInput = {
    update: XOR<UserUpdateWithoutTimeEntryInput, UserUncheckedUpdateWithoutTimeEntryInput>
    create: XOR<UserCreateWithoutTimeEntryInput, UserUncheckedCreateWithoutTimeEntryInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutTimeEntryInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutTimeEntryInput, UserUncheckedUpdateWithoutTimeEntryInput>
  }

  export type UserUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeUpsertWithoutTimeEntryInput = {
    update: XOR<EmployeeUpdateWithoutTimeEntryInput, EmployeeUncheckedUpdateWithoutTimeEntryInput>
    create: XOR<EmployeeCreateWithoutTimeEntryInput, EmployeeUncheckedCreateWithoutTimeEntryInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutTimeEntryInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutTimeEntryInput, EmployeeUncheckedUpdateWithoutTimeEntryInput>
  }

  export type EmployeeUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type TerminalUpsertWithoutTimeEntryInput = {
    update: XOR<TerminalUpdateWithoutTimeEntryInput, TerminalUncheckedUpdateWithoutTimeEntryInput>
    create: XOR<TerminalCreateWithoutTimeEntryInput, TerminalUncheckedCreateWithoutTimeEntryInput>
    where?: TerminalWhereInput
  }

  export type TerminalUpdateToOneWithWhereWithoutTimeEntryInput = {
    where?: TerminalWhereInput
    data: XOR<TerminalUpdateWithoutTimeEntryInput, TerminalUncheckedUpdateWithoutTimeEntryInput>
  }

  export type TerminalUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutTerminalNestedInput
  }

  export type TerminalUncheckedUpdateWithoutTimeEntryInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    ipAddress?: StringFieldUpdateOperationsInput | string
    port?: IntFieldUpdateOperationsInput | number
    username?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    deviceType?: NullableStringFieldUpdateOperationsInput | string | null
    serialNumber?: NullableStringFieldUpdateOperationsInput | string | null
    firmwareVersion?: NullableStringFieldUpdateOperationsInput | string | null
    location?: NullableStringFieldUpdateOperationsInput | string | null
    isOnline?: BoolFieldUpdateOperationsInput | boolean
    lastSyncAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutTerminalNestedInput
  }

  export type EmployeeCreateWithoutEmployeeRateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeRateInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeRateInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeRateInput, EmployeeUncheckedCreateWithoutEmployeeRateInput>
  }

  export type EmployeeUpsertWithoutEmployeeRateInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeRateInput, EmployeeUncheckedUpdateWithoutEmployeeRateInput>
    create: XOR<EmployeeCreateWithoutEmployeeRateInput, EmployeeUncheckedCreateWithoutEmployeeRateInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeRateInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeRateInput, EmployeeUncheckedUpdateWithoutEmployeeRateInput>
  }

  export type EmployeeUpdateWithoutEmployeeRateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeRateInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeCreateWithoutEmployeeDeductionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeInfractions?: InfractionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeDeductionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeInfractions?: InfractionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeDeductionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeDeductionsInput, EmployeeUncheckedCreateWithoutEmployeeDeductionsInput>
  }

  export type UserCreateWithoutDeductionApprovalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutDeductionApprovalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutDeductionApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutDeductionApprovalsInput, UserUncheckedCreateWithoutDeductionApprovalsInput>
  }

  export type EmployeeUpsertWithoutEmployeeDeductionsInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeDeductionsInput, EmployeeUncheckedUpdateWithoutEmployeeDeductionsInput>
    create: XOR<EmployeeCreateWithoutEmployeeDeductionsInput, EmployeeUncheckedCreateWithoutEmployeeDeductionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeDeductionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeDeductionsInput, EmployeeUncheckedUpdateWithoutEmployeeDeductionsInput>
  }

  export type EmployeeUpdateWithoutEmployeeDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeDeductionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutDeductionApprovalsInput = {
    update: XOR<UserUpdateWithoutDeductionApprovalsInput, UserUncheckedUpdateWithoutDeductionApprovalsInput>
    create: XOR<UserCreateWithoutDeductionApprovalsInput, UserUncheckedCreateWithoutDeductionApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutDeductionApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutDeductionApprovalsInput, UserUncheckedUpdateWithoutDeductionApprovalsInput>
  }

  export type UserUpdateWithoutDeductionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutDeductionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type EmployeeCreateWithoutEmployeeInfractionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataCreateNestedManyWithoutEmployeeInput
    department?: DepartmentCreateNestedOneWithoutEmployeesInput
    Employee?: EmployeeCreateNestedOneWithoutOther_EmployeeInput
    other_Employee?: EmployeeCreateNestedManyWithoutEmployeeInput
    shift?: ShiftCreateNestedOneWithoutEmployeesInput
    User?: UserCreateNestedOneWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeUncheckedCreateWithoutEmployeeInfractionsInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
    AttendanceLog?: AttendanceLogUncheckedCreateNestedManyWithoutEmployeeInput
    BiometricData?: BiometricDataUncheckedCreateNestedManyWithoutEmployeeInput
    other_Employee?: EmployeeUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveBalance?: LeaveBalanceUncheckedCreateNestedManyWithoutEmployeeInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutEmployeeInput
    Notification?: NotificationUncheckedCreateNestedManyWithoutEmployeeInput
    ShiftAssignment?: ShiftAssignmentUncheckedCreateNestedManyWithoutEmployeeInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutEmployeeInput
    EmployeeRate?: EmployeeRateUncheckedCreateNestedOneWithoutEmployeeInput
    EmployeeDeductions?: PayrollDeductionUncheckedCreateNestedManyWithoutEmployeeInput
  }

  export type EmployeeCreateOrConnectWithoutEmployeeInfractionsInput = {
    where: EmployeeWhereUniqueInput
    create: XOR<EmployeeCreateWithoutEmployeeInfractionsInput, EmployeeUncheckedCreateWithoutEmployeeInfractionsInput>
  }

  export type UserCreateWithoutInfractionReportsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionApprovals?: InfractionCreateNestedManyWithoutApprovedByInput
  }

  export type UserUncheckedCreateWithoutInfractionReportsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionApprovals?: InfractionUncheckedCreateNestedManyWithoutApprovedByInput
  }

  export type UserCreateOrConnectWithoutInfractionReportsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInfractionReportsInput, UserUncheckedCreateWithoutInfractionReportsInput>
  }

  export type UserCreateWithoutInfractionApprovalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogCreateNestedManyWithoutUserInput
    Employee?: EmployeeCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionCreateNestedManyWithoutReportedByInput
  }

  export type UserUncheckedCreateWithoutInfractionApprovalsInput = {
    id?: string
    email: string
    password: string
    firstName: string
    lastName: string
    role?: string
    permissions?: string
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
    AuditLog?: AuditLogUncheckedCreateNestedManyWithoutUserInput
    Employee?: EmployeeUncheckedCreateNestedOneWithoutUserInput
    LeaveRequest?: LeaveRequestUncheckedCreateNestedManyWithoutUserInput
    TimeEntry?: TimeEntryUncheckedCreateNestedManyWithoutUserInput
    DepartmentsCreated?: DepartmentUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftsCreated?: ShiftUncheckedCreateNestedManyWithoutCreatedByInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedCreateNestedManyWithoutAssignedByInput
    DeductionApprovals?: PayrollDeductionUncheckedCreateNestedManyWithoutApprovedByInput
    InfractionReports?: InfractionUncheckedCreateNestedManyWithoutReportedByInput
  }

  export type UserCreateOrConnectWithoutInfractionApprovalsInput = {
    where: UserWhereUniqueInput
    create: XOR<UserCreateWithoutInfractionApprovalsInput, UserUncheckedCreateWithoutInfractionApprovalsInput>
  }

  export type EmployeeUpsertWithoutEmployeeInfractionsInput = {
    update: XOR<EmployeeUpdateWithoutEmployeeInfractionsInput, EmployeeUncheckedUpdateWithoutEmployeeInfractionsInput>
    create: XOR<EmployeeCreateWithoutEmployeeInfractionsInput, EmployeeUncheckedCreateWithoutEmployeeInfractionsInput>
    where?: EmployeeWhereInput
  }

  export type EmployeeUpdateToOneWithWhereWithoutEmployeeInfractionsInput = {
    where?: EmployeeWhereInput
    data: XOR<EmployeeUpdateWithoutEmployeeInfractionsInput, EmployeeUncheckedUpdateWithoutEmployeeInfractionsInput>
  }

  export type EmployeeUpdateWithoutEmployeeInfractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeInfractionsInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type UserUpsertWithoutInfractionReportsInput = {
    update: XOR<UserUpdateWithoutInfractionReportsInput, UserUncheckedUpdateWithoutInfractionReportsInput>
    create: XOR<UserCreateWithoutInfractionReportsInput, UserUncheckedCreateWithoutInfractionReportsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInfractionReportsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInfractionReportsInput, UserUncheckedUpdateWithoutInfractionReportsInput>
  }

  export type UserUpdateWithoutInfractionReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionApprovals?: InfractionUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInfractionReportsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionApprovals?: InfractionUncheckedUpdateManyWithoutApprovedByNestedInput
  }

  export type UserUpsertWithoutInfractionApprovalsInput = {
    update: XOR<UserUpdateWithoutInfractionApprovalsInput, UserUncheckedUpdateWithoutInfractionApprovalsInput>
    create: XOR<UserCreateWithoutInfractionApprovalsInput, UserUncheckedCreateWithoutInfractionApprovalsInput>
    where?: UserWhereInput
  }

  export type UserUpdateToOneWithWhereWithoutInfractionApprovalsInput = {
    where?: UserWhereInput
    data: XOR<UserUpdateWithoutInfractionApprovalsInput, UserUncheckedUpdateWithoutInfractionApprovalsInput>
  }

  export type UserUpdateWithoutInfractionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUpdateManyWithoutReportedByNestedInput
  }

  export type UserUncheckedUpdateWithoutInfractionApprovalsInput = {
    id?: StringFieldUpdateOperationsInput | string
    email?: StringFieldUpdateOperationsInput | string
    password?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    role?: StringFieldUpdateOperationsInput | string
    permissions?: StringFieldUpdateOperationsInput | string
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AuditLog?: AuditLogUncheckedUpdateManyWithoutUserNestedInput
    Employee?: EmployeeUncheckedUpdateOneWithoutUserNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutUserNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutUserNestedInput
    DepartmentsCreated?: DepartmentUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftsCreated?: ShiftUncheckedUpdateManyWithoutCreatedByNestedInput
    ShiftAssignmentsCreated?: ShiftAssignmentUncheckedUpdateManyWithoutAssignedByNestedInput
    DeductionApprovals?: PayrollDeductionUncheckedUpdateManyWithoutApprovedByNestedInput
    InfractionReports?: InfractionUncheckedUpdateManyWithoutReportedByNestedInput
  }

  export type AuditLogCreateManyUserInput = {
    id?: string
    action: string
    entityType: string
    entityId?: string | null
    oldValue?: string | null
    newValue?: string | null
    ipAddress?: string | null
    userAgent?: string | null
    createdAt?: Date | string
  }

  export type LeaveRequestCreateManyUserInput = {
    id: string
    employeeId: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type TimeEntryCreateManyUserInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type DepartmentCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    managerId?: string | null
    color?: string | null
    budget?: number | null
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftCreateManyCreatedByInput = {
    id?: string
    name: string
    description?: string | null
    startTime: string
    endTime: string
    breakDuration?: number
    graceMinutes?: number
    overtimeAfter?: number
    workingDays?: string
    color?: string | null
    isNightShift?: boolean
    isActive?: boolean
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateManyAssignedByInput = {
    id: string
    employeeId: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    createdAt?: Date | string
  }

  export type PayrollDeductionCreateManyApprovedByInput = {
    id?: string
    employeeId: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateManyReportedByInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateManyApprovedByInput = {
    id?: string
    employeeId: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AuditLogUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AuditLogUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    action?: StringFieldUpdateOperationsInput | string
    entityType?: StringFieldUpdateOperationsInput | string
    entityId?: NullableStringFieldUpdateOperationsInput | string | null
    oldValue?: NullableStringFieldUpdateOperationsInput | string | null
    newValue?: NullableStringFieldUpdateOperationsInput | string | null
    ipAddress?: NullableStringFieldUpdateOperationsInput | string | null
    userAgent?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutTimeEntryNestedInput
    Terminal?: TerminalUpdateOneWithoutTimeEntryNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutUserInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type DepartmentUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutDepartmentNestedInput
  }

  export type DepartmentUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    color?: NullableStringFieldUpdateOperationsInput | string | null
    budget?: NullableFloatFieldUpdateOperationsInput | number | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUpdateManyWithoutShiftNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    employees?: EmployeeUncheckedUpdateManyWithoutShiftNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutShiftNestedInput
  }

  export type ShiftUncheckedUpdateManyWithoutCreatedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    name?: StringFieldUpdateOperationsInput | string
    description?: NullableStringFieldUpdateOperationsInput | string | null
    startTime?: StringFieldUpdateOperationsInput | string
    endTime?: StringFieldUpdateOperationsInput | string
    breakDuration?: IntFieldUpdateOperationsInput | number
    graceMinutes?: IntFieldUpdateOperationsInput | number
    overtimeAfter?: FloatFieldUpdateOperationsInput | number
    workingDays?: StringFieldUpdateOperationsInput | string
    color?: NullableStringFieldUpdateOperationsInput | string | null
    isNightShift?: BoolFieldUpdateOperationsInput | boolean
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutShiftAssignmentNestedInput
    Shift?: ShiftUpdateOneRequiredWithoutShiftAssignmentNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutAssignedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeDeductionsNestedInput
  }

  export type PayrollDeductionUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeInfractionsNestedInput
    ApprovedBy?: UserUpdateOneWithoutInfractionApprovalsNestedInput
  }

  export type InfractionUncheckedUpdateWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUncheckedUpdateManyWithoutReportedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutEmployeeInfractionsNestedInput
    ReportedBy?: UserUpdateOneWithoutInfractionReportsNestedInput
  }

  export type InfractionUncheckedUpdateWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUncheckedUpdateManyWithoutApprovedByInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyDepartmentInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type EmployeeUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutDepartmentInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeCreateManyShiftInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    managerId?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type ShiftAssignmentCreateManyShiftInput = {
    id: string
    employeeId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type EmployeeUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    Employee?: EmployeeUpdateOneWithoutOther_EmployeeNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    managerId?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutShiftAssignmentNestedInput
    AssignedBy?: UserUpdateOneWithoutShiftAssignmentsCreatedNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutShiftInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyEmployeeInput = {
    id: string
    eventType: string
    timestamp: Date | string
    terminalId?: string | null
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type BiometricDataCreateManyEmployeeInput = {
    id: string
    type: string
    data?: string | null
    fingerNo?: number | null
    enrolledAt?: Date | string
  }

  export type EmployeeCreateManyEmployeeInput = {
    id?: string
    employeeId: string
    firstName: string
    lastName: string
    email?: string | null
    phone?: string | null
    photo?: string | null
    departmentId?: string | null
    designation?: string | null
    joinDate?: Date | string
    employmentType?: string
    status?: string
    shiftId?: string | null
    salary?: number | null
    hourlyRate?: number | null
    cardNumber?: string | null
    faceEnrolled?: boolean
    fingerprintEnrolled?: boolean
    fingerprintTemplate?: string | null
    fingerprintTemplateDate?: Date | string | null
    userId?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type LeaveBalanceCreateManyEmployeeInput = {
    id: string
    leaveType: string
    year: number
    totalDays: number
    usedDays?: number
    remainingDays: number
  }

  export type LeaveRequestCreateManyEmployeeInput = {
    id: string
    leaveType: string
    startDate: Date | string
    endDate: Date | string
    totalDays: number
    reason?: string | null
    status?: string
    approvedById?: string | null
    approvedAt?: Date | string | null
    rejectionReason?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type NotificationCreateManyEmployeeInput = {
    id: string
    userId?: string | null
    type: string
    title: string
    message: string
    isRead?: boolean
    data?: string | null
    createdAt?: Date | string
  }

  export type ShiftAssignmentCreateManyEmployeeInput = {
    id: string
    shiftId: string
    startDate: Date | string
    endDate?: Date | string | null
    isActive?: boolean
    assignedById?: string | null
    createdAt?: Date | string
  }

  export type TimeEntryCreateManyEmployeeInput = {
    id: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    terminalId?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type PayrollDeductionCreateManyEmployeeInput = {
    id?: string
    deductionType: string
    amount: number
    reason?: string | null
    description?: string | null
    month: Date | string
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    appliedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type InfractionCreateManyEmployeeInput = {
    id?: string
    type: string
    severity?: string
    amount?: number | null
    description: string
    date: Date | string
    reportedBy?: string | null
    status?: string
    approvedBy?: string | null
    approvedAt?: Date | string | null
    notes?: string | null
    createdAt?: Date | string
    updatedAt?: Date | string
  }

  export type AttendanceLogUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Terminal?: TerminalUpdateOneWithoutAttendanceLogNestedInput
  }

  export type AttendanceLogUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type BiometricDataUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    data?: NullableStringFieldUpdateOperationsInput | string | null
    fingerNo?: NullableIntFieldUpdateOperationsInput | number | null
    enrolledAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type EmployeeUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUpdateManyWithoutEmployeeNestedInput
    department?: DepartmentUpdateOneWithoutEmployeesNestedInput
    other_Employee?: EmployeeUpdateManyWithoutEmployeeNestedInput
    shift?: ShiftUpdateOneWithoutEmployeesNestedInput
    User?: UserUpdateOneWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    AttendanceLog?: AttendanceLogUncheckedUpdateManyWithoutEmployeeNestedInput
    BiometricData?: BiometricDataUncheckedUpdateManyWithoutEmployeeNestedInput
    other_Employee?: EmployeeUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveBalance?: LeaveBalanceUncheckedUpdateManyWithoutEmployeeNestedInput
    LeaveRequest?: LeaveRequestUncheckedUpdateManyWithoutEmployeeNestedInput
    Notification?: NotificationUncheckedUpdateManyWithoutEmployeeNestedInput
    ShiftAssignment?: ShiftAssignmentUncheckedUpdateManyWithoutEmployeeNestedInput
    TimeEntry?: TimeEntryUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeRate?: EmployeeRateUncheckedUpdateOneWithoutEmployeeNestedInput
    EmployeeDeductions?: PayrollDeductionUncheckedUpdateManyWithoutEmployeeNestedInput
    EmployeeInfractions?: InfractionUncheckedUpdateManyWithoutEmployeeNestedInput
  }

  export type EmployeeUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    firstName?: StringFieldUpdateOperationsInput | string
    lastName?: StringFieldUpdateOperationsInput | string
    email?: NullableStringFieldUpdateOperationsInput | string | null
    phone?: NullableStringFieldUpdateOperationsInput | string | null
    photo?: NullableStringFieldUpdateOperationsInput | string | null
    departmentId?: NullableStringFieldUpdateOperationsInput | string | null
    designation?: NullableStringFieldUpdateOperationsInput | string | null
    joinDate?: DateTimeFieldUpdateOperationsInput | Date | string
    employmentType?: StringFieldUpdateOperationsInput | string
    status?: StringFieldUpdateOperationsInput | string
    shiftId?: NullableStringFieldUpdateOperationsInput | string | null
    salary?: NullableFloatFieldUpdateOperationsInput | number | null
    hourlyRate?: NullableFloatFieldUpdateOperationsInput | number | null
    cardNumber?: NullableStringFieldUpdateOperationsInput | string | null
    faceEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintEnrolled?: BoolFieldUpdateOperationsInput | boolean
    fingerprintTemplate?: NullableStringFieldUpdateOperationsInput | string | null
    fingerprintTemplateDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveBalanceUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveBalanceUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveBalanceUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    year?: IntFieldUpdateOperationsInput | number
    totalDays?: IntFieldUpdateOperationsInput | number
    usedDays?: IntFieldUpdateOperationsInput | number
    remainingDays?: IntFieldUpdateOperationsInput | number
  }

  export type LeaveRequestUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutLeaveRequestNestedInput
  }

  export type LeaveRequestUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type LeaveRequestUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    leaveType?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: DateTimeFieldUpdateOperationsInput | Date | string
    totalDays?: IntFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    rejectionReason?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type NotificationUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    userId?: NullableStringFieldUpdateOperationsInput | string | null
    type?: StringFieldUpdateOperationsInput | string
    title?: StringFieldUpdateOperationsInput | string
    message?: StringFieldUpdateOperationsInput | string
    isRead?: BoolFieldUpdateOperationsInput | boolean
    data?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Shift?: ShiftUpdateOneRequiredWithoutShiftAssignmentNestedInput
    AssignedBy?: UserUpdateOneWithoutShiftAssignmentsCreatedNestedInput
  }

  export type ShiftAssignmentUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type ShiftAssignmentUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    shiftId?: StringFieldUpdateOperationsInput | string
    startDate?: DateTimeFieldUpdateOperationsInput | Date | string
    endDate?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    isActive?: BoolFieldUpdateOperationsInput | boolean
    assignedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutTimeEntryNestedInput
    Terminal?: TerminalUpdateOneWithoutTimeEntryNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    terminalId?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ApprovedBy?: UserUpdateOneWithoutDeductionApprovalsNestedInput
  }

  export type PayrollDeductionUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type PayrollDeductionUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    deductionType?: StringFieldUpdateOperationsInput | string
    amount?: FloatFieldUpdateOperationsInput | number
    reason?: NullableStringFieldUpdateOperationsInput | string | null
    description?: NullableStringFieldUpdateOperationsInput | string | null
    month?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    appliedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    status?: StringFieldUpdateOperationsInput | string
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    ReportedBy?: UserUpdateOneWithoutInfractionReportsNestedInput
    ApprovedBy?: UserUpdateOneWithoutInfractionApprovalsNestedInput
  }

  export type InfractionUncheckedUpdateWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type InfractionUncheckedUpdateManyWithoutEmployeeInput = {
    id?: StringFieldUpdateOperationsInput | string
    type?: StringFieldUpdateOperationsInput | string
    severity?: StringFieldUpdateOperationsInput | string
    amount?: NullableFloatFieldUpdateOperationsInput | number | null
    description?: StringFieldUpdateOperationsInput | string
    date?: DateTimeFieldUpdateOperationsInput | Date | string
    reportedBy?: NullableStringFieldUpdateOperationsInput | string | null
    status?: StringFieldUpdateOperationsInput | string
    approvedBy?: NullableStringFieldUpdateOperationsInput | string | null
    approvedAt?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogCreateManyTerminalInput = {
    id: string
    employeeId: string
    eventType: string
    timestamp: Date | string
    verifyMethod?: string | null
    snapshot?: string | null
    temperature?: number | null
    maskDetected?: boolean | null
    processed?: boolean
    rawData?: string | null
    createdAt?: Date | string
  }

  export type TimeEntryCreateManyTerminalInput = {
    id: string
    employeeId: string
    clockIn: Date | string
    clockOut?: Date | string | null
    breakStart?: Date | string | null
    breakEnd?: Date | string | null
    totalHours?: number | null
    regularHours?: number | null
    overtimeHours?: number | null
    breakMinutes?: number | null
    status?: string
    location?: string | null
    verifyMethod?: string | null
    clockInPhoto?: string | null
    clockOutPhoto?: string | null
    notes?: string | null
    isManualEntry?: boolean
    approvedById?: string | null
    createdAt?: Date | string
    updatedAt: Date | string
  }

  export type AttendanceLogUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    Employee?: EmployeeUpdateOneRequiredWithoutAttendanceLogNestedInput
  }

  export type AttendanceLogUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type AttendanceLogUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    eventType?: StringFieldUpdateOperationsInput | string
    timestamp?: DateTimeFieldUpdateOperationsInput | Date | string
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    snapshot?: NullableStringFieldUpdateOperationsInput | string | null
    temperature?: NullableFloatFieldUpdateOperationsInput | number | null
    maskDetected?: NullableBoolFieldUpdateOperationsInput | boolean | null
    processed?: BoolFieldUpdateOperationsInput | boolean
    rawData?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
    User?: UserUpdateOneWithoutTimeEntryNestedInput
    Employee?: EmployeeUpdateOneRequiredWithoutTimeEntryNestedInput
  }

  export type TimeEntryUncheckedUpdateWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }

  export type TimeEntryUncheckedUpdateManyWithoutTerminalInput = {
    id?: StringFieldUpdateOperationsInput | string
    employeeId?: StringFieldUpdateOperationsInput | string
    clockIn?: DateTimeFieldUpdateOperationsInput | Date | string
    clockOut?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakStart?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    breakEnd?: NullableDateTimeFieldUpdateOperationsInput | Date | string | null
    totalHours?: NullableFloatFieldUpdateOperationsInput | number | null
    regularHours?: NullableFloatFieldUpdateOperationsInput | number | null
    overtimeHours?: NullableFloatFieldUpdateOperationsInput | number | null
    breakMinutes?: NullableIntFieldUpdateOperationsInput | number | null
    status?: StringFieldUpdateOperationsInput | string
    location?: NullableStringFieldUpdateOperationsInput | string | null
    verifyMethod?: NullableStringFieldUpdateOperationsInput | string | null
    clockInPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    clockOutPhoto?: NullableStringFieldUpdateOperationsInput | string | null
    notes?: NullableStringFieldUpdateOperationsInput | string | null
    isManualEntry?: BoolFieldUpdateOperationsInput | boolean
    approvedById?: NullableStringFieldUpdateOperationsInput | string | null
    createdAt?: DateTimeFieldUpdateOperationsInput | Date | string
    updatedAt?: DateTimeFieldUpdateOperationsInput | Date | string
  }



  /**
   * Aliases for legacy arg types
   */
    /**
     * @deprecated Use UserCountOutputTypeDefaultArgs instead
     */
    export type UserCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentCountOutputTypeDefaultArgs instead
     */
    export type DepartmentCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftCountOutputTypeDefaultArgs instead
     */
    export type ShiftCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeCountOutputTypeDefaultArgs instead
     */
    export type EmployeeCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerminalCountOutputTypeDefaultArgs instead
     */
    export type TerminalCountOutputTypeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerminalCountOutputTypeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use UserDefaultArgs instead
     */
    export type UserArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = UserDefaultArgs<ExtArgs>
    /**
     * @deprecated Use DepartmentDefaultArgs instead
     */
    export type DepartmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = DepartmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftDefaultArgs instead
     */
    export type ShiftArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeDefaultArgs instead
     */
    export type EmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InactiveEmployeeDefaultArgs instead
     */
    export type InactiveEmployeeArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InactiveEmployeeDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AuditLogDefaultArgs instead
     */
    export type AuditLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AuditLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use AttendanceLogDefaultArgs instead
     */
    export type AttendanceLogArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = AttendanceLogDefaultArgs<ExtArgs>
    /**
     * @deprecated Use BiometricDataDefaultArgs instead
     */
    export type BiometricDataArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = BiometricDataDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveBalanceDefaultArgs instead
     */
    export type LeaveBalanceArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveBalanceDefaultArgs<ExtArgs>
    /**
     * @deprecated Use LeaveRequestDefaultArgs instead
     */
    export type LeaveRequestArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = LeaveRequestDefaultArgs<ExtArgs>
    /**
     * @deprecated Use NotificationDefaultArgs instead
     */
    export type NotificationArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = NotificationDefaultArgs<ExtArgs>
    /**
     * @deprecated Use SettingDefaultArgs instead
     */
    export type SettingArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = SettingDefaultArgs<ExtArgs>
    /**
     * @deprecated Use ShiftAssignmentDefaultArgs instead
     */
    export type ShiftAssignmentArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = ShiftAssignmentDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TerminalDefaultArgs instead
     */
    export type TerminalArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TerminalDefaultArgs<ExtArgs>
    /**
     * @deprecated Use TimeEntryDefaultArgs instead
     */
    export type TimeEntryArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = TimeEntryDefaultArgs<ExtArgs>
    /**
     * @deprecated Use EmployeeRateDefaultArgs instead
     */
    export type EmployeeRateArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = EmployeeRateDefaultArgs<ExtArgs>
    /**
     * @deprecated Use PayrollDeductionDefaultArgs instead
     */
    export type PayrollDeductionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = PayrollDeductionDefaultArgs<ExtArgs>
    /**
     * @deprecated Use InfractionDefaultArgs instead
     */
    export type InfractionArgs<ExtArgs extends $Extensions.InternalArgs = $Extensions.DefaultArgs> = InfractionDefaultArgs<ExtArgs>

  /**
   * Batch Payload for updateMany & deleteMany & createMany
   */

  export type BatchPayload = {
    count: number
  }

  /**
   * DMMF
   */
  export const dmmf: runtime.BaseDMMF
}